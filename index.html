<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game Tree Editor - Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header {
            padding: 15px;
            border-bottom: 2px solid #eee;
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        /* ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò */
        .tab-nav {
            display: none;
            background: #f8f9fa;
            padding: 10px;
            gap: 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .tab-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            min-height: 500px;
            position: relative;
        }

        .panel {
            padding: 20px;
            overflow-y: auto;
        }

        .tree-panel {
            width: 100%;
            background: #fafafa;
            border-bottom: 1px solid #ddd;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease;
        }

        .tree-panel.collapsed {
            max-height: 0;
            overflow: hidden;
            border: none;
        }

        .tree-panel-bar {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background: #f1f2f6;
            border-bottom: 1px solid #ddd;
            gap: 10px;
        }

        .tree-panel-toggle {
            padding: 6px 12px;
            background: #3498db;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tree-panel-toggle:hover {
            background: #2980b9;
        }

        .tree-panel-header {
            padding: 10px 0;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }

        .tree-panel-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .tree-panel-controls button {
            flex: 1;
            padding: 8px 12px;
            font-size: 13px;
        }

        .resizer {
            display: none;
        }

        .editor-panel {
            flex: 1;
            background: white;
            max-height: 500px;
            border-top: 1px solid #ddd;
        }

        /* Tree Styles - Card Layout */
        .tree {
            font-size: 14px;
        }

        .scene-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .scene-card {
            background: white;
            border: 2px solid #007bff;
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s;
            cursor: pointer;
        }

        .scene-card:hover {
            box-shadow: 0 4px 12px rgba(0,123,255,0.2);
        }

        .scene-card.selected {
            border-color: #0056b3;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.3);
        }

        .scene-card.ending {
            border-color: #dc3545;
        }

        .scene-card.empty {
            border-style: dashed;
            opacity: 0.7;
        }

        .scene-card.highlight {
            animation: highlightPulse 1.5s ease;
        }

        @keyframes highlightPulse {
            0%, 100% { box-shadow: 0 0 0 3px rgba(0,123,255,0.3); }
            50% { box-shadow: 0 0 0 6px rgba(255,193,7,0.6); }
        }

        .scene-card-header {
            padding: 10px 12px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .scene-card.selected .scene-card-header {
            background: #007bff;
            color: white;
        }

        .scene-card.ending .scene-card-header {
            background: #fff5f5;
        }

        .scene-card-num {
            font-weight: bold;
            font-size: 13px;
        }

        .scene-card-badge {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        .ending-badge {
            background: #dc3545;
            color: white;
        }

        .scene-card-content {
            padding: 10px 12px;
            font-size: 13px;
            color: #555;
            line-height: 1.4;
            border-bottom: 1px solid #eee;
        }

        .scene-card-choices {
            padding: 8px;
            background: #fafafa;
        }

        .scene-card-choice {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .scene-card-choice:last-child {
            margin-bottom: 0;
        }

        .scene-card-choice:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        .scene-card-choice.selected {
            background: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        .scene-card-choice.success {
            border-left: 3px solid #28a745;
        }

        .scene-card-choice.failure {
            border-left: 3px solid #dc3545;
        }

        .scene-card-choice.empty {
            opacity: 0.6;
            border-style: dashed;
        }

        .choice-index {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: #007bff;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .scene-card-choice.selected .choice-index {
            background: white;
            color: #6c757d;
        }

        .choice-text-preview {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .choice-next {
            margin-left: 8px;
            padding: 2px 8px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            color: #007bff;
            cursor: pointer;
            flex-shrink: 0;
        }

        .choice-next:hover {
            background: #007bff;
            color: white;
        }

        .scene-card-choice.selected .choice-next {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .success-label, .failure-label {
            background: transparent;
        }

        .empty-next {
            background: #ffc107;
            color: #856404;
        }

        .orphan-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px dashed #ffc107;
        }

        .orphan-header {
            color: #856404;
            font-weight: bold;
            margin-bottom: 12px;
            font-size: 13px;
        }

        /* Editor Styles */
        .editor-section {
            margin-bottom: 15px;
        }

        .editor-label {
            font-weight: bold;
            margin-bottom: 6px;
            color: #333;
            font-size: 12px;
        }

        .editor-input, .editor-textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .editor-textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .choice-container {
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            background: #f9f9f9;
        }

        .choice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .next-scene-control {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .next-scene-input {
            width: 80px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 13px;
        }

        .auto-btn {
            padding: 6px 10px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }

        .delete-btn {
            padding: 5px 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }

        .add-choice-btn {
            padding: 10px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
        }

        .editor-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .editor-controls button {
            flex: 1;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }

        .checkbox-label input {
            width: 20px;
            height: 20px;
        }

        .status-bar {
            padding: 12px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            font-size: 13px;
            text-align: center;
        }

        .stats-info {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .stat-value {
            font-weight: bold;
            color: #007bff;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }

        /* Î™®Î∞îÏùº Ïä§ÌÉÄÏùº */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
                box-shadow: none;
            }

            .header {
                position: sticky;
                top: 0;
                background: white;
                z-index: 100;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }

            .tree-panel {
                max-height: none;
            }

            .title {
                font-size: 18px;
            }

            .buttons {
                gap: 5px;
            }

            button {
                padding: 8px 12px;
                font-size: 13px;
            }

            .tab-nav {
                display: flex;
                position: sticky;
                top: 60px;
                z-index: 99;
                background: white;
                border-bottom: 1px solid #ddd;
            }

            .panel {
                display: none;
                min-height: calc(100vh - 200px);
                max-height: none !important;
            }

            .panel.active {
                display: block;
            }

            /* Î™®Î∞îÏùºÏóêÏÑú Ìä∏Î¶¨ ÌÑ∞Ïπò ÏòÅÏó≠ ÌôïÎåÄ */
            .scene-node, .choice-node {
                padding: 10px 14px;
                font-size: 14px;
                margin: 4px 0;
            }

            .editor-input, .editor-textarea, .next-scene-input {
                font-size: 16px; /* iOS Ï§å Î∞©ÏßÄ */
            }

            .editor-controls {
                flex-direction: column;
            }

            .editor-controls button {
                width: 100%;
                padding: 12px;
            }

            .next-scene-control {
                flex-direction: column;
                align-items: stretch;
            }

            .next-scene-input {
                width: 100%;
            }

            .auto-btn {
                width: 100%;
                padding: 10px;
            }

            /* Ïä§ÌÅ¨Î°§ Í∞úÏÑ† */
            .tree-panel, .editor-panel {
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
            }

            /* ÌÑ∞Ïπò ÌîºÎìúÎ∞± */
            button:active, .scene-node:active, .choice-node:active {
                opacity: 0.8;
            }
        }

        /* ÌÉúÎ∏îÎ¶ø */
        @media (min-width: 769px) and (max-width: 1024px) {
            .tree-panel, .editor-panel {
                max-height: 350px;
            }
        }

        /* Í∞ÄÎ°ú Î™®Îìú ÏµúÏ†ÅÌôî */
        @media (max-width: 768px) and (orientation: landscape) {
            .header {
                padding: 10px;
            }

            .title {
                font-size: 16px;
                margin-bottom: 5px;
            }

            .panel {
                min-height: calc(100vh - 150px);
            }
        }

        /* ==================== Story Preview Panel ==================== */
        .story-preview-bar {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background: #f1f2f6;
            border-bottom: 1px solid #ddd;
            gap: 10px;
        }

        .preview-toggle {
            padding: 6px 12px;
            background: #6c5ce7;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .preview-toggle:hover {
            background: #5b4cdb;
        }

        .preview-toggle .toggle-icon {
            font-size: 10px;
        }

        .incognito-btn {
            margin-left: auto;
            padding: 6px 12px;
            background: #2d3436;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .incognito-btn:hover {
            background: #636e72;
        }

        .incognito-btn.active {
            background: #00b894;
        }

        .story-preview-container {
            background: #f8f9fa;
            border-bottom: 2px solid #ddd;
            max-height: 400px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }

        .story-preview-container.collapsed {
            max-height: 0;
            border: none;
            overflow: hidden;
        }

        .story-preview-container.expanded {
            max-height: 70vh;
        }

        .story-preview-content {
            padding: 15px;
        }

        .story-path {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #6c5ce7;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .path-header {
            font-weight: bold;
            color: #6c5ce7;
            font-size: 14px;
            padding-bottom: 10px;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .path-ending-tag {
            background: #e17055;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .path-ending-tag.incomplete {
            background: #636e72;
        }

        .path-scene {
            margin-bottom: 12px;
        }

        .path-scene-header {
            color: #6c5ce7;
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .path-scene-content {
            color: #333;
            font-size: 13px;
            line-height: 1.6;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            white-space: pre-wrap;
        }

        .path-choice {
            color: #00b894;
            font-weight: 600;
            font-size: 13px;
            padding: 8px 0 8px 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .path-choice .choice-num {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: #00b894;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .path-choice .choice-text {
            flex: 1;
        }

        .path-choices-container {
            margin-top: 8px;
            border-left: 2px solid #e0e0e0;
            margin-left: 10px;
        }

        .path-choice.unselected {
            color: #999;
            opacity: 0.5;
        }

        .path-choice.unselected .choice-num {
            background: #bbb;
        }

        .path-choice.selected {
            color: #00b894;
            opacity: 1;
        }

        .preview-edit-btn {
            padding: 2px 6px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .preview-edit-btn:hover {
            opacity: 1;
            background: #e0e0e0;
        }

        .preview-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .preview-edit-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .preview-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 16px;
        }

        .preview-edit-header button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }

        .preview-edit-content textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 15px;
        }

        .preview-edit-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .preview-edit-buttons button {
            padding: 8px 16px;
            border-radius: 5px;
            font-size: 14px;
        }

        .path-ending {
            margin-top: 10px;
            padding: 10px;
            background: rgba(225, 112, 85, 0.1);
            border-radius: 5px;
            color: #e17055;
            font-weight: 600;
            font-size: 13px;
        }

        .path-ending::before {
            content: "üîö ÏóîÎî©: ";
        }

        .path-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 8px;
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .path-nav-btn {
            padding: 8px 16px;
            background: #6c5ce7;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
        }

        .path-nav-btn:hover:not(:disabled) {
            background: #5b4cdb;
        }

        .path-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .path-nav-info {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        /* Tree View Styles */
        .tree-controls {
            display: flex;
            gap: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 8px;
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .tree-ctrl-btn {
            padding: 8px 14px;
            background: #6c5ce7;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .tree-ctrl-btn:hover {
            background: #5b4cdb;
        }

        /* Flat View Styles */
        .flat-story-container {
            font-size: 13px;
        }

        .flat-scene-block {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .flat-path-header {
            color: #6c5ce7;
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e8e6ff;
        }

        .flat-scene-content {
            color: #333;
            line-height: 1.7;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            white-space: pre-wrap;
            margin-bottom: 12px;
            position: relative;
        }

        .flat-scene-content .preview-edit-btn {
            position: absolute;
            top: 8px;
            right: 8px;
        }

        .flat-choices {
            margin-top: 10px;
        }

        .flat-choice-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 0;
            flex-wrap: wrap;
        }

        .flat-line {
            color: #999;
            font-family: monospace;
            flex-shrink: 0;
        }

        .flat-choice-num {
            color: #00b894;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
        }

        .flat-toggle {
            cursor: pointer;
            color: #6c5ce7;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            user-select: none;
            background: #f0eeff;
        }

        .flat-toggle:hover {
            background: #e8e6ff;
        }

        .flat-choice-text {
            color: #00b894;
            font-weight: 500;
            flex: 1;
        }

        .flat-arrow {
            color: #666;
            font-size: 12px;
        }

        .flat-arrow.flat-incomplete {
            color: #e17055;
        }

        .branch-count {
            color: #6c5ce7;
            font-size: 11px;
            background: #e8e6ff;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .flat-ending {
            color: #e17055;
            font-weight: bold;
            margin-top: 10px;
            padding: 10px;
            background: rgba(225, 112, 85, 0.1);
            border-radius: 5px;
            text-align: center;
        }

        .flat-incomplete-notice {
            color: #e17055;
            font-size: 12px;
            padding: 10px;
            background: rgba(225, 112, 85, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }

        .flat-empty {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        /* Incognito Theme */
        body.incognito {
            background: #f5f5f5;
        }

        body.incognito .title {
            color: #333;
        }

        body.incognito .title::before {
            content: "üìä ";
        }

        body.incognito .btn-primary,
        body.incognito .btn-success,
        body.incognito .btn-danger,
        body.incognito .btn-info {
            background: #6c757d;
        }

        body.incognito button[style*="9b59b6"] {
            background: #6c757d !important;
        }

        body.incognito .preview-toggle {
            background: #5f6368;
            color: #fff;
        }

        body.incognito .tree-panel-toggle {
            background: #5f6368;
            color: #fff;
        }

        body.incognito .tree-panel-bar {
            background: #f1f3f4;
            border-bottom-color: #e8eaed;
        }

        body.incognito .story-preview-container {
            background: #f8f9fa;
            border-bottom-color: #e8eaed;
        }

        body.incognito .story-path {
            border-left-color: #6c757d;
        }

        body.incognito .path-header {
            color: #495057;
        }

        body.incognito .path-ending-tag {
            background: #6c757d;
        }

        body.incognito .path-scene-header {
            color: #495057;
        }

        body.incognito .path-choice {
            color: #495057;
        }

        body.incognito .path-choice .choice-num {
            background: #6c757d;
        }

        body.incognito .path-choice.unselected {
            opacity: 0.3;
            color: #aaa;
        }

        body.incognito .path-choice.unselected .choice-num {
            background: #ccc;
        }

        body.incognito .path-choices-container {
            border-left-color: #ccc;
        }

        body.incognito .path-nav {
            background: #e0e0e0;
        }

        body.incognito .path-nav-btn {
            background: #6c757d;
        }

        body.incognito .path-nav-btn:hover:not(:disabled) {
            background: #5a6268;
        }

        body.incognito .path-ending {
            background: rgba(108, 117, 125, 0.1);
            color: #495057;
        }

        /* Tree View Incognito */
        body.incognito .tree-controls {
            background: #e0e0e0;
        }

        body.incognito .tree-ctrl-btn {
            background: #6c757d;
        }

        body.incognito .tree-ctrl-btn:hover {
            background: #5a6268;
        }

        body.incognito .tree-scene {
            border-left-color: #6c757d;
        }

        body.incognito .tree-scene-num {
            color: #495057;
        }

        body.incognito .tree-choice-num {
            background: #6c757d;
        }

        body.incognito .tree-toggle {
            color: #6c757d;
        }

        body.incognito .tree-toggle:hover {
            background: #e0e0e0;
        }

        body.incognito .tree-choice-text {
            color: #495057;
        }

        body.incognito .branch-count {
            background: #e0e0e0;
            color: #495057;
        }

        body.incognito .tree-ending {
            background: rgba(108, 117, 125, 0.1);
            color: #495057;
        }

        body.incognito .tree-branch-content {
            border-left-color: #ccc;
        }

        body.incognito .scene-card {
            border-color: #6c757d;
        }

        body.incognito .scene-card.selected .scene-card-header {
            background: #495057;
        }

        body.incognito .choice-index {
            background: #6c757d;
        }

        body.incognito .version-bar button {
            background: #6c757d !important;
            border-color: #6c757d !important;
        }

        body.incognito .tab-btn.active {
            background: #495057;
            border-color: #495057;
        }

        /* Flat View Incognito Styles - ÏóÖÎ¨¥Ïö© Î∞ùÏùÄ ÌÖåÎßà */
        body.incognito .flat-scene-block {
            background: #ffffff;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
            border: 1px solid #e0e0e0;
        }

        body.incognito .flat-path-header {
            color: #5f6368;
            border-bottom-color: #e8eaed;
        }

        body.incognito .flat-scene-content {
            color: #3c4043;
            background: #f8f9fa;
        }

        body.incognito .flat-choice-num {
            background: #e8eaed;
            color: #5f6368;
        }

        body.incognito .flat-toggle {
            color: #5f6368;
            background: #f1f3f4;
        }

        body.incognito .flat-toggle:hover {
            background: #e8eaed;
        }

        body.incognito .flat-choice-text {
            color: #3c4043;
        }

        body.incognito .flat-arrow {
            color: #80868b;
        }

        body.incognito .flat-ending {
            background: #f1f3f4;
            color: #5f6368;
        }

        body.incognito .flat-choice-row.unselected {
            opacity: 0.5;
        }

        body.incognito .branch-count {
            background: #e8eaed;
            color: #5f6368;
        }

        body.incognito .flat-incomplete-notice {
            color: #80868b;
        }

        body.incognito .flat-empty {
            color: #9aa0a6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">üéÆ Game Tree Editor</h1>
            <div class="buttons">
                <button class="btn-primary" onclick="saveToLocal()">üíæ Ï†ÄÏû•</button>
                <button class="btn-primary" onclick="loadFromLocal()">üìÇ Ïó¥Í∏∞</button>
                <button class="btn-success" onclick="exportJSON()">üì§ JSON</button>
                <button class="btn-info" onclick="importJSON()">üì• Í∞ÄÏ†∏Ïò§Í∏∞</button>
                <button style="background: #9b59b6; color: white;" onclick="showPlayDialog()">‚ñ∂Ô∏è ÌîåÎ†àÏù¥ÌïòÍ∏∞</button>
                <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Ï¥àÍ∏∞Ìôî</button>
            </div>
        </div>

        <!-- Ïä§ÌÜ†Î¶¨ Î≤ÑÏ†Ñ ÏÑ†ÌÉù Î∞î -->
        <div class="version-bar" style="padding: 10px 15px; background: #f8f9fa; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <span style="font-weight: bold; color: #555;">üìö Ïä§ÌÜ†Î¶¨:</span>
            <div id="versionTabs" style="display: flex; gap: 5px; flex-wrap: wrap;"></div>
            <button onclick="addNewVersion()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;" id="addVersionBtn">‚ûï ÏÉà Î≤ÑÏ†Ñ</button>
            <button onclick="importAsNewVersion()" style="padding: 6px 12px; background: #17a2b8; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">üì• ÏÉà Î≤ÑÏ†ÑÏúºÎ°ú</button>
            <button onclick="appendToCurrentVersion()" style="padding: 6px 12px; background: #fd7e14; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">üìé Ïù¥Ïñ¥Î∂ôÏù¥Í∏∞</button>
        </div>

        <!-- Story Preview Bar -->
        <div class="story-preview-bar">
            <button class="preview-toggle" id="previewToggle" onclick="toggleStoryPreview()">
                <span class="toggle-icon">‚ñº</span> üìñ Ïä§ÌÜ†Î¶¨ ÌîÑÎ¶¨Î∑∞
            </button>
            <button class="incognito-btn" id="incognitoBtn" onclick="toggleIncognito()">üï∂Ô∏è Work</button>
        </div>

        <!-- Story Preview Container -->
        <div class="story-preview-container" id="storyPreviewContainer">
            <div class="story-preview-content" id="storyPreviewContent">
                <div style="color:#666;text-align:center;padding:20px;">Î°úÎî© Ï§ë...</div>
            </div>
        </div>

        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('tree')">üå≥ Ìä∏Î¶¨</button>
            <button class="tab-btn" onclick="switchTab('editor')">‚úèÔ∏è Ìé∏Ïßë</button>
        </div>

        <!-- Tree Panel Toggle Bar -->
        <div class="tree-panel-bar">
            <button class="tree-panel-toggle" id="treePanelToggle" onclick="toggleTreePanel()">
                <span class="toggle-icon">‚ñº</span> üå≥ Ïî¨ Ìä∏Î¶¨
            </button>
        </div>

        <div class="main-content">
            <div class="panel tree-panel active" id="treePanel">
                <div class="tree-panel-header">
                    <div class="tree-panel-controls">
                        <button class="btn-success" onclick="showAddSceneDialog()">‚ûï ÏÉà Ïî¨</button>
                        <button class="btn-info" onclick="showAllScenes()">üìã Ï†ÑÏ≤¥ Î™©Î°ù</button>
                        <button class="btn-danger" onclick="showAllEndings()">üîö ÏóîÎî© Î™®ÏïÑÎ≥¥Í∏∞</button>
                    </div>
                </div>
                <div class="tree" id="tree" style="flex: 1; overflow-y: auto;">
                    <div class="empty-state">Î°úÎî© Ï§ë...</div>
                </div>
            </div>

            <div class="resizer" id="resizer"></div>

            <div class="panel editor-panel" id="editorPanel">
                <div id="editor">
                    <div class="empty-state">
                        Ìä∏Î¶¨ÏóêÏÑú Ïî¨Ïù¥ÎÇò ÏÑ†ÌÉùÏßÄÎ•º ÌÉ≠ÌïòÏó¨ Ìé∏ÏßëÌïòÏÑ∏Ïöî
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusMessage">Ï§ÄÎπÑÎê®</div>
            <div class="stats-info">
                <div>ÏÇ¨Ïö©: <span class="stat-value" id="usedScenes">1</span></div>
                <div>ÎÇ®Ïùå: <span class="stat-value" id="availableScenes">999</span></div>
                <div>Ï†ÑÏ≤¥: <span class="stat-value">1000</span></div>
                <div style="border-left: 1px solid #ddd; padding-left: 15px;">‚è±Ô∏è ÏòàÏÉÅ: <span class="stat-value" id="estimatedTime">0Î∂Ñ</span></div>
            </div>
        </div>
    </div>


    <script>
        // Ïä§ÌÜ†Î¶¨ Î≤ÑÏ†Ñ Í¥ÄÎ¶¨
        const MAX_VERSIONS = 5;
        let storyVersions = []; // [{name: "Î≤ÑÏ†Ñ1", data: {...}, title: "Catch! Love"}, ...]
        let currentVersionIndex = 0;

        // ÌòÑÏû¨ Î≤ÑÏ†ÑÏùò Îç∞Ïù¥ÌÑ∞ (Í∏∞Ï°¥ ÏΩîÎìúÏôÄÏùò Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ getter/setter ÏÇ¨Ïö©)
        let gameData = {};
        let selectedNode = null;
        let selectedType = null;
        let usedSceneNumbers = new Set();
        let isMobile = window.innerWidth <= 768;
        let gameTitle = "Catch! Love"; // Í≤åÏûÑ Ï†úÎ™©
        let currentEditingScene = null; // ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ Ïî¨ Î≤àÌò∏
        let currentEditingChoice = null; // ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ ÏÑ†ÌÉùÏßÄ {scene, index}
        let autoSaveTimer = null; // ÏûêÎèô Ï†ÄÏû• ÌÉÄÏù¥Î®∏

        // Î≤ÑÏ†Ñ ÌÉ≠ Î†åÎçîÎßÅ
        function renderVersionTabs() {
            const container = document.getElementById('versionTabs');
            let html = '';

            storyVersions.forEach((version, index) => {
                const isActive = index === currentVersionIndex;
                const sceneCount = Object.keys(version.data).filter(k => version.data[k]?.content).length;
                html += `
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <button onclick="switchVersion(${index})" style="
                            padding: 6px 12px;
                            background: ${isActive ? '#007bff' : '#e9ecef'};
                            color: ${isActive ? 'white' : '#333'};
                            border: ${isActive ? '2px solid #0056b3' : '1px solid #ccc'};
                            border-radius: 5px 0 0 5px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: ${isActive ? 'bold' : 'normal'};
                        ">${version.name} (${sceneCount}Ïî¨)</button>
                        ${storyVersions.length > 1 ? `
                            <button onclick="deleteVersion(${index})" style="
                                padding: 6px 8px;
                                background: ${isActive ? '#dc3545' : '#f8d7da'};
                                color: ${isActive ? 'white' : '#721c24'};
                                border: 1px solid ${isActive ? '#c82333' : '#f5c6cb'};
                                border-radius: 0 5px 5px 0;
                                cursor: pointer;
                                font-size: 10px;
                            ">‚úï</button>
                        ` : `
                            <span style="
                                padding: 6px 8px;
                                background: #e9ecef;
                                color: #aaa;
                                border: 1px solid #ccc;
                                border-radius: 0 5px 5px 0;
                                font-size: 10px;
                            ">‚úï</span>
                        `}
                    </div>`;
            });

            container.innerHTML = html;

            // Î≤ÑÏ†Ñ Ï∂îÍ∞Ä Î≤ÑÌäº ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
            const addBtn = document.getElementById('addVersionBtn');
            if (storyVersions.length >= MAX_VERSIONS) {
                addBtn.disabled = true;
                addBtn.style.opacity = '0.5';
                addBtn.title = 'ÏµúÎåÄ 5Í∞úÍπåÏßÄÎßå ÏÉùÏÑ± Í∞ÄÎä•Ìï©ÎãàÎã§';
            } else {
                addBtn.disabled = false;
                addBtn.style.opacity = '1';
                addBtn.title = '';
            }
        }

        // Î≤ÑÏ†Ñ Ï†ÑÌôò
        function switchVersion(index) {
            if (index < 0 || index >= storyVersions.length) return;

            // ÌòÑÏû¨ Î≤ÑÏ†Ñ Ï†ÄÏû•
            autoSaveCurrentEdit();
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            // ÏÉà Î≤ÑÏ†ÑÏúºÎ°ú Ï†ÑÌôò
            currentVersionIndex = index;
            gameData = storyVersions[index].data;
            gameTitle = storyVersions[index].title || "Catch! Love";

            // UI ÏóÖÎç∞Ïù¥Ìä∏
            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();

            // ÏóêÎîîÌÑ∞ Ï¥àÍ∏∞Ìôî
            document.getElementById('editor').innerHTML = '<div class="empty-state">Ïî¨ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>';
            selectedNode = null;
            selectedType = null;
            currentEditingScene = null;
            currentEditingChoice = null;

            updateStatus(`"${storyVersions[index].name}" Î≤ÑÏ†ÑÏúºÎ°ú Ï†ÑÌôòÎê®`);
        }

        // ÏÉà Î≤ÑÏ†Ñ Ï∂îÍ∞Ä
        function addNewVersion() {
            if (storyVersions.length >= MAX_VERSIONS) {
                alert(`ÏµúÎåÄ ${MAX_VERSIONS}Í∞úÍπåÏßÄÎßå ÏÉùÏÑ± Í∞ÄÎä•Ìï©ÎãàÎã§.`);
                return;
            }

            const name = prompt('ÏÉà Î≤ÑÏ†Ñ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', `Î≤ÑÏ†Ñ ${storyVersions.length + 1}`);
            if (!name) return;

            // ÌòÑÏû¨ Î≤ÑÏ†Ñ Ï†ÄÏû•
            autoSaveCurrentEdit();
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            // ÏÉà Î≤ÑÏ†Ñ ÏÉùÏÑ± (Îπà Ïä§ÌÜ†Î¶¨)
            const newVersion = {
                name: name,
                title: "Catch! Love",
                data: { 1: { content: '', isEnding: false, choices: [] } }
            };

            storyVersions.push(newVersion);
            currentVersionIndex = storyVersions.length - 1;
            gameData = newVersion.data;
            gameTitle = newVersion.title;

            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();
            updateStatus(`"${name}" Î≤ÑÏ†ÑÏù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.`);
        }

        // ÌååÏùºÏùÑ ÏÉà Î≤ÑÏ†ÑÏúºÎ°ú Î∂àÎü¨Ïò§Í∏∞
        function importAsNewVersion() {
            if (storyVersions.length >= MAX_VERSIONS) {
                alert(`ÏµúÎåÄ ${MAX_VERSIONS}Í∞úÍπåÏßÄÎßå ÏÉùÏÑ± Í∞ÄÎä•Ìï©ÎãàÎã§.`);
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);

                        // ÌòÑÏû¨ Î≤ÑÏ†Ñ Ï†ÄÏû•
                        autoSaveCurrentEdit();
                        storyVersions[currentVersionIndex].data = gameData;
                        storyVersions[currentVersionIndex].title = gameTitle;

                        // ÏÉà Î≤ÑÏ†Ñ ÏÉùÏÑ±
                        const name = prompt('Î≤ÑÏ†Ñ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', story.title || `Î≤ÑÏ†Ñ ${storyVersions.length + 1}`);
                        if (!name) return;

                        const newVersion = {
                            name: name,
                            title: story.title || "Catch! Love",
                            data: {}
                        };

                        // STORY ÌòïÏãùÏùÑ ÏóêÎîîÌÑ∞ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                        if (story.scenes && Array.isArray(story.scenes)) {
                            story.scenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const num = parseInt(match[1]);
                                if (num < 1 || num > 1000) return;

                                newVersion.data[num] = {
                                    content: scene.content || '',
                                    isEnding: scene.isEnding || false,
                                    choices: []
                                };

                                if (!scene.isEnding && scene.choices) {
                                    scene.choices.forEach(choice => {
                                        if (choice.label) {
                                            let nextNum = 0;
                                            if (choice.nextSceneId) {
                                                const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                                if (nextMatch) nextNum = parseInt(nextMatch[1]);
                                            }
                                            newVersion.data[num].choices.push({
                                                text: choice.label,
                                                next: nextNum,
                                                outcome: choice.outcome || 'continue'
                                            });
                                        }
                                    });
                                }
                            });
                        }

                        // ÏµúÏÜå Ïî¨ 1Ïù¥ÎùºÎèÑ ÏûàÍ≤å
                        if (!newVersion.data[1]) {
                            newVersion.data[1] = { content: '', isEnding: false, choices: [] };
                        }

                        storyVersions.push(newVersion);
                        currentVersionIndex = storyVersions.length - 1;
                        gameData = newVersion.data;
                        gameTitle = newVersion.title;

                        updateUsedScenes();
                        renderTree();
                        renderVersionTabs();
                        saveAllVersionsToLocal();
                        updateStatus(`"${name}" Î≤ÑÏ†ÑÏúºÎ°ú ÌååÏùºÏùÑ Î∂àÎü¨ÏôîÏäµÎãàÎã§.`);

                    } catch (err) {
                        alert('JSON ÌååÏã± Ïã§Ìå®: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ÌòÑÏû¨ Î≤ÑÏ†ÑÏóê ÌååÏùº ÎÇ¥Ïö© Ïù¥Ïñ¥Î∂ôÏù¥Í∏∞
        function appendToCurrentVersion() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);

                        // ÌòÑÏû¨ Ìé∏Ïßë ÎÇ¥Ïö© Ï†ÄÏû•
                        autoSaveCurrentEdit();

                        // ÌòÑÏû¨ Î≤ÑÏ†ÑÏóêÏÑú ÏÇ¨Ïö© Ï§ëÏù∏ ÏµúÎåÄ Ïî¨ Î≤àÌò∏ Ï∞æÍ∏∞
                        let maxSceneNum = 0;
                        for (let i = 1; i <= 1000; i++) {
                            if (gameData[i] && gameData[i].content) {
                                maxSceneNum = i;
                            }
                        }

                        // Î∂àÎü¨Ïò® ÌååÏùºÏùò Ïî¨ Î≤àÌò∏ Îß§Ìïë (Í∏∞Ï°¥ Ïî¨ Ïù¥ÌõÑÎ°ú Ïù¥Ïñ¥Î∂ôÏù¥Í∏∞)
                        const sceneMapping = {}; // ÏõêÎûò Ïî¨ Î≤àÌò∏ -> ÏÉà Ïî¨ Î≤àÌò∏
                        let importedCount = 0;

                        if (story.scenes && Array.isArray(story.scenes)) {
                            // Î®ºÏ†Ä Ïî¨ Î≤àÌò∏ Îß§Ìïë ÏÉùÏÑ±
                            const sortedScenes = [...story.scenes].sort((a, b) => {
                                const numA = parseInt(a.id.match(/S(\d+)/)?.[1] || 0);
                                const numB = parseInt(b.id.match(/S(\d+)/)?.[1] || 0);
                                return numA - numB;
                            });

                            sortedScenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const originalNum = parseInt(match[1]);
                                const newNum = maxSceneNum + originalNum;

                                if (newNum > 1000) return; // 1000 Ï¥àÍ≥ºÌïòÎ©¥ Ïä§ÌÇµ

                                sceneMapping[originalNum] = newNum;
                            });

                            // Ïî¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
                            sortedScenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const originalNum = parseInt(match[1]);
                                const newNum = sceneMapping[originalNum];

                                if (!newNum || newNum > 1000) return;

                                gameData[newNum] = {
                                    content: scene.content || '',
                                    isEnding: scene.isEnding || false,
                                    choices: []
                                };

                                if (!scene.isEnding && scene.choices) {
                                    scene.choices.forEach(choice => {
                                        // label ÎòêÎäî text Îëò Îã§ ÏßÄÏõê
                                        const choiceText = choice.label || choice.text || '';
                                        if (choiceText) {
                                            let nextNum = 0;
                                            // nextSceneId ÎòêÎäî next Îëò Îã§ ÏßÄÏõê
                                            const nextSceneId = choice.nextSceneId || '';
                                            const directNext = choice.next || 0;

                                            if (nextSceneId) {
                                                const nextMatch = nextSceneId.match(/S(\d+)/);
                                                if (nextMatch) {
                                                    const originalNext = parseInt(nextMatch[1]);
                                                    nextNum = sceneMapping[originalNext] || 0;
                                                }
                                            } else if (directNext > 0) {
                                                // ÏßÅÏ†ë Ïà´ÏûêÎ°ú Îêú nextÎèÑ Îß§Ìïë
                                                nextNum = sceneMapping[directNext] || 0;
                                            }

                                            gameData[newNum].choices.push({
                                                text: choiceText,
                                                next: nextNum,
                                                outcome: choice.outcome || 'continue'
                                            });
                                        }
                                    });
                                }

                                importedCount++;
                            });
                        }

                        // Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî
                        storyVersions[currentVersionIndex].data = gameData;

                        updateUsedScenes();
                        renderTree();
                        renderVersionTabs();
                        saveAllVersionsToLocal();
                        updateStatus(`${importedCount}Í∞ú Ïî¨ÏùÑ ÌòÑÏû¨ Î≤ÑÏ†ÑÏóê Ï∂îÍ∞ÄÌñàÏäµÎãàÎã§. (Ïî¨ ${maxSceneNum + 1}Î∂ÄÌÑ∞)`);

                    } catch (err) {
                        alert('JSON ÌååÏã± Ïã§Ìå®: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Î≤ÑÏ†Ñ ÏÇ≠Ï†ú
        function deleteVersion(index) {
            if (storyVersions.length <= 1) {
                alert('ÏµúÏÜå 1Í∞úÏùò Î≤ÑÏ†ÑÏùÄ Ïú†ÏßÄÌï¥Ïïº Ìï©ÎãàÎã§.');
                return;
            }

            const version = storyVersions[index];
            if (!confirm(`"${version.name}" Î≤ÑÏ†ÑÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?\nÎ™®Îì† Ïî¨Ïù¥ ÏÇ≠Ï†úÎê©ÎãàÎã§.`)) {
                return;
            }

            storyVersions.splice(index, 1);

            // ÌòÑÏû¨ Î≤ÑÏ†ÑÏù¥ ÏÇ≠Ï†úÎêòÏóàÍ±∞ÎÇò Ïù∏Îç±Ïä§ Ï°∞Ï†ï ÌïÑÏöî
            if (currentVersionIndex >= storyVersions.length) {
                currentVersionIndex = storyVersions.length - 1;
            } else if (currentVersionIndex > index) {
                currentVersionIndex--;
            }

            // ÌòÑÏû¨ Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
            gameData = storyVersions[currentVersionIndex].data;
            gameTitle = storyVersions[currentVersionIndex].title || "Catch! Love";

            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();
            updateStatus(`Î≤ÑÏ†ÑÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.`);
        }

        // Î™®Îì† Î≤ÑÏ†ÑÏùÑ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•
        function saveAllVersionsToLocal() {
            // ÌòÑÏû¨ Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            localStorage.setItem('gameTreeVersions', JSON.stringify({
                versions: storyVersions,
                currentIndex: currentVersionIndex
            }));
        }

        // Î™®Îì† Î≤ÑÏ†ÑÏùÑ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞
        function loadAllVersionsFromLocal() {
            const saved = localStorage.getItem('gameTreeVersions');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    storyVersions = data.versions || [];
                    currentVersionIndex = data.currentIndex || 0;

                    if (storyVersions.length === 0) {
                        initDefaultVersion();
                    } else {
                        // Ïù∏Îç±Ïä§ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                        if (currentVersionIndex >= storyVersions.length) {
                            currentVersionIndex = 0;
                        }
                        gameData = storyVersions[currentVersionIndex].data;
                        gameTitle = storyVersions[currentVersionIndex].title || "Catch! Love";
                    }
                    return true;
                } catch (e) {
                    console.error('Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', e);
                }
            }
            return false;
        }

        // Í∏∞Î≥∏ Î≤ÑÏ†Ñ Ï¥àÍ∏∞Ìôî
        function initDefaultVersion() {
            storyVersions = [{
                name: 'Î≤ÑÏ†Ñ 1',
                title: 'Catch! Love',
                data: { 1: { content: '', isEnding: false, choices: [] } }
            }];
            currentVersionIndex = 0;
            gameData = storyVersions[0].data;
            gameTitle = storyVersions[0].title;
        }

        // JSON ÌååÏùºÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        async function loadFromJSON() {
            try {
                const response = await fetch('./Catch!-Love.json');
                if (!response.ok) throw new Error('Failed to load JSON');
                const story = await response.json();

                const convertedData = {};
                for (let i = 1; i <= 1000; i++) {
                    convertedData[i] = { content: '', isEnding: false, choices: [] };
                }

                if (story.scenes && Array.isArray(story.scenes)) {
                    story.scenes.forEach(scene => {
                        const match = scene.id.match(/S(\d+)/);
                        if (!match) return;

                        const num = parseInt(match[1]);
                        if (num < 1 || num > 1000) return;

                        convertedData[num] = {
                            content: scene.content || '',
                            isEnding: scene.isEnding || false,
                            choices: [],
                            name: scene.name || '',
                            endingInfo: scene.endingInfo || null
                        };

                        if (!scene.isEnding && scene.choices) {
                            scene.choices.forEach(choice => {
                                if (choice.label) {
                                    let nextNum = 0;
                                    if (choice.nextSceneId) {
                                        const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                        if (nextMatch) nextNum = parseInt(nextMatch[1]);
                                    }
                                    convertedData[num].choices.push({
                                        text: choice.label,
                                        next: nextNum,
                                        outcome: choice.outcome || 'continue'
                                    });
                                }
                            });
                        }
                    });
                }

                storyVersions = [{
                    name: 'Î≤ÑÏ†Ñ 1',
                    title: story.title || 'Catch! Love',
                    data: convertedData
                }];
                currentVersionIndex = 0;
                gameData = storyVersions[0].data;
                gameTitle = storyVersions[0].title;
                return true;
            } catch (e) {
                console.error('JSON Î°úÎìú Ïã§Ìå®:', e);
                return false;
            }
        }

        // ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥ Í¥ÄÎ†® Î≥ÄÏàò
        let testCurrentScene = 1;
        let testPathHistory = []; // ÌëúÏãúÏö© Í≤ΩÎ°ú
        let testSceneStack = []; // Îí§Î°úÍ∞ÄÍ∏∞Ïö© Ïî¨ Ïä§ÌÉù

        // ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥ ÏãúÏûë (Ïî¨ 1Î∂ÄÌÑ∞)
        function startTestPlay() {
            // ÌòÑÏû¨ Ìé∏Ïßë ÎÇ¥Ïö© Ï†ÄÏû•
            autoSaveCurrentEdit();

            // Ïî¨ 1Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            if (!gameData[1] || !gameData[1].content) {
                alert('Ïî¨ 1Ïóê ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            testCurrentScene = 1;
            testPathHistory = [];
            testSceneStack = [];
            document.getElementById('testPlayModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            showTestScene(1, false);
        }

        // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïî¨Î∂ÄÌÑ∞ ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥ ÏãúÏûë
        function startTestPlayFromCurrent() {
            // ÌòÑÏû¨ Ìé∏Ïßë ÎÇ¥Ïö© Ï†ÄÏû•
            autoSaveCurrentEdit();

            const startScene = currentEditingScene || 1;

            // ÏÑ†ÌÉùÎêú Ïî¨Ïù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            if (!gameData[startScene] || !gameData[startScene].content) {
                alert(`Ïî¨ ${startScene}Ïóê ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.`);
                return;
            }

            testCurrentScene = startScene;
            testPathHistory = [];
            testSceneStack = [];
            document.getElementById('testPlayModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            showTestScene(startScene, false);
        }

        // "ÌòÑÏû¨ Ïî¨" ÌÖåÏä§Ìä∏ Î≤ÑÌäº ÌëúÏãú/Ïà®ÍπÄ
        function updateTestFromCurrentButton() {
            const btn = document.getElementById('testFromCurrentBtn');
            if (currentEditingScene && currentEditingScene !== 1) {
                btn.style.display = 'inline-block';
                btn.textContent = `‚ñ∂Ô∏è Ïî¨ ${currentEditingScene}Î∂ÄÌÑ∞`;
            } else {
                btn.style.display = 'none';
            }
        }

        // ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥ Îã´Í∏∞
        function closeTestPlay() {
            document.getElementById('testPlayModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        // ÌÖåÏä§Ìä∏ ÌîåÎ†àÏù¥ Ïû¨ÏãúÏûë
        function restartTestPlay() {
            testCurrentScene = 1;
            testPathHistory = [];
            testSceneStack = [];
            showTestScene(1, false);
        }

        // Ïù¥Ï†Ñ Ïî¨ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞
        function goBackTestPlay() {
            if (testSceneStack.length > 0) {
                // ÌòÑÏû¨ Ïî¨ÏóêÏÑú Ï∂îÍ∞ÄÎêú Í≤ΩÎ°ú Ï†úÍ±∞ (Ïî¨ + ÏÑ†ÌÉù)
                if (testPathHistory.length > 0) testPathHistory.pop(); // ÏÑ†ÌÉù Ï†úÍ±∞
                if (testPathHistory.length > 0) testPathHistory.pop(); // Ïî¨ Ï†úÍ±∞

                const prevScene = testSceneStack.pop();
                showTestScene(prevScene, false);
            }
        }

        // Îí§Î°úÍ∞ÄÍ∏∞ Î≤ÑÌäº ÌëúÏãú/Ïà®ÍπÄ
        function updateBackButton() {
            const backBtn = document.getElementById('testBackBtn');
            if (testSceneStack.length > 0) {
                backBtn.style.display = 'inline-block';
            } else {
                backBtn.style.display = 'none';
            }
        }

        // ÌÖåÏä§Ìä∏ Ïî¨ ÌëúÏãú
        function showTestScene(sceneNum, addToStack = true) {
            const scene = gameData[sceneNum];

            // Ïä§ÌÉùÏóê ÌòÑÏû¨ Ïî¨ Ï†ÄÏû• (Îí§Î°úÍ∞ÄÍ∏∞Ïö©)
            if (addToStack && testCurrentScene !== sceneNum) {
                testSceneStack.push(testCurrentScene);
            }

            testCurrentScene = sceneNum;

            // Í≤ΩÎ°ú Í∏∞Î°ù
            testPathHistory.push(`Ïî¨ ${sceneNum}`);
            document.getElementById('testPathHistory').textContent = testPathHistory.join(' ‚Üí ');

            // Ïî¨ Î≤àÌò∏ ÌëúÏãú
            document.getElementById('testSceneNumber').textContent = `üìç Ïî¨ ${sceneNum}`;

            // Îí§Î°úÍ∞ÄÍ∏∞ Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
            updateBackButton();

            if (!scene || !scene.content) {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="color: #dc3545; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
                        <div style="font-size: 18px; font-weight: bold;">Ïî¨ ${sceneNum}Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§</div>
                        <div style="color: #666; margin-top: 10px;">ÏóêÎîîÌÑ∞ÏóêÏÑú Ïù¥ Ïî¨Ïùò ÎÇ¥Ïö©ÏùÑ ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.</div>
                    </div>`;
                document.getElementById('testChoices').innerHTML = '';
                return;
            }

            // Ïî¨ ÎÇ¥Ïö© ÌëúÏãú
            document.getElementById('testSceneContent').textContent = scene.content;

            // ÏÑ†ÌÉùÏßÄ ÎòêÎäî ÏóîÎî© ÌëúÏãú
            const choicesDiv = document.getElementById('testChoices');

            if (scene.isEnding) {
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px;">
                        <div style="font-size: 48px; margin-bottom: 15px;">üéâ</div>
                        <div style="font-size: 24px; color: white; font-weight: bold;">~ THE END ~</div>
                        <div style="color: rgba(255,255,255,0.9); margin-top: 10px;">ÏóîÎî©Ïóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§!</div>
                    </div>`;
            } else if (scene.choices && scene.choices.length > 0) {
                let choicesHTML = '';
                scene.choices.forEach((choice, index) => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';
                        let btnColor = '#007bff';
                        let outcomeLabel = '';

                        if (outcome === 'success') {
                            btnColor = '#28a745';
                            outcomeLabel = ' üéâ';
                        } else if (outcome === 'failure') {
                            btnColor = '#dc3545';
                            outcomeLabel = ' üíî';
                        }

                        choicesHTML += `
                            <button onclick="selectTestChoice(${sceneNum}, ${index})" style="
                                padding: 15px 20px;
                                background: ${btnColor};
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-size: 15px;
                                cursor: pointer;
                                text-align: left;
                                transition: all 0.3s;
                            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                                ${index + 1}. ${choice.text}${outcomeLabel}
                            </button>`;
                    }
                });

                if (choicesHTML === '') {
                    choicesHTML = `<div style="color: white; text-align: center; padding: 20px;">ÏÑ†ÌÉùÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§. ÏóêÎîîÌÑ∞ÏóêÏÑú ÏÑ†ÌÉùÏßÄÎ•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.</div>`;
                }

                choicesDiv.innerHTML = choicesHTML;
            } else {
                choicesDiv.innerHTML = `<div style="color: white; text-align: center; padding: 20px;">ÏÑ†ÌÉùÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§. ÏóêÎîîÌÑ∞ÏóêÏÑú ÏÑ†ÌÉùÏßÄÎ•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.</div>`;
            }
        }

        // ÌÖåÏä§Ìä∏ ÏÑ†ÌÉùÏßÄ ÏÑ†ÌÉù
        function selectTestChoice(sceneNum, choiceIndex) {
            const choice = gameData[sceneNum].choices[choiceIndex];
            if (!choice) return;

            const outcome = choice.outcome || 'continue';

            // Í≤ΩÎ°úÏóê ÏÑ†ÌÉù Í∏∞Î°ù
            testPathHistory.push(`"${choice.text.substring(0, 15)}${choice.text.length > 15 ? '...' : ''}"`);

            if (outcome === 'success') {
                showTestEnding('success');
            } else if (outcome === 'failure') {
                showTestEnding('failure');
            } else if (choice.next && choice.next > 0) {
                showTestScene(choice.next);
            } else {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="color: #ffc107; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 15px;">‚ö†Ô∏è</div>
                        <div style="font-size: 18px; font-weight: bold;">Îã§Ïùå Ïî¨Ïù¥ ÏßÄÏ†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§</div>
                        <div style="color: #666; margin-top: 10px;">ÏóêÎîîÌÑ∞ÏóêÏÑú Ïù¥ ÏÑ†ÌÉùÏßÄÏùò Îã§Ïùå Ïî¨ Î≤àÌò∏Î•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.</div>
                    </div>`;
                document.getElementById('testChoices').innerHTML = '';
            }
        }

        // ÌÖåÏä§Ìä∏ ÏóîÎî© ÌëúÏãú
        function showTestEnding(type) {
            document.getElementById('testPathHistory').textContent = testPathHistory.join(' ‚Üí ');

            const choicesDiv = document.getElementById('testChoices');

            if (type === 'success') {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">üíï</div>
                        <div style="font-size: 28px; color: #e91e63; font-weight: bold;">SUCCESS!</div>
                        <div style="color: #666; margin-top: 15px; font-size: 16px;">Ï∂ïÌïòÌï©ÎãàÎã§! ÏÑ±Í≥µ ÏóîÎî©Ïóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§.</div>
                    </div>`;
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px;">
                        <div style="font-size: 20px; color: white; font-weight: bold;">üéâ THE END üéâ</div>
                    </div>`;
            } else {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">üíî</div>
                        <div style="font-size: 28px; color: #607d8b; font-weight: bold;">MAYBE NEXT TIME...</div>
                        <div style="color: #666; margin-top: 15px; font-size: 16px;">Îã§Î•∏ ÏÑ†ÌÉùÏùÑ Ìï¥Î≥¥ÏÑ∏Ïöî.</div>
                    </div>`;
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); border-radius: 10px;">
                        <div style="font-size: 20px; color: #455a64; font-weight: bold;">~ THE END ~</div>
                    </div>`;
            }
        }

        // Î™®Î∞îÏùº Í∞êÏßÄ Î∞è Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
        window.addEventListener('resize', () => {
            isMobile = window.innerWidth <= 768;
        });

        // Ìå®ÎÑê Î¶¨ÏÇ¨Ïù¥Ï†Ä Í∏∞Îä•
        function initResizer() {
            const resizer = document.getElementById('resizer');
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            let isResizing = false;

            resizer.addEventListener('mousedown', function(e) {
                if (isMobile) return;
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing || isMobile) return;

                const container = document.querySelector('.main-content');
                const containerRect = container.getBoundingClientRect();
                const newWidth = e.clientX - containerRect.left;
                const minWidth = 250;
                const maxWidth = containerRect.width - 300;

                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    const percentage = (newWidth / containerRect.width) * 100;
                    treePanel.style.width = percentage + '%';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // ÌÉ≠ Ï†ÑÌôò (Î™®Î∞îÏùº)
        function switchTab(tab) {
            if (!isMobile) return;
            
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            const tabBtns = document.querySelectorAll('.tab-btn');
            
            tabBtns.forEach(btn => btn.classList.remove('active'));
            
            if (tab === 'tree') {
                treePanel.classList.add('active');
                editorPanel.classList.remove('active');
                tabBtns[0].classList.add('active');
            } else {
                treePanel.classList.remove('active');
                editorPanel.classList.add('active');
                tabBtns[1].classList.add('active');
            }
        }

        // Ï¥àÍ∏∞Ìôî
        function init() {
            for (let i = 1; i <= 1000; i++) {
                gameData[i] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }
            gameData[1].content = 'Í≤åÏûÑ ÏãúÏûë';
            updateUsedScenes();
            renderTree();
        }

        // ÏÇ¨Ïö©Îêú Ïî¨ ÏóÖÎç∞Ïù¥Ìä∏
        function updateUsedScenes() {
            usedSceneNumbers.clear();
            usedSceneNumbers.add(1);
            
            function traverse(sceneNum) {
                const scene = gameData[sceneNum];
                if (!scene) return;
                
                scene.choices.forEach(choice => {
                    if (choice.next && choice.next > 0 && choice.next <= 1000) {
                        if (!usedSceneNumbers.has(choice.next)) {
                            usedSceneNumbers.add(choice.next);
                            traverse(choice.next);
                        }
                    }
                });
            }
            
            traverse(1);
            
            for (let i = 1; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim()) {
                    usedSceneNumbers.add(i);
                }
            }
            
            updateStats();
        }

        // Îã§Ïùå ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïî¨ Ï∞æÍ∏∞
        function getNextAvailableScene() {
            for (let i = 2; i <= 1000; i++) {
                if (!usedSceneNumbers.has(i)) {
                    return i;
                }
            }
            return 0;
        }

        // ÏÉà Ïî¨ Ï∂îÍ∞Ä Îã§Ïù¥ÏñºÎ°úÍ∑∏
        function showAddSceneDialog() {
            // Í∏∞Ï°¥ Ìé∏Ïßë ÎÇ¥Ïö© Î®ºÏ†Ä Ï†ÄÏû•
            autoSaveCurrentEdit();

            const nextScene = getNextAvailableScene();
            if (nextScene === 0) {
                alert('Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïî¨Ïù¥ ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const sceneNum = prompt(`ÏÉà Ïî¨ Î≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ï∂îÏ≤ú: ${nextScene})`, nextScene);
            if (sceneNum === null) return;

            const num = parseInt(sceneNum);
            if (isNaN(num) || num < 1 || num > 1000) {
                alert('1~1000 ÏÇ¨Ïù¥Ïùò Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                return;
            }

            if (usedSceneNumbers.has(num)) {
                if (!confirm(`Ïî¨ ${num}ÏùÄ(Îäî) Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏûÖÎãàÎã§. ÏàòÏ†ïÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    return;
                }
            }

            // ÏÉà Ïî¨ ÏÉùÏÑ± ÎòêÎäî ÏàòÏ†ï
            if (!gameData[num]) {
                gameData[num] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }

            selectScene(num);
            updateUsedScenes();
            renderTree();
            updateStatus(`Ïî¨ ${num} Ï§ÄÎπÑÎê®`);
        }

        // Ï†ÑÏ≤¥ Ïî¨ Î™©Î°ù Î≥¥Í∏∞
        function showAllScenes() {
            // Í∏∞Ï°¥ Ìé∏Ïßë ÎÇ¥Ïö© Î®ºÏ†Ä Ï†ÄÏû•
            autoSaveCurrentEdit();

            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">Ï†ÑÏ≤¥ Ïî¨ Î™©Î°ù (${sceneList.length}Í∞ú)</h3>
                </div>

                <div class="editor-section">
                    <div style="display: grid; gap: 8px; max-height: 500px; overflow-y: auto;">`;

            sceneList.forEach(num => {
                const scene = gameData[num];
                const preview = scene.content ? scene.content.substring(0, 30) : '(ÎÇ¥Ïö© ÏóÜÏùå)';
                const endingBadge = scene.isEnding ? '<span style="color: #dc3545; font-weight: bold;"> [END]</span>' : '';
                const choicesInfo = !scene.isEnding ? ` (ÏÑ†ÌÉùÏßÄ: ${scene.choices.length})` : '';

                html += `
                    <div style="
                        padding: 12px;
                        background: ${num === 1 ? '#e3f2fd' : 'white'};
                        border: 2px solid ${scene.isEnding ? '#dc3545' : '#007bff'};
                        border-radius: 5px;
                        cursor: pointer;
                        transition: all 0.2s;
                    " onclick="selectScene(${num})"
                       onmouseover="this.style.background='#f0f0f0'"
                       onmouseout="this.style.background='${num === 1 ? '#e3f2fd' : 'white'}'">
                        <div style="font-weight: bold; margin-bottom: 5px;">
                            Ïî¨ ${num}${endingBadge}${choicesInfo}
                        </div>
                        <div style="color: #666; font-size: 13px;">
                            ${preview}${scene.content && scene.content.length > 30 ? '...' : ''}
                        </div>
                    </div>`;
            });

            html += `
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-info" onclick="renderTree(); document.getElementById('editor').innerHTML='<div class=\\'empty-state\\'>Ìä∏Î¶¨ÏóêÏÑú Ïî¨Ïù¥ÎÇò ÏÑ†ÌÉùÏßÄÎ•º ÌÉ≠ÌïòÏó¨ Ìé∏ÏßëÌïòÏÑ∏Ïöî</div>'">Ìä∏Î¶¨Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                </div>`;

            document.getElementById('editor').innerHTML = html;

            if (isMobile) {
                switchTab('editor');
            }
        }

        // ÏóîÎî© Ïî¨Îßå Î™®ÏïÑÎ≥¥Í∏∞
        function showAllEndings() {
            autoSaveCurrentEdit();

            const endingScenes = Array.from(usedSceneNumbers)
                .filter(num => gameData[num]?.isEnding)
                .sort((a, b) => a - b);

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">üîö ÏóîÎî© Î™©Î°ù (${endingScenes.length}Í∞ú)</h3>
                </div>

                <div class="editor-section">
                    <div style="display: grid; gap: 8px; max-height: 500px; overflow-y: auto;">`;

            if (endingScenes.length === 0) {
                html += `<div style="color: #666; text-align: center; padding: 20px;">ÏóîÎî© Ïî¨Ïù¥ ÏóÜÏäµÎãàÎã§.</div>`;
            } else {
                endingScenes.forEach(num => {
                    const scene = gameData[num];
                    const title = scene.endingTitle || '(Ï†úÎ™© ÏóÜÏùå)';
                    const preview = scene.content ? scene.content.substring(0, 40) : '(ÎÇ¥Ïö© ÏóÜÏùå)';

                    html += `
                        <div style="
                            padding: 10px;
                            background: #fff5f5;
                            border: 2px solid #dc3545;
                            border-radius: 5px;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onclick="selectScene(${num})"
                           onmouseover="this.style.background='#ffe0e0'"
                           onmouseout="this.style.background='#fff5f5'">
                            <div style="font-weight: bold; margin-bottom: 4px; font-size: 13px;">
                                Ïî¨ ${num} - <span style="color: #dc3545;">${title}</span>
                            </div>
                            <div style="color: #666; font-size: 12px;">
                                ${preview}${scene.content && scene.content.length > 40 ? '...' : ''}
                            </div>
                        </div>`;
                });
            }

            html += `
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-info" onclick="renderTree(); document.getElementById('editor').innerHTML='<div class=\\'empty-state\\'>Ìä∏Î¶¨ÏóêÏÑú Ïî¨Ïù¥ÎÇò ÏÑ†ÌÉùÏßÄÎ•º ÌÉ≠ÌïòÏó¨ Ìé∏ÏßëÌïòÏÑ∏Ïöî</div>'">Ìä∏Î¶¨Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>
                </div>`;

            document.getElementById('editor').innerHTML = html;

            if (isMobile) {
                switchTab('editor');
            }
        }

        // Ìä∏Î¶¨ Î†åÎçîÎßÅ - Ïπ¥Îìú ÌòïÌÉúÎ°ú Ïî¨Í≥º ÏÑ†ÌÉùÏßÄÎ•º ÌïúÎààÏóê Î≥¥Í∏∞
        function renderTree() {
            const treeDiv = document.getElementById('tree');

            // BFSÎ°ú Ïî¨ 1Î∂ÄÌÑ∞ Ïó∞Í≤∞Îêú ÏàúÏÑúÎåÄÎ°ú Ïî¨ ÏàòÏßë
            const orderedScenes = [];
            const connectedScenes = new Set();
            const queue = [1];

            while (queue.length > 0) {
                const sceneNum = queue.shift();
                if (connectedScenes.has(sceneNum)) continue;
                connectedScenes.add(sceneNum);

                const scene = gameData[sceneNum];
                if (scene && scene.content && scene.content.trim()) {
                    orderedScenes.push(sceneNum);

                    // ÏÑ†ÌÉùÏßÄÏùò Îã§Ïùå Ïî¨Îì§ÏùÑ ÌÅêÏóê Ï∂îÍ∞Ä
                    if (!scene.isEnding && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.next && choice.next > 0 && !connectedScenes.has(choice.next)) {
                                queue.push(choice.next);
                            }
                        });
                    }
                }
            }

            // Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ Ïî¨Îì§ (Í≥†ÏïÑ Ïî¨) Ï∞æÍ∏∞
            const orphanScenes = [];
            for (let i = 2; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim() && !connectedScenes.has(i)) {
                    orphanScenes.push(i);
                }
            }

            // HTML ÏÉùÏÑ±
            let html = '<div class="scene-cards">';

            orderedScenes.forEach(sceneNum => {
                html += buildSceneCard(sceneNum);
            });

            // Í≥†ÏïÑ Ïî¨Îì§ ÌëúÏãú
            if (orphanScenes.length > 0) {
                html += `<div class="orphan-section">
                    <div class="orphan-header">‚ö†Ô∏è Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ Ïî¨ (${orphanScenes.length}Í∞ú)</div>`;
                orphanScenes.forEach(num => {
                    html += buildSceneCard(num);
                });
                html += '</div>';
            }

            html += '</div>';
            treeDiv.innerHTML = html;
        }

        // Ïî¨ Ïπ¥Îìú HTML ÏÉùÏÑ±
        function buildSceneCard(sceneNum) {
            const scene = gameData[sceneNum];
            if (!scene) return '';

            const hasContent = scene.content && scene.content.trim();
            const isSelected = selectedNode === sceneNum && selectedType === 'scene';

            let cardClass = 'scene-card';
            if (isSelected) cardClass += ' selected';
            if (scene.isEnding) cardClass += ' ending';
            if (!hasContent) cardClass += ' empty';

            let html = `<div class="${cardClass}" id="scene-card-${sceneNum}">`;

            // Ïî¨ Ìó§Îçî
            html += `<div class="scene-card-header" onclick="selectScene(${sceneNum})">`;
            html += `<span class="scene-card-num">üìÑ Ïî¨ ${sceneNum}</span>`;
            if (scene.isEnding) {
                html += '<span class="scene-card-badge ending-badge">END</span>';
            }
            html += '</div>';

            // Ïî¨ ÎÇ¥Ïö© ÎØ∏Î¶¨Î≥¥Í∏∞
            if (hasContent) {
                const preview = scene.content.substring(0, 40);
                html += `<div class="scene-card-content" onclick="selectScene(${sceneNum})">${preview}${scene.content.length > 40 ? '...' : ''}</div>`;
            }

            // ÏÑ†ÌÉùÏßÄ Î™©Î°ù
            if (!scene.isEnding && scene.choices && scene.choices.length > 0) {
                html += '<div class="scene-card-choices">';
                scene.choices.forEach((choice, index) => {
                    const isChoiceSelected = selectedNode === `${sceneNum}-${index}` && selectedType === 'choice';
                    let choiceClass = 'scene-card-choice';
                    if (isChoiceSelected) choiceClass += ' selected';
                    if (!choice.text) choiceClass += ' empty';

                    // Í≤∞Í≥º ÌÉÄÏûÖÏóê Îî∞Î•∏ Ïä§ÌÉÄÏùº
                    const outcome = choice.outcome || 'continue';
                    if (outcome === 'success') choiceClass += ' success';
                    else if (outcome === 'failure') choiceClass += ' failure';

                    html += `<div class="${choiceClass}" onclick="selectChoice(${sceneNum}, ${index})">`;
                    html += `<span class="choice-index">${index + 1}</span>`;
                    html += `<span class="choice-text-preview">${choice.text ? choice.text.substring(0, 25) + (choice.text.length > 25 ? '...' : '') : '(Îπà ÏÑ†ÌÉùÏßÄ)'}</span>`;

                    // Îã§Ïùå Ïî¨ ÎòêÎäî Í≤∞Í≥º ÌëúÏãú
                    if (outcome === 'success') {
                        html += '<span class="choice-next success-label">üéâ</span>';
                    } else if (outcome === 'failure') {
                        html += '<span class="choice-next failure-label">üíî</span>';
                    } else if (choice.next && choice.next > 0) {
                        html += `<span class="choice-next" onclick="event.stopPropagation(); scrollToScene(${choice.next})" title="Ïî¨ ${choice.next}Î°ú Ïù¥Îèô">‚Üí ${choice.next}</span>`;
                    } else {
                        html += '<span class="choice-next empty-next">?</span>';
                    }

                    html += '</div>';
                });
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // ÌäπÏ†ï Ïî¨ Ïπ¥ÎìúÎ°ú Ïä§ÌÅ¨Î°§
        function scrollToScene(sceneNum) {
            const card = document.getElementById(`scene-card-${sceneNum}`);
            if (card) {
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Ïû†Ïãú ÌïòÏù¥ÎùºÏù¥Ìä∏
                card.classList.add('highlight');
                setTimeout(() => card.classList.remove('highlight'), 1500);
            }
        }

        // ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ ÎÇ¥Ïö© ÏûêÎèô Ï†ÄÏû•
        function autoSaveCurrentEdit() {
            // Ïî¨ Ìé∏Ïßë Ï§ëÏù¥Î©¥ Ï†ÄÏû•
            if (currentEditingScene !== null && selectedType === 'scene') {
                const contentEl = document.getElementById('sceneContent');
                const isEndingEl = document.getElementById('isEnding');
                const endingTitleEl = document.getElementById('endingTitle');

                if (contentEl) {
                    gameData[currentEditingScene].content = contentEl.value;
                }
                if (isEndingEl) {
                    gameData[currentEditingScene].isEnding = isEndingEl.checked;
                }
                if (endingTitleEl && gameData[currentEditingScene].isEnding) {
                    gameData[currentEditingScene].endingTitle = endingTitleEl.value;
                }

                // ÏÑ†ÌÉùÏßÄÎì§ÎèÑ Ï†ÄÏû•
                if (!gameData[currentEditingScene].isEnding) {
                    gameData[currentEditingScene].choices.forEach((choice, index) => {
                        const textInput = document.getElementById(`choice-text-${index}`);
                        const nextInput = document.getElementById(`choice-next-${index}`);
                        const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                        if (textInput) choice.text = textInput.value;
                        if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                        if (outcomeInput) choice.outcome = outcomeInput.value;
                    });
                }

                saveToLocal();
            }

            // ÏÑ†ÌÉùÏßÄ Ìé∏Ïßë Ï§ëÏù¥Î©¥ Ï†ÄÏû•
            if (currentEditingChoice !== null && selectedType === 'choice') {
                const textEl = document.getElementById('choiceText');
                const outcomeEl = document.getElementById('choiceOutcome');
                const nextEl = document.getElementById('choiceNext');

                if (textEl && gameData[currentEditingChoice.scene]?.choices[currentEditingChoice.index]) {
                    const choice = gameData[currentEditingChoice.scene].choices[currentEditingChoice.index];
                    choice.text = textEl.value;
                    if (outcomeEl) choice.outcome = outcomeEl.value;
                    if (nextEl && choice.outcome === 'continue') {
                        choice.next = parseInt(nextEl.value) || 0;
                    }
                    saveToLocal();
                }
            }
        }

        // ÏûêÎèô Ï†ÄÏû• ÌÉÄÏù¥Î®∏ ÏãúÏûë (5Ï¥àÎßàÎã§)
        function startAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            autoSaveTimer = setInterval(() => {
                autoSaveCurrentEdit();
                updateStatus('ÏûêÎèô Ï†ÄÏû•Îê®');
            }, 5000);
        }

        // Ïî¨ ÏÑ†ÌÉù
        function selectScene(sceneNum) {
            // Í∏∞Ï°¥ Ìé∏Ïßë ÎÇ¥Ïö© Î®ºÏ†Ä Ï†ÄÏû•
            autoSaveCurrentEdit();

            selectedNode = sceneNum;
            selectedType = 'scene';
            currentEditingScene = sceneNum;
            currentEditingChoice = null;

            renderTree();
            showSceneEditor(sceneNum);

            // Î™®Î∞îÏùºÏóêÏÑúÎäî ÏûêÎèôÏúºÎ°ú Ìé∏Ïßë ÌÉ≠ÏúºÎ°ú Ï†ÑÌôò
            if (isMobile) {
                switchTab('editor');
            }
        }

        // ÏÑ†ÌÉùÏßÄ ÏÑ†ÌÉù
        function selectChoice(sceneNum, choiceIndex) {
            // Í∏∞Ï°¥ Ìé∏Ïßë ÎÇ¥Ïö© Î®ºÏ†Ä Ï†ÄÏû•
            autoSaveCurrentEdit();

            selectedNode = `${sceneNum}-${choiceIndex}`;
            selectedType = 'choice';
            currentEditingScene = null;
            currentEditingChoice = { scene: sceneNum, index: choiceIndex };

            renderTree();
            showChoiceEditor(sceneNum, choiceIndex);

            if (isMobile) {
                switchTab('editor');
            }
        }

        // Ïî¨ ÏóêÎîîÌÑ∞
        function showSceneEditor(sceneNum) {
            const scene = gameData[sceneNum];
            const editor = document.getElementById('editor');
            
            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">Ïî¨ ${sceneNum}</h3>
                </div>
                
                <div class="editor-section">
                    <div class="editor-label">Ïî¨ ÎÇ¥Ïö©</div>
                    <textarea class="editor-textarea" id="sceneContent" 
                              placeholder="Ïù¥ Ïî¨Ïùò ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî...">${scene.content}</textarea>
                </div>

                <div class="editor-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="isEnding" ${scene.isEnding ? 'checked' : ''}
                               onchange="toggleEnding(${sceneNum})">
                        <span>ÏóîÎî© Ïî¨ÏúºÎ°ú ÏÑ§Ï†ï</span>
                    </label>
                </div>

                <div class="editor-section" id="endingTitleSection" ${scene.isEnding ? '' : 'style="display:none"'}>
                    <div class="editor-label">ÏóîÎî© Ï†úÎ™©</div>
                    <input type="text" class="editor-input" id="endingTitle"
                           placeholder="ÏóîÎî© Ï†úÎ™©ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: Ìï¥ÌîºÏóîÎî©, Î∞∞ÎìúÏóîÎî©...)"
                           value="${scene.endingTitle || ''}">
                </div>

                <div class="editor-section" id="choicesSection" ${scene.isEnding ? 'style="display:none"' : ''}>
                    <div class="editor-label">ÏÑ†ÌÉùÏßÄ (${scene.choices.length}/3)</div>`;
            
            scene.choices.forEach((choice, index) => {
                const outcomeValue = choice.outcome || 'continue';
                html += `
                    <div class="choice-container">
                        <div class="choice-header">
                            <span class="choice-number">ÏÑ†ÌÉùÏßÄ ${index + 1}</span>
                            <button class="delete-btn" onclick="deleteChoice(${sceneNum}, ${index})">ÏÇ≠Ï†ú</button>
                        </div>
                        <input type="text" class="editor-input" id="choice-text-${index}"
                               placeholder="ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." value="${choice.text}">
                        <div class="next-scene-control">
                            <select class="editor-input" id="choice-outcome-${index}" style="width: auto; min-width: 120px;">
                                <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>Îã§Ïùå Ïî¨ÏúºÎ°ú</option>
                                <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ÏÑ±Í≥µ ÏóîÎî©</option>
                                <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>Ïã§Ìå® ÏóîÎî©</option>
                            </select>
                            <input type="number" class="next-scene-input" id="choice-next-${index}"
                                   min="1" max="1000" value="${choice.next || ''}"
                                   placeholder="Îã§Ïùå Ïî¨" ${outcomeValue !== 'continue' ? 'disabled' : ''}>
                            <button class="auto-btn" onclick="autoAssignNext(${sceneNum}, ${index})" ${outcomeValue !== 'continue' ? 'disabled' : ''}>ÏûêÎèô</button>
                            ${choice.next && choice.next > 0 && outcomeValue === 'continue' ? `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${choice.next})">‚Üí Ïî¨ ${choice.next}</button>` : ''}
                        </div>
                    </div>`;
            });
            
            if (scene.choices.length < 3 && !scene.isEnding) {
                html += `<button class="add-choice-btn" onclick="addChoice(${sceneNum})">+ ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞Ä</button>`;
            }
            
            html += `</div>`;

            // Î∞îÎ°úÍ∞ÄÍ∏∞ ÏÑπÏÖò Ï∂îÍ∞Ä
            const parentScenes = findParentScenes(sceneNum);
            const childScenes = scene.choices.filter(c => c.next && c.next > 0 && (c.outcome || 'continue') === 'continue').map(c => c.next);

            if (parentScenes.length > 0 || childScenes.length > 0) {
                html += `<div class="editor-section">
                    <div class="editor-label">üîó Î∞îÎ°úÍ∞ÄÍ∏∞</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">`;

                parentScenes.forEach(p => {
                    html += `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${p.scene})">‚Üê Ïî¨ ${p.scene} (ÏÑ†ÌÉùÏßÄ ${p.choiceIdx + 1})</button>`;
                });

                childScenes.forEach(nextScene => {
                    html += `<button class="auto-btn" style="background: #17a2b8;" onclick="selectScene(${nextScene})">‚Üí Ïî¨ ${nextScene}</button>`;
                });

                html += `</div></div>`;
            }

            html += `
                <div class="editor-controls">
                    <button class="btn-success" onclick="saveScene(${sceneNum})">Ï†ÄÏû•</button>
                    ${sceneNum !== 1 ? `<button class="btn-danger" onclick="deleteScene(${sceneNum})">Ïî¨ ÏÇ≠Ï†ú</button>` : ''}
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">Ìä∏Î¶¨Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>` : ''}
                </div>`;

            editor.innerHTML = html;
        }

        // ÌäπÏ†ï Ïî¨ÏùÑ Ïó∞Í≤∞ÌïòÎäî Î∂ÄÎ™® Ïî¨Îì§ Ï∞æÍ∏∞
        function findParentScenes(targetScene) {
            const parents = [];
            Object.keys(gameData).forEach(key => {
                const sceneNum = parseInt(key);
                const scene = gameData[sceneNum];
                if (scene && scene.choices) {
                    scene.choices.forEach((choice, idx) => {
                        if (choice.next === targetScene && (choice.outcome || 'continue') === 'continue') {
                            parents.push({ scene: sceneNum, choiceIdx: idx });
                        }
                    });
                }
            });
            return parents;
        }

        // ÏÑ†ÌÉùÏßÄ ÏóêÎîîÌÑ∞
        function showChoiceEditor(sceneNum, choiceIndex) {
            const choice = gameData[sceneNum].choices[choiceIndex];
            const editor = document.getElementById('editor');
            const outcomeValue = choice.outcome || 'continue';

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">Ïî¨ ${sceneNum} - ÏÑ†ÌÉùÏßÄ ${choiceIndex + 1}</h3>
                </div>

                <div class="editor-section">
                    <div class="editor-label">ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏</div>
                    <input type="text" class="editor-input" id="choiceText"
                           placeholder="ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." value="${choice.text || ''}">
                </div>

                <div class="editor-section">
                    <div class="editor-label">Í≤∞Í≥º Ïú†Ìòï</div>
                    <select class="editor-input" id="choiceOutcome" onchange="toggleNextSceneInput()">
                        <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>Îã§Ïùå Ïî¨ÏúºÎ°ú ÏßÑÌñâ</option>
                        <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ÏÑ±Í≥µ ÏóîÎî©</option>
                        <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>Ïã§Ìå® ÏóîÎî©</option>
                    </select>
                </div>

                <div class="editor-section" id="nextSceneSection" ${outcomeValue !== 'continue' ? 'style="display:none"' : ''}>
                    <div class="editor-label">Îã§Ïùå Ïî¨ Î≤àÌò∏</div>
                    <div class="next-scene-control">
                        <input type="number" class="editor-input" id="choiceNext"
                               min="1" max="1000" value="${choice.next || ''}"
                               placeholder="1-1000">
                        <button class="auto-btn" onclick="autoAssignNextForChoice(${sceneNum}, ${choiceIndex})">ÏûêÎèô Ï±ÑÎ≤à</button>
                        ${choice.next && choice.next > 0 ? `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${choice.next})">‚Üí Ïî¨ ${choice.next} Ìé∏Ïßë</button>` : ''}
                    </div>
                </div>

                <div class="editor-section">
                    <div class="editor-label">Î∞îÎ°úÍ∞ÄÍ∏∞</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="auto-btn" style="background: #007bff;" onclick="selectScene(${sceneNum})">‚Üê Ïî¨ ${sceneNum}ÏúºÎ°ú</button>
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-success" onclick="saveChoice(${sceneNum}, ${choiceIndex})">Ï†ÄÏû•</button>
                    <button class="btn-danger" onclick="deleteChoice(${sceneNum}, ${choiceIndex})">ÏÇ≠Ï†ú</button>
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">Ìä∏Î¶¨Î°ú ÎèåÏïÑÍ∞ÄÍ∏∞</button>` : ''}
                </div>`;

            editor.innerHTML = html;
        }

        // Îã§Ïùå Ïî¨ ÏûÖÎ†•Ï∞Ω ÌÜ†Í∏Ä
        function toggleNextSceneInput() {
            const outcome = document.getElementById('choiceOutcome').value;
            const section = document.getElementById('nextSceneSection');
            if (section) {
                section.style.display = outcome === 'continue' ? 'block' : 'none';
            }
        }

        // ÏóîÎî© ÌÜ†Í∏Ä
        function toggleEnding(sceneNum) {
            const isEnding = document.getElementById('isEnding').checked;
            gameData[sceneNum].isEnding = isEnding;

            const choicesSection = document.getElementById('choicesSection');
            const endingTitleSection = document.getElementById('endingTitleSection');
            if (isEnding) {
                choicesSection.style.display = 'none';
                endingTitleSection.style.display = 'block';
                gameData[sceneNum].choices = [];
            } else {
                choicesSection.style.display = 'block';
                endingTitleSection.style.display = 'none';
                gameData[sceneNum].endingTitle = '';
            }

            updateUsedScenes();
            renderTree();
        }

        // ÏûêÎèô Ï±ÑÎ≤à (ÌòÑÏû¨ ÌôîÎ©¥Ïùò ÏûÖÎ†•Í∞íÎèÑ Í≥†Î†§)
        function autoAssignNext(sceneNum, choiceIndex) {
            // ÌòÑÏû¨ ÌôîÎ©¥Ïóê Ïù¥ÎØ∏ ÏûÖÎ†•Îêú Îã§Ïùå Ïî¨ Î≤àÌò∏Îì§ ÏàòÏßë
            const usedInCurrentForm = new Set();
            const scene = gameData[sceneNum];
            if (scene && scene.choices) {
                scene.choices.forEach((choice, idx) => {
                    // ÌòÑÏû¨ Ìé∏Ïßë Ï§ëÏù∏ ÏÑ†ÌÉùÏßÄÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞, ÏûÖÎ†• ÌïÑÎìúÏóêÏÑú Í∞í ÌôïÏù∏
                    const inputEl = document.getElementById(`choice-next-${idx}`);
                    if (inputEl && inputEl.value) {
                        usedInCurrentForm.add(parseInt(inputEl.value));
                    }
                });
            }

            const nextScene = getNextAvailableSceneExcluding(usedInCurrentForm);
            if (nextScene > 0) {
                document.getElementById(`choice-next-${choiceIndex}`).value = nextScene;
                updateStatus(`Ïî¨ ${nextScene} ÏûêÎèô Ìï†Îãπ`);
            } else {
                alert('ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïî¨Ïù¥ ÏóÜÏäµÎãàÎã§');
            }
        }

        function autoAssignNextForChoice(sceneNum, choiceIndex) {
            // Í∞ôÏùÄ Ïî¨Ïùò Îã§Î•∏ ÏÑ†ÌÉùÏßÄÏóêÏÑú ÏÇ¨Ïö© Ï§ëÏù∏ Î≤àÌò∏ ÏàòÏßë
            const usedInCurrentScene = new Set();
            const scene = gameData[sceneNum];
            if (scene && scene.choices) {
                scene.choices.forEach((choice, idx) => {
                    if (idx !== choiceIndex && choice.next > 0) {
                        usedInCurrentScene.add(choice.next);
                    }
                });
            }

            const nextScene = getNextAvailableSceneExcluding(usedInCurrentScene);
            if (nextScene > 0) {
                document.getElementById('choiceNext').value = nextScene;
                updateStatus(`Ïî¨ ${nextScene} ÏûêÎèô Ìï†Îãπ`);
            } else {
                alert('ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïî¨Ïù¥ ÏóÜÏäµÎãàÎã§');
            }
        }

        // ÌäπÏ†ï Î≤àÌò∏Îì§ÏùÑ Ï†úÏô∏ÌïòÍ≥† Îã§Ïùå ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïî¨ Ï∞æÍ∏∞
        function getNextAvailableSceneExcluding(excludeSet) {
            for (let i = 2; i <= 1000; i++) {
                if (!usedSceneNumbers.has(i) && !excludeSet.has(i)) {
                    return i;
                }
            }
            return 0;
        }

        // Ïî¨ Ï†ÄÏû•
        function saveScene(sceneNum) {
            const content = document.getElementById('sceneContent').value;
            const isEnding = document.getElementById('isEnding').checked;
            const endingTitleEl = document.getElementById('endingTitle');

            gameData[sceneNum].content = content;
            gameData[sceneNum].isEnding = isEnding;

            if (isEnding && endingTitleEl) {
                gameData[sceneNum].endingTitle = endingTitleEl.value;
            }

            if (!isEnding) {
                gameData[sceneNum].choices.forEach((choice, index) => {
                    const textInput = document.getElementById(`choice-text-${index}`);
                    const nextInput = document.getElementById(`choice-next-${index}`);
                    const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                    if (textInput) choice.text = textInput.value;
                    if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                    if (outcomeInput) choice.outcome = outcomeInput.value;
                });
            }
            
            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('Ïî¨ ' + sceneNum + ' Ï†ÄÏû•Îê®');
            
            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ÏÑ†ÌÉùÏßÄ Ï†ÄÏû•
        function saveChoice(sceneNum, choiceIndex) {
            const text = document.getElementById('choiceText').value;
            const outcomeEl = document.getElementById('choiceOutcome');
            const nextEl = document.getElementById('choiceNext');

            const outcome = outcomeEl ? outcomeEl.value : 'continue';
            const next = outcome === 'continue' ? (parseInt(nextEl?.value) || 0) : 0;

            gameData[sceneNum].choices[choiceIndex] = { text, next, outcome };

            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('ÏÑ†ÌÉùÏßÄ Ï†ÄÏû•Îê®');

            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞Ä
        function addChoice(sceneNum) {
            if (gameData[sceneNum].choices.length < 3) {
                gameData[sceneNum].choices.push({ text: '', next: 0, outcome: 'continue' });
                showSceneEditor(sceneNum);
                updateStatus('ÏÑ†ÌÉùÏßÄ Ï∂îÍ∞ÄÎê®');
            }
        }

        // ÏÑ†ÌÉùÏßÄ ÏÇ≠Ï†ú
        function deleteChoice(sceneNum, choiceIndex) {
            if (confirm('ÏÑ†ÌÉùÏßÄÎ•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                gameData[sceneNum].choices.splice(choiceIndex, 1);
                updateUsedScenes();
                renderTree();
                if (selectedType === 'choice') {
                    showSceneEditor(sceneNum);
                }
                saveToLocal();
                updateStatus('ÏÑ†ÌÉùÏßÄ ÏÇ≠Ï†úÎê®');
            }
        }

        // Ïî¨ ÏÇ≠Ï†ú
        function deleteScene(sceneNum) {
            if (sceneNum === 1) {
                alert('Ïî¨ 1ÏùÄ ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§');
                return;
            }
            
            if (confirm(`Ïî¨ ${sceneNum}ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                gameData[sceneNum] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
                updateUsedScenes();
                renderTree();
                document.getElementById('editor').innerHTML = '<div class="empty-state">Ìä∏Î¶¨ÏóêÏÑú Ïî¨Ïù¥ÎÇò ÏÑ†ÌÉùÏßÄÎ•º ÌÉ≠ÌïòÏó¨ Ìé∏ÏßëÌïòÏÑ∏Ïöî</div>';
                saveToLocal();
                updateStatus('Ïî¨ ' + sceneNum + ' ÏÇ≠Ï†úÎê®');
                
                if (isMobile) {
                    switchTab('tree');
                }
            }
        }

        // Î°úÏª¨ Ï†ÄÏû• (Î≤ÑÏ†Ñ ÏãúÏä§ÌÖúÍ≥º ÌÜµÌï©)
        function saveToLocal() {
            saveAllVersionsToLocal();
            renderVersionTabs(); // Ïî¨ Í∞úÏàò ÏóÖÎç∞Ïù¥Ìä∏
        }

        // Î°úÏª¨ÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞ (ÌòÑÏû¨ Î≤ÑÏ†ÑÎßå Îã§Ïãú Î°úÎìú)
        function loadFromLocal() {
            if (loadAllVersionsFromLocal()) {
                updateUsedScenes();
                renderTree();
                renderVersionTabs();
                updateStatus('Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò¥');
            } else {
                updateStatus('Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
            }
        }

        // Ï¥àÍ∏∞Ìôî (ÌòÑÏû¨ Î≤ÑÏ†ÑÎßå)
        function clearAll() {
            const currentName = storyVersions[currentVersionIndex].name;
            if (confirm(`"${currentName}" Î≤ÑÏ†ÑÏùò Î™®Îì† Ïî¨ÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                gameData = { 1: { content: '', isEnding: false, choices: [] } };
                storyVersions[currentVersionIndex].data = gameData;
                usedSceneNumbers.clear();
                usedSceneNumbers.add(1);

                document.getElementById('editor').innerHTML = '<div class="empty-state">Ìä∏Î¶¨ÏóêÏÑú Ïî¨Ïù¥ÎÇò ÏÑ†ÌÉùÏßÄÎ•º ÌÉ≠ÌïòÏó¨ Ìé∏ÏßëÌïòÏÑ∏Ïöî</div>';
                selectedNode = null;
                selectedType = null;
                currentEditingScene = null;
                currentEditingChoice = null;

                renderTree();
                renderVersionTabs();
                saveToLocal();
                updateStatus(`"${currentName}" Ï¥àÍ∏∞Ìôî ÏôÑÎ£å`);
            }
        }

        // game.html Ìò∏Ìôò JSON ÎÇ¥Î≥¥ÎÇ¥Í∏∞
        function exportJSON() {
            const story = convertToStoryFormat();
            const errors = validateStory(story);

            if (errors.length > 0) {
                alert('Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Í≤ΩÍ≥†:\n' + errors.join('\n') + '\n\nÎÇ¥Î≥¥ÎÇ¥Í∏∞Î•º Í≥ÑÏÜçÌï©ÎãàÎã§.');
            }

            const json = JSON.stringify(story, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${gameTitle.replace(/\s+/g, '-')}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('JSON ÌååÏùº ÏÉùÏÑ±Îê® (game.html Ìò∏Ìôò)');
        }

        // ÏóêÎîîÌÑ∞ Îç∞Ïù¥ÌÑ∞Î•º game.html STORY ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
        function convertToStoryFormat() {
            const scenes = [];
            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            sceneList.forEach(num => {
                const scene = gameData[num];
                if (!scene || (!scene.content && scene.choices.length === 0)) return;

                const sceneId = `S${String(num).padStart(3, '0')}`;
                const sceneObj = {
                    id: sceneId,
                    name: `Ïî¨ ${num}`,
                    content: scene.content || '',
                    isEnding: scene.isEnding || false,
                    choices: []
                };

                if (scene.isEnding) {
                    sceneObj.endingInfo = {
                        code: `END-${num}`,
                        title: scene.endingTitle || `ÏóîÎî© ${num}`,
                        summary: scene.content || ''
                    };
                    // ÏóîÎî© Ïî¨ÎèÑ Îπà ÏÑ†ÌÉùÏßÄ 2Í∞ú ÌïÑÏöî (game.html ÌòïÏãù)
                    sceneObj.choices = [
                        { id: `C${String(num).padStart(3, '0')}A`, label: '', outcome: 'continue', nextSceneId: '' },
                        { id: `C${String(num).padStart(3, '0')}B`, label: '', outcome: 'continue', nextSceneId: '' }
                    ];
                } else {
                    // ÏÑ†ÌÉùÏßÄ Î≥ÄÌôò (ÏµúÎåÄ 2Í∞úÎßå)
                    for (let i = 0; i < 2; i++) {
                        const choice = scene.choices[i];
                        const choiceId = `C${String(num).padStart(3, '0')}${i === 0 ? 'A' : 'B'}`;

                        if (choice && choice.text) {
                            const outcome = choice.outcome || 'continue';
                            let nextSceneId = '';

                            if (outcome === 'continue' && choice.next > 0) {
                                nextSceneId = `S${String(choice.next).padStart(3, '0')}`;
                            }

                            sceneObj.choices.push({
                                id: choiceId,
                                label: choice.text,
                                outcome: outcome,
                                nextSceneId: nextSceneId
                            });
                        } else {
                            // Îπà ÏÑ†ÌÉùÏßÄ
                            sceneObj.choices.push({
                                id: choiceId,
                                label: '',
                                outcome: 'continue',
                                nextSceneId: ''
                            });
                        }
                    }
                }

                scenes.push(sceneObj);
            });

            return {
                title: gameTitle,
                startSceneId: 'S001',
                scenes: scenes
            };
        }

        // STORY ÌòïÏãù Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
        function validateStory(story) {
            const errors = [];

            if (!story.startSceneId) {
                errors.push('ÏãúÏûë Ïî¨ IDÍ∞Ä ÏóÜÏäµÎãàÎã§.');
            } else if (!story.scenes.find(s => s.id === story.startSceneId)) {
                errors.push(`ÏãúÏûë Ïî¨ ${story.startSceneId}ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
            }

            story.scenes.forEach(scene => {
                if (!scene.choices || scene.choices.length !== 2) {
                    errors.push(`Ïî¨ ${scene.id}: ÏÑ†ÌÉùÏßÄÍ∞Ä Ï†ïÌôïÌûà 2Í∞úÏó¨Ïïº Ìï©ÎãàÎã§.`);
                }

                if (scene.choices) {
                    scene.choices.forEach((choice, idx) => {
                        if (choice.outcome === 'continue' && choice.label && !choice.nextSceneId) {
                            errors.push(`Ïî¨ ${scene.id}, ÏÑ†ÌÉùÏßÄ ${idx + 1}: outcomeÏù¥ 'continue'Ïù∏Îç∞ nextSceneIdÍ∞Ä ÏóÜÏäµÎãàÎã§.`);
                        }

                        if (choice.outcome === 'continue' && choice.nextSceneId) {
                            if (!story.scenes.find(s => s.id === choice.nextSceneId)) {
                                errors.push(`Ïî¨ ${scene.id}, ÏÑ†ÌÉùÏßÄ ${idx + 1}: nextSceneId ${choice.nextSceneId}ÏùÑ(Î•º) Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
                            }
                        }
                    });
                }
            });

            return errors;
        }

        // JSON Í∞ÄÏ†∏Ïò§Í∏∞
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);
                        convertFromStoryFormat(story);
                        updateStatus('JSON ÌååÏùº Í∞ÄÏ†∏Ïò§Í∏∞ ÏôÑÎ£å');
                    } catch (err) {
                        alert('JSON ÌååÏã± Ïã§Ìå®: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // game.html STORY ÌòïÏãùÏùÑ ÏóêÎîîÌÑ∞ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
        function convertFromStoryFormat(story) {
            if (story.title) {
                gameTitle = story.title;
            }

            // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
            init();

            if (story.scenes && Array.isArray(story.scenes)) {
                story.scenes.forEach(scene => {
                    // Ïî¨ IDÏóêÏÑú Î≤àÌò∏ Ï∂îÏ∂ú (S001 -> 1)
                    const match = scene.id.match(/S(\d+)/);
                    if (!match) return;

                    const num = parseInt(match[1]);
                    if (num < 1 || num > 1000) return;

                    gameData[num] = {
                        content: scene.content || '',
                        isEnding: scene.isEnding || false,
                        choices: []
                    };

                    if (!scene.isEnding && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.label) {
                                let nextNum = 0;
                                if (choice.nextSceneId) {
                                    const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                    if (nextMatch) {
                                        nextNum = parseInt(nextMatch[1]);
                                    }
                                }

                                gameData[num].choices.push({
                                    text: choice.label,
                                    next: nextNum,
                                    outcome: choice.outcome || 'continue'
                                });
                            }
                        });
                    }
                });
            }

            updateUsedScenes();
            renderTree();
            saveToLocal();
        }

        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
            updateStats();
        }

        // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        function updateStats() {
            const used = usedSceneNumbers.size;
            const available = 1000 - used;

            document.getElementById('usedScenes').textContent = used;
            document.getElementById('availableScenes').textContent = available;

            // ÏòàÏÉÅ ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            const estimatedTime = calculateEstimatedPlayTime();
            document.getElementById('estimatedTime').textContent = estimatedTime;
        }

        // ÏòàÏÉÅ ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
        // ÌïúÍµ≠Ïñ¥ ÌèâÍ∑† ÏùΩÍ∏∞ ÏÜçÎèÑ: ÏïΩ 200Ïûê/Î∂Ñ (ÏÑ±Ïù∏ Í∏∞Ï§Ä)
        // ÏÑ†ÌÉùÏßÄ Í≥†ÎØº ÏãúÍ∞Ñ: ÏïΩ 3-5Ï¥à Ï∂îÍ∞Ä
        function calculateEstimatedPlayTime() {
            const CHARS_PER_MINUTE = 200; // ÌïúÍµ≠Ïñ¥ ÏùΩÍ∏∞ ÏÜçÎèÑ
            const CHOICE_THINKING_SECONDS = 4; // ÏÑ†ÌÉùÏßÄÎãπ Í≥†ÎØº ÏãúÍ∞Ñ

            // Î™®Îì† Í≤ΩÎ°ú ÌÉêÏÉâÌïòÏó¨ ÌèâÍ∑† Í≤ΩÎ°ú Í∏∏Ïù¥ Í≥ÑÏÇ∞
            const paths = findAllPaths();

            if (paths.length === 0) {
                return '0Î∂Ñ';
            }

            // Í∞Å Í≤ΩÎ°úÏùò ÌîåÎ†àÏù¥ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            const pathTimes = paths.map(path => {
                let totalChars = 0;
                let totalChoices = 0;

                path.forEach(sceneNum => {
                    const scene = gameData[sceneNum];
                    if (scene) {
                        // Ïî¨ ÎÇ¥Ïö© Í∏ÄÏûê Ïàò
                        totalChars += (scene.content || '').length;

                        // ÏÑ†ÌÉùÏßÄ Í∏ÄÏûê Ïàò Î∞è Í∞úÏàò
                        if (scene.choices && !scene.isEnding) {
                            scene.choices.forEach(choice => {
                                if (choice.text) {
                                    totalChars += choice.text.length;
                                    totalChoices++;
                                }
                            });
                        }
                    }
                });

                // ÏùΩÍ∏∞ ÏãúÍ∞Ñ(Î∂Ñ) + ÏÑ†ÌÉù Í≥†ÎØº ÏãúÍ∞Ñ(Î∂Ñ)
                const readingMinutes = totalChars / CHARS_PER_MINUTE;
                const thinkingMinutes = (totalChoices * CHOICE_THINKING_SECONDS) / 60;

                return readingMinutes + thinkingMinutes;
            });

            // ÏµúÏÜå, ÏµúÎåÄ, ÌèâÍ∑† Í≥ÑÏÇ∞
            const minTime = Math.min(...pathTimes);
            const maxTime = Math.max(...pathTimes);
            const avgTime = pathTimes.reduce((a, b) => a + b, 0) / pathTimes.length;

            // Ìè¨Îß∑ÌåÖ
            if (avgTime < 1) {
                const seconds = Math.round(avgTime * 60);
                return `${seconds}Ï¥à`;
            } else if (minTime === maxTime) {
                return `ÏïΩ ${Math.round(avgTime)}Î∂Ñ`;
            } else {
                return `${Math.round(minTime)}-${Math.round(maxTime)}Î∂Ñ`;
            }
        }

        // Ïî¨ 1Î∂ÄÌÑ∞ Î™®Îì† Í∞ÄÎä•Ìïú Í≤ΩÎ°ú ÌÉêÏÉâ (DFS)
        function findAllPaths() {
            const paths = [];
            const maxDepth = 100; // Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ

            function dfs(sceneNum, currentPath, visited) {
                if (currentPath.length > maxDepth) return;
                if (visited.has(sceneNum)) return; // ÏàúÌôò Î∞©ÏßÄ

                const scene = gameData[sceneNum];
                if (!scene || !scene.content) return;

                const newPath = [...currentPath, sceneNum];
                const newVisited = new Set(visited);
                newVisited.add(sceneNum);

                // ÏóîÎî©Ïù¥Í±∞ÎÇò ÏÑ†ÌÉùÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Í≤ΩÎ°ú ÏôÑÏÑ±
                if (scene.isEnding || !scene.choices || scene.choices.length === 0) {
                    paths.push(newPath);
                    return;
                }

                // Ïú†Ìö®Ìïú ÏÑ†ÌÉùÏßÄÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
                let hasValidChoice = false;
                scene.choices.forEach(choice => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';

                        if (outcome === 'success' || outcome === 'failure') {
                            // ÏóîÎî© ÏÑ†ÌÉùÏßÄ - Í≤ΩÎ°ú ÏôÑÏÑ±
                            paths.push(newPath);
                            hasValidChoice = true;
                        } else if (choice.next > 0) {
                            // Îã§Ïùå Ïî¨ÏúºÎ°ú Ïù¥Îèô
                            dfs(choice.next, newPath, newVisited);
                            hasValidChoice = true;
                        }
                    }
                });

                // Ïú†Ìö®Ìïú ÏÑ†ÌÉùÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Ïó¨Í∏∞ÏÑú Í≤ΩÎ°ú Ï¢ÖÎ£å
                if (!hasValidChoice) {
                    paths.push(newPath);
                }
            }

            // Ïî¨ 1Î∂ÄÌÑ∞ ÏãúÏûë
            if (gameData[1] && gameData[1].content) {
                dfs(1, [], new Set());
            }

            return paths;
        }

        // ==================== STORY PREVIEW SYSTEM (ÌîåÎû´ Î∑∞) ====================

        // ÌéºÏ≥êÏßÑ Î∂ÑÍ∏∞ Ï∂îÏ†Å - Í≤ΩÎ°ú Í∏∞Î∞ò (Ïòà: "1-0", "1-0-1-1")
        let expandedPaths = new Set();

        // ÌäπÏ†ï ÏÑ†ÌÉùÏßÄÏóêÏÑú ÎèÑÎã¨ Í∞ÄÎä•Ìïú ÏóîÎî©/Î∂ÑÍ∏∞ Ïàò Í≥ÑÏÇ∞
        function countBranches(sceneNum, visited = new Set()) {
            if (visited.has(sceneNum)) return { endings: 0, incomplete: 0 };

            const scene = gameData[sceneNum];
            if (!scene || !scene.content) return { endings: 0, incomplete: 1 };

            if (scene.isEnding) return { endings: 1, incomplete: 0 };

            const validChoices = (scene.choices || []).filter(c => c.text && c.next);
            if (validChoices.length === 0) return { endings: 0, incomplete: 1 };

            const newVisited = new Set(visited);
            newVisited.add(sceneNum);

            let total = { endings: 0, incomplete: 0 };
            validChoices.forEach(choice => {
                const sub = countBranches(choice.next, newVisited);
                total.endings += sub.endings;
                total.incomplete += sub.incomplete;
            });
            return total;
        }

        // Í≤ΩÎ°úÎ•º Î∏åÎ†àÎìúÌÅ¨Îüº Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
        function pathToBreadcrumb(pathSteps) {
            if (pathSteps.length === 0) return '[Ïî¨1]';

            let breadcrumb = '';
            pathSteps.forEach((step, idx) => {
                if (idx > 0) breadcrumb += ' ‚Üí ';
                breadcrumb += `Ïî¨${step.sceneNum}`;
                if (step.choiceIdx !== undefined) {
                    breadcrumb += ` ‚Üí ‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©`[step.choiceIdx + 1] || `(${step.choiceIdx + 1})`;
                }
            });
            return breadcrumb;
        }

        // Ïî¨ Î∏îÎ°ù Î†åÎçîÎßÅ (Îì§Ïó¨Ïì∞Í∏∞ ÏóÜÏùå)
        function renderSceneBlock(sceneNum, pathKey, pathSteps) {
            const scene = gameData[sceneNum];
            if (!scene || !scene.content) {
                return `<div class="flat-scene-block"><div class="flat-empty">‚ö†Ô∏è Ïî¨${sceneNum} ÏóÜÏùå</div></div>`;
            }

            let html = `<div class="flat-scene-block">`;

            // Í≤ΩÎ°ú Ìó§Îçî (Î∏åÎ†àÎìúÌÅ¨Îüº)
            const breadcrumb = pathToBreadcrumb(pathSteps);
            html += `<div class="flat-path-header">‚îÅ‚îÅ‚îÅ ${breadcrumb} ‚Üí [Ïî¨${sceneNum}] ‚îÅ‚îÅ‚îÅ</div>`;

            // Ïî¨ ÎÇ¥Ïö©
            html += `<div class="flat-scene-content">
                ${escapeHtml(scene.content || '')}
                <button class="preview-edit-btn" onclick="openPreviewEdit('scene', ${sceneNum})">‚úèÔ∏è</button>
            </div>`;

            // ÏóîÎî©Ïù∏ Í≤ΩÏö∞
            if (scene.isEnding) {
                const endingInfo = scene.endingInfo || {};
                html += `<div class="flat-ending">üîö ${endingInfo.code || 'END-' + sceneNum}</div>`;
                html += `</div>`;
                return html;
            }

            // ÏÑ†ÌÉùÏßÄÎì§
            const choices = scene.choices || [];
            const validChoices = choices.filter(c => c.text);

            if (validChoices.length > 0) {
                html += `<div class="flat-choices">`;
                choices.forEach((choice, cIdx) => {
                    if (!choice.text) return;

                    const choicePathKey = pathKey ? `${pathKey}-${cIdx}` : `${sceneNum}-${cIdx}`;
                    const isExpanded = expandedPaths.has(choicePathKey);
                    const nextScene = gameData[choice.next];
                    const isEnding = nextScene?.isEnding;
                    const hasNext = choice.next && nextScene?.content;

                    // Î∂ÑÍ∏∞ Ïàò Í≥ÑÏÇ∞
                    let branchInfo = '';
                    if (hasNext && !isEnding) {
                        const counts = countBranches(choice.next, new Set([sceneNum]));
                        const total = counts.endings + counts.incomplete;
                        if (total > 1) {
                            branchInfo = `<span class="branch-count">(${total}Í∞ú Î∂ÑÍ∏∞)</span>`;
                        }
                    }

                    // ÏÑ†ÌÉùÏßÄ ÎùºÏù∏
                    const lineChar = cIdx === validChoices.length - 1 ? '‚îî‚îÄ' : '‚îú‚îÄ';
                    const choiceNum = '‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©'[cIdx] || `(${cIdx + 1})`;

                    html += `<div class="flat-choice-row">`;
                    html += `<span class="flat-line">${lineChar}</span>`;
                    html += `<span class="flat-choice-num">${choiceNum}</span>`;

                    if (hasNext && !isEnding) {
                        html += `<span class="flat-toggle" onclick="togglePath('${choicePathKey}')">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>`;
                    }

                    html += `<span class="flat-choice-text">"${escapeHtml(choice.text)}"</span>`;
                    html += `<button class="preview-edit-btn" onclick="openPreviewEdit('choice', ${sceneNum}, ${cIdx})">‚úèÔ∏è</button>`;

                    if (isEnding) {
                        html += `<span class="flat-arrow">‚Üí üîö Ïî¨${choice.next}</span>`;
                    } else if (hasNext) {
                        html += `<span class="flat-arrow">‚Üí Ïî¨${choice.next}</span>`;
                        html += branchInfo;
                    } else if (choice.next) {
                        html += `<span class="flat-arrow flat-incomplete">‚Üí Ïî¨${choice.next} (ÎØ∏ÏûëÏÑ±)</span>`;
                    }

                    html += `</div>`;
                });
                html += `</div>`;
            } else {
                html += `<div class="flat-incomplete-notice">‚ö†Ô∏è ÏÑ†ÌÉùÏßÄ ÏóÜÏùå (ÎØ∏ÏôÑÏÑ±)</div>`;
            }

            html += `</div>`;
            return html;
        }

        // ÌéºÏ≥êÏßÑ Î™®Îì† Ïî¨ Î∏îÎ°ù ÏàòÏßë Î∞è Î†åÎçîÎßÅ
        function collectExpandedBlocks(sceneNum, pathKey, pathSteps, blocks, visited) {
            if (visited.has(sceneNum)) return;

            const scene = gameData[sceneNum];
            if (!scene || !scene.content) return;

            visited.add(sceneNum);

            // ÌòÑÏû¨ Ïî¨ Î∏îÎ°ù Ï∂îÍ∞Ä
            blocks.push({ sceneNum, pathKey, pathSteps: [...pathSteps] });

            // ÏóîÎî©Ïù¥Î©¥ Ï¢ÖÎ£å
            if (scene.isEnding) return;

            // ÌéºÏ≥êÏßÑ ÏÑ†ÌÉùÏßÄÎì§Ïùò Îã§Ïùå Ïî¨ Ï∂îÍ∞Ä
            const choices = scene.choices || [];
            choices.forEach((choice, cIdx) => {
                if (!choice.text || !choice.next) return;

                const choicePathKey = pathKey ? `${pathKey}-${cIdx}` : `${sceneNum}-${cIdx}`;

                if (expandedPaths.has(choicePathKey)) {
                    const nextScene = gameData[choice.next];
                    if (nextScene?.content && !nextScene.isEnding) {
                        const newPathSteps = [...pathSteps, { sceneNum, choiceIdx: cIdx }];
                        collectExpandedBlocks(choice.next, choicePathKey, newPathSteps, blocks, new Set(visited));
                    }
                }
            });
        }

        // Í≤ΩÎ°ú ÌéºÏπòÍ∏∞/Ï†ëÍ∏∞
        function togglePath(pathKey) {
            if (expandedPaths.has(pathKey)) {
                // Ï†ëÏùÑ Îïå: ÌïòÏúÑ Í≤ΩÎ°úÎèÑ Î™®Îëê Ï†ëÍ∏∞
                const toRemove = [];
                expandedPaths.forEach(p => {
                    if (p === pathKey || p.startsWith(pathKey + '-')) {
                        toRemove.push(p);
                    }
                });
                toRemove.forEach(p => expandedPaths.delete(p));
            } else {
                expandedPaths.add(pathKey);
            }
            updateStoryPreview();
        }

        // Ï†ÑÏ≤¥ ÌéºÏπòÍ∏∞
        function expandAllBranches() {
            function addAllPaths(sceneNum, pathKey, visited) {
                if (visited.has(sceneNum)) return;
                const scene = gameData[sceneNum];
                if (!scene || !scene.content || scene.isEnding) return;

                visited.add(sceneNum);
                (scene.choices || []).forEach((choice, cIdx) => {
                    if (choice.text && choice.next) {
                        const choicePathKey = pathKey ? `${pathKey}-${cIdx}` : `${sceneNum}-${cIdx}`;
                        const nextScene = gameData[choice.next];
                        if (nextScene?.content && !nextScene.isEnding) {
                            expandedPaths.add(choicePathKey);
                            addAllPaths(choice.next, choicePathKey, new Set(visited));
                        }
                    }
                });
            }
            addAllPaths(1, '', new Set());
            updateStoryPreview();
        }

        // Ï†ÑÏ≤¥ Ï†ëÍ∏∞
        function collapseAllBranches() {
            expandedPaths.clear();
            updateStoryPreview();
        }

        // Ïä§ÌÜ†Î¶¨ ÌîÑÎ¶¨Î∑∞ Î†åÎçîÎßÅ
        function renderStoryPreview() {
            if (!gameData[1] || !gameData[1].content) {
                return '<div style="color:#666;text-align:center;padding:30px;">Ïî¨ 1Î∂ÄÌÑ∞ ÏãúÏûëÌïòÏÑ∏Ïöî.</div>';
            }

            let html = '';

            // Ïª®Ìä∏Î°§ Î∞î
            html += `<div class="tree-controls">
                <button class="tree-ctrl-btn" onclick="expandAllBranches()">üìÇ Ï†ÑÏ≤¥ ÌéºÏπòÍ∏∞</button>
                <button class="tree-ctrl-btn" onclick="collapseAllBranches()">üìÅ Ï†ÑÏ≤¥ Ï†ëÍ∏∞</button>
            </div>`;

            // Î™®Îì† ÌéºÏ≥êÏßÑ Î∏îÎ°ù ÏàòÏßë
            const blocks = [];
            collectExpandedBlocks(1, '', [], blocks, new Set());

            // Î∏îÎ°ùÎì§ Î†åÎçîÎßÅ
            html += `<div class="flat-story-container">`;
            blocks.forEach(block => {
                html += renderSceneBlock(block.sceneNum, block.pathKey, block.pathSteps);
            });
            html += `</div>`;

            return html;
        }

        // HTML Ïù¥Ïä§ÏºÄÏù¥ÌîÑ Ìï®Ïàò
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ÌîÑÎ¶¨Î∑∞ÏóêÏÑú Ïù∏ÎùºÏù∏ Ìé∏Ïßë Ïó¥Í∏∞
        function openPreviewEdit(type, sceneNum, choiceIndex) {
            const modal = document.createElement('div');
            modal.className = 'preview-edit-modal';
            modal.id = 'previewEditModal';

            let currentValue = '';
            let title = '';

            if (type === 'scene') {
                currentValue = gameData[sceneNum]?.content || '';
                title = `Ïî¨ ${sceneNum} ÎÇ¥Ïö© Ìé∏Ïßë`;
            } else {
                currentValue = gameData[sceneNum]?.choices?.[choiceIndex]?.text || '';
                title = `Ïî¨ ${sceneNum} ÏÑ†ÌÉùÏßÄ ${choiceIndex + 1} Ìé∏Ïßë`;
            }

            modal.innerHTML = `
                <div class="preview-edit-content">
                    <div class="preview-edit-header">
                        <span>${title}</span>
                        <button onclick="closePreviewEdit()">‚úï</button>
                    </div>
                    <textarea id="previewEditText" rows="${type === 'scene' ? 6 : 2}">${escapeHtml(currentValue)}</textarea>
                    <div class="preview-edit-buttons">
                        <button class="btn-success" onclick="savePreviewEdit('${type}', ${sceneNum}, ${choiceIndex ?? 'null'})">Ï†ÄÏû•</button>
                        <button class="btn-danger" onclick="closePreviewEdit()">Ï∑®ÏÜå</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            document.getElementById('previewEditText').focus();
        }

        // ÌîÑÎ¶¨Î∑∞ Ìé∏Ïßë Ï†ÄÏû•
        function savePreviewEdit(type, sceneNum, choiceIndex) {
            const textarea = document.getElementById('previewEditText');
            const newValue = textarea.value;

            if (type === 'scene') {
                if (gameData[sceneNum]) {
                    gameData[sceneNum].content = newValue;
                }
            } else {
                if (gameData[sceneNum]?.choices?.[choiceIndex]) {
                    gameData[sceneNum].choices[choiceIndex].text = newValue;
                }
            }

            // Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî
            storyVersions[currentVersionIndex].data = gameData;
            saveAllVersionsToLocal();

            // UI ÏóÖÎç∞Ïù¥Ìä∏
            closePreviewEdit();
            updateStoryPreview();
            renderTree();
            updateStatus('Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.');
        }

        // ÌîÑÎ¶¨Î∑∞ Ìé∏Ïßë Îã´Í∏∞
        function closePreviewEdit() {
            const modal = document.getElementById('previewEditModal');
            if (modal) modal.remove();
        }

        // Ïä§ÌÜ†Î¶¨ ÌîÑÎ¶¨Î∑∞ ÏóÖÎç∞Ïù¥Ìä∏
        let previewNeedsUpdate = true;
        function updateStoryPreview() {
            const container = document.getElementById('storyPreviewContent');
            const previewContainer = document.getElementById('storyPreviewContainer');

            // ÌîÑÎ¶¨Î∑∞Í∞Ä Îã´ÌòÄÏûàÏúºÎ©¥ ÎÇòÏ§ëÏóê ÏóÖÎç∞Ïù¥Ìä∏
            if (previewContainer.classList.contains('collapsed')) {
                previewNeedsUpdate = true;
                return;
            }

            // Ìä∏Î¶¨ Î∑∞ Î†åÎçîÎßÅ (Ï¶âÏãú Î†åÎçîÎßÅ, Îß§Ïö∞ Îπ†Î¶Ñ)
            container.innerHTML = renderStoryPreview();
            previewNeedsUpdate = false;
        }

        // ÌîÑÎ¶¨Î∑∞ ÌÜ†Í∏Ä
        function toggleStoryPreview() {
            const container = document.getElementById('storyPreviewContainer');
            const btn = document.getElementById('previewToggle');
            const icon = btn.querySelector('.toggle-icon');

            container.classList.toggle('collapsed');
            const isCollapsed = container.classList.contains('collapsed');
            icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';

            // Ïó¥Î¶¥ Îïå ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöîÌïòÎ©¥ Í≥ÑÏÇ∞
            if (!isCollapsed && previewNeedsUpdate) {
                updateStoryPreview();
            }
        }

        // Ïî¨ Ìä∏Î¶¨ Ìå®ÎÑê ÌÜ†Í∏Ä
        function toggleTreePanel() {
            const panel = document.getElementById('treePanel');
            const btn = document.getElementById('treePanelToggle');
            const icon = btn.querySelector('.toggle-icon');

            panel.classList.toggle('collapsed');
            const isCollapsed = panel.classList.contains('collapsed');
            icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
        }

        // Incognito Î™®Îìú ÌÜ†Í∏Ä
        function toggleIncognito() {
            document.body.classList.toggle('incognito');
            const btn = document.getElementById('incognitoBtn');
            btn.classList.toggle('active');

            if (document.body.classList.contains('incognito')) {
                btn.textContent = 'üíº Work';
                document.querySelector('.title').textContent = 'Data Analysis Tool';
            } else {
                btn.textContent = 'üï∂Ô∏è Work';
                document.querySelector('.title').textContent = 'üéÆ Game Tree Editor';
            }
        }

        // ÌîÑÎ¶¨Î∑∞ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
        function initPreviewSystem() {
            // ÌîÑÎ¶¨Î∑∞Îäî Îã´Ìûå ÏÉÅÌÉúÎ°ú ÏãúÏûë, Ïó¥ Îïå Í≥ÑÏÇ∞
            const container = document.getElementById('storyPreviewContainer');
            container.classList.add('collapsed');
            document.querySelector('#previewToggle .toggle-icon').textContent = '‚ñ∂';
            previewNeedsUpdate = true;
        }

        // Ï¥àÍ∏∞Ìôî
        window.onload = async function() {
            // Î®ºÏ†Ä JSON ÌååÏùºÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÎèÑ
            const jsonLoaded = await loadFromJSON();

            if (!jsonLoaded) {
                // JSON Î°úÎìú Ïã§Ìå® Ïãú Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Î°úÎìú
                if (!loadAllVersionsFromLocal()) {
                    // Í∏∞Ï°¥ Îã®Ïùº Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏãúÎèÑ
                    const oldSaved = localStorage.getItem('gameTreeDataMobile');
                    if (oldSaved) {
                        try {
                            const oldData = JSON.parse(oldSaved);
                            storyVersions = [{
                                name: 'Î≤ÑÏ†Ñ 1',
                                title: 'Catch! Love',
                                data: oldData
                            }];
                            currentVersionIndex = 0;
                            gameData = oldData;
                            gameTitle = 'Catch! Love';
                            // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÌõÑ ÏÉà ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•
                            saveAllVersionsToLocal();
                        } catch (e) {
                            initDefaultVersion();
                        }
                    } else {
                        initDefaultVersion();
                    }
                }
            }

            updateUsedScenes();
            renderTree();
            renderVersionTabs();

            // Îç∞Ïä§ÌÅ¨ÌÜ±ÏóêÏÑúÎäî Ìå®ÎÑê Î™®Îëê ÌëúÏãú
            if (!isMobile) {
                document.getElementById('treePanel').classList.add('active');
                document.getElementById('editorPanel').classList.add('active');
            }

            // Î¶¨ÏÇ¨Ïù¥Ï†Ä Ï¥àÍ∏∞Ìôî
            initResizer();

            // ÏûêÎèô Ï†ÄÏû• ÌÉÄÏù¥Î®∏ ÏãúÏûë
            startAutoSave();

            // Ïä§ÌÜ†Î¶¨ ÌîÑÎ¶¨Î∑∞ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
            initPreviewSystem();

            updateStatus('Catch!-Love.jsonÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.');
        };

        // ÌéòÏù¥ÏßÄÎ•º Îñ†ÎÇ† Îïå Ï†ÄÏû•
        window.onbeforeunload = function() {
            autoSaveCurrentEdit();
        };

        // ÌÉ≠Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎê† ÎïåÎèÑ Ï†ÄÏû• (Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†ÄÏö©)
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                autoSaveCurrentEdit();
            }
        });

        // ========== ÌåùÏóÖ ÌîåÎ†àÏù¥ Í∏∞Îä• ==========
        let previewPopup = null;

        // ÌåùÏóÖÏóêÏÑú Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠ Î©îÏãúÏßÄ ÏàòÏã†
        window.addEventListener('message', function(e) {
            if (e.data.type === 'requestGameData') {
                autoSaveCurrentEdit();
                if (previewPopup && !previewPopup.closed) {
                    previewPopup.postMessage({
                        type: 'gameDataResponse',
                        gameData: gameData,
                        selectedScene: (selectedType === 'scene' && selectedNode) ? selectedNode : 1
                    }, '*');
                }
            }
        });

        function showPlayDialog() {
            autoSaveCurrentEdit();

            if (!gameData[1] || !gameData[1].content) {
                alert('Ïî¨ 1Ïóê ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // ÏÇ¨Ïö© Ï§ëÏù∏ Ïî¨ Î™©Î°ù ÏÉùÏÑ±
            const usedScenes = [];
            for (let i = 1; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim()) {
                    usedScenes.push(i);
                }
            }

            // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïî¨
            const currentSelectedScene = (selectedType === 'scene' && selectedNode) ? selectedNode : 1;

            // Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÏÉùÏÑ±
            const dialog = document.createElement('div');
            dialog.id = 'playDialog';
            dialog.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 2000; display: flex; align-items: center; justify-content: center;';

            let sceneOptions = usedScenes.map(num => {
                const preview = gameData[num].content.substring(0, 20);
                const selected = num === currentSelectedScene ? 'selected' : '';
                return `<option value="${num}" ${selected}>Ïî¨ ${num}: ${preview}${gameData[num].content.length > 20 ? '...' : ''}</option>`;
            }).join('');

            dialog.innerHTML = `
                <div style="background: white; border-radius: 15px; padding: 25px; max-width: 400px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                    <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">üéÆ ÌîåÎ†àÏù¥ÌïòÍ∏∞</h3>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 8px; color: #666; font-size: 14px;">ÏãúÏûëÌï† Ïî¨ ÏÑ†ÌÉù:</label>
                        <select id="playStartScene" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; cursor: pointer;">
                            ${sceneOptions}
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="document.getElementById('playDialog').remove();" style="flex: 1; padding: 12px; background: #6c757d; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">Ï∑®ÏÜå</button>
                        <button onclick="startPlayFromDialog();" style="flex: 1; padding: 12px; background: #9b59b6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">‚ñ∂Ô∏è ÏãúÏûë</button>
                    </div>
                </div>
            `;

            document.body.appendChild(dialog);

            // ESC ÌÇ§Î°ú Îã´Í∏∞
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) dialog.remove();
            });
        }

        function startPlayFromDialog() {
            const select = document.getElementById('playStartScene');
            const startScene = parseInt(select.value);
            document.getElementById('playDialog').remove();
            openPreviewPopup(startScene);
        }

        function openPreviewPopup(startScene = null) {
            autoSaveCurrentEdit();

            if (!gameData[1] || !gameData[1].content) {
                alert('Ïî¨ 1Ïóê ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // ÏãúÏûë Ïî¨ Í≤∞Ï†ï: Ïù∏ÏûêÎ°ú Î∞õÍ±∞ÎÇò, ÌòÑÏû¨ ÏÑ†ÌÉùÎêú Ïî¨ ÎòêÎäî 1
            const initialScene = startScene || (selectedType === 'scene' && selectedNode ? selectedNode : 1);

            // Í∏∞Ï°¥ ÌåùÏóÖÏù¥ Ïó¥Î†§ÏûàÏúºÎ©¥ Ìè¨Ïª§Ïä§ÌïòÍ≥† Ìï¥Îãπ Ïî¨ÏúºÎ°ú Ïù¥Îèô
            if (previewPopup && !previewPopup.closed) {
                previewPopup.focus();
                previewPopup.postMessage({ type: 'refresh', scene: initialScene, restart: true, gameData: gameData }, '*');
                return;
            }

            // ÌåùÏóÖ HTML ÏÉùÏÑ±
            const popupContent = generatePreviewPopupHTML(initialScene);

            previewPopup = window.open('', 'PreviewPopup', 'width=500,height=700,scrollbars=yes,resizable=yes');
            previewPopup.document.write(popupContent);
            previewPopup.document.close();
        }

        function generatePreviewPopupHTML(initialScene = 1) {
            // gameDataÎ•º JSONÏúºÎ°ú ÏßÅÎ†¨ÌôîÌïòÏó¨ ÌåùÏóÖÏóê Ï†ÑÎã¨
            const gameDataJSON = JSON.stringify(gameData);

            return `
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>üéÆ ÌîåÎ†àÏù¥ÌïòÍ∏∞</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        .header h1 { color: white; font-size: 18px; }
        .header-btns { display: flex; gap: 8px; flex-wrap: wrap; }
        .header-btns button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .start-options {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        .start-options button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .start-options button:hover { transform: translateY(-2px); }
        .content-box {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            min-height: 150px;
        }
        .scene-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .scene-num { font-size: 12px; color: #999; }
        .edit-btn {
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .edit-btn:hover { background: #0056b3; }
        .scene-content {
            font-size: 15px;
            line-height: 1.8;
            color: #333;
            white-space: pre-wrap;
        }
        .choices { display: flex; flex-direction: column; gap: 10px; }
        .choice-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            text-align: left;
            transition: all 0.2s;
        }
        .choice-btn:hover { transform: translateY(-2px); opacity: 0.9; }
        .choice-btn.success { background: #28a745; }
        .choice-btn.failure { background: #dc3545; }
        .choice-text { flex: 1; }
        .choice-edit {
            padding: 4px 8px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        .choice-edit:hover { background: rgba(255,255,255,0.3); }
        .ending {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
        }
        .ending-icon { font-size: 48px; margin-bottom: 10px; }
        .ending-text { font-size: 20px; color: white; font-weight: bold; }
        .path-box {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }
        .path-label { color: rgba(255,255,255,0.7); font-size: 11px; margin-bottom: 5px; }
        .path-content { color: white; font-size: 12px; word-break: break-all; }
        .warning {
            text-align: center;
            color: #dc3545;
            padding: 20px;
        }
        .warning-icon { font-size: 40px; margin-bottom: 10px; }
        .current-scene-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: white;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ ÌîåÎ†àÏù¥ÌïòÍ∏∞</h1>
        <div class="header-btns">
            <button onclick="goBack()" id="backBtn" style="background: #6c757d; color: white; display: none;">‚¨ÖÔ∏è Ïù¥Ï†Ñ</button>
            <button onclick="refreshCurrent()" style="background: #17a2b8; color: white;">üîÑ ÏÉàÎ°úÍ≥†Ïπ®</button>
        </div>
    </div>
    <div class="start-options">
        <button onclick="restart(1)" style="background: #9b59b6; color: white;">üìñ Ï≤òÏùåÎ∂ÄÌÑ∞</button>
        <button onclick="restartFromCurrent()" id="currentSceneBtn" style="background: #e67e22; color: white;">üìç ÌòÑÏû¨ Ïî¨Î∂ÄÌÑ∞</button>
    </div>
    <div id="content"></div>
    <div class="path-box">
        <div class="path-label">üìç Í≤ΩÎ°ú:</div>
        <div class="path-content" id="pathDisplay"></div>
    </div>

    <script>
        let currentScene = ${initialScene};
        let pathHistory = [];
        let sceneStack = [];
        let startedScene = ${initialScene};

        // ÌåùÏóÖ ÏÉùÏÑ± Ïãú Ï†ÑÎã¨Î∞õÏùÄ gameData (Ï¥àÍ∏∞Í∞í)
        let localGameData = ${gameDataJSON};

        function getGameData() {
            // Î∂ÄÎ™® Ï∞ΩÏóêÏÑú ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Í±∞ÎÇò, Î°úÏª¨ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            try {
                if (window.opener && !window.opener.closed && window.opener.gameData) {
                    return window.opener.gameData;
                }
            } catch(e) {
                // cross-origin Ï†ëÍ∑º Ïò§Î•ò Ïãú Î¨¥Ïãú
            }
            return localGameData;
        }

        function getCurrentSelectedScene() {
            if (window.opener && !window.opener.closed) {
                const type = window.opener.selectedType;
                const node = window.opener.selectedNode;
                if (type === 'scene' && node) return node;
            }
            return 1;
        }

        function showScene(sceneNum, addToStack = true) {
            const gameData = getGameData();
            const scene = gameData[sceneNum];

            if (addToStack && currentScene !== sceneNum) {
                sceneStack.push(currentScene);
            }
            currentScene = sceneNum;
            pathHistory.push('Ïî¨ ' + sceneNum);

            document.getElementById('pathDisplay').textContent = pathHistory.join(' ‚Üí ');
            document.getElementById('backBtn').style.display = sceneStack.length > 0 ? 'inline-block' : 'none';

            // ÌòÑÏû¨ Ïî¨ Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
            updateCurrentSceneBtn();

            const content = document.getElementById('content');

            if (!scene || !scene.content) {
                content.innerHTML = '<div class="content-box"><div class="warning"><div class="warning-icon">‚ö†Ô∏è</div><div>Ïî¨ ' + sceneNum + 'Ïù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§</div></div></div>';
                return;
            }

            let html = '<div class="content-box">';
            html += '<div class="scene-info"><span class="scene-num">üìç Ïî¨ ' + sceneNum + '</span>';
            html += '<button class="edit-btn" onclick="editScene(' + sceneNum + ')">‚úèÔ∏è Ìé∏Ïßë</button></div>';
            html += '<div class="scene-content">' + escapeHtml(scene.content) + '</div></div>';

            if (scene.isEnding) {
                html += '<div class="ending"><div class="ending-icon">üéâ</div><div class="ending-text">~ THE END ~</div></div>';
            } else if (scene.choices && scene.choices.length > 0) {
                html += '<div class="choices">';
                scene.choices.forEach((choice, idx) => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';
                        let btnClass = '';
                        let label = '';
                        if (outcome === 'success') { btnClass = 'success'; label = ' üéâ'; }
                        else if (outcome === 'failure') { btnClass = 'failure'; label = ' üíî'; }

                        html += '<button class="choice-btn ' + btnClass + '" onclick="selectChoice(' + sceneNum + ',' + idx + ')">';
                        html += '<span class="choice-text">' + (idx + 1) + '. ' + escapeHtml(choice.text) + label + '</span>';
                        html += '<span class="choice-edit" onclick="event.stopPropagation(); editChoice(' + sceneNum + ',' + idx + ')">Ìé∏Ïßë</span>';
                        html += '</button>';
                    }
                });
                html += '</div>';
            } else {
                html += '<div class="content-box"><div class="warning">ÏÑ†ÌÉùÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§</div></div>';
            }

            content.innerHTML = html;
        }

        function selectChoice(sceneNum, choiceIdx) {
            const gameData = getGameData();
            const choice = gameData[sceneNum].choices[choiceIdx];
            if (!choice) return;

            pathHistory.push('"' + choice.text.substring(0, 15) + (choice.text.length > 15 ? '...' : '') + '"');
            const outcome = choice.outcome || 'continue';

            if (outcome === 'success') {
                showEnding('success');
            } else if (outcome === 'failure') {
                showEnding('failure');
            } else if (choice.next && choice.next > 0) {
                showScene(choice.next);
            } else {
                document.getElementById('content').innerHTML = '<div class="content-box"><div class="warning"><div class="warning-icon">‚ö†Ô∏è</div><div>Îã§Ïùå Ïî¨Ïù¥ ÏßÄÏ†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§</div></div></div>';
            }
        }

        function showEnding(type) {
            document.getElementById('pathDisplay').textContent = pathHistory.join(' ‚Üí ');
            const icon = type === 'success' ? 'üíï' : 'üíî';
            const text = type === 'success' ? 'SUCCESS!' : 'MAYBE NEXT TIME...';
            const gradient = type === 'success' ? 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)' : 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)';
            document.getElementById('content').innerHTML = '<div class="ending" style="background: ' + gradient + '"><div class="ending-icon">' + icon + '</div><div class="ending-text">' + text + '</div></div>';
        }

        function editScene(sceneNum) {
            if (window.opener && !window.opener.closed) {
                window.opener.selectScene(sceneNum);
                window.opener.focus();
            }
        }

        function editChoice(sceneNum, choiceIdx) {
            if (window.opener && !window.opener.closed) {
                window.opener.selectChoice(sceneNum, choiceIdx);
                window.opener.focus();
            }
        }

        function goBack() {
            if (sceneStack.length > 0) {
                if (pathHistory.length > 0) pathHistory.pop();
                if (pathHistory.length > 0) pathHistory.pop();
                const prevScene = sceneStack.pop();
                showScene(prevScene, false);
            }
        }

        function restart(startFrom = 1) {
            currentScene = startFrom;
            pathHistory = [];
            sceneStack = [];
            startedScene = startFrom;
            showScene(startFrom, false);
        }

        function restartFromCurrent() {
            const scene = getCurrentSelectedScene();
            restart(scene);
        }

        function refreshCurrent() {
            // Î∂ÄÎ™® Ï∞ΩÏóê ÏµúÏã† Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠
            if (window.opener && !window.opener.closed) {
                window.opener.postMessage({ type: 'requestGameData' }, '*');
            } else {
                // Î∂ÄÎ™® Ï∞ΩÏù¥ ÏóÜÏúºÎ©¥ ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞Î°ú Îã§Ïãú Î†åÎçîÎßÅ
                showScene(currentScene, false);
                pathHistory.pop();
            }
        }

        function updateCurrentSceneBtn() {
            try {
                if (window.opener && !window.opener.closed) {
                    const type = window.opener.selectedType;
                    const node = window.opener.selectedNode;
                    if (type === 'scene' && node) {
                        document.getElementById('currentSceneBtn').textContent = 'üìç Ïî¨ ' + node + 'Î∂ÄÌÑ∞';
                        return;
                    }
                }
            } catch(e) {}
            document.getElementById('currentSceneBtn').textContent = 'üìç ÌòÑÏû¨ Ïî¨Î∂ÄÌÑ∞';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Î∂ÄÎ™® Ï∞ΩÏóêÏÑú Î©îÏãúÏßÄ ÏàòÏã†
        window.addEventListener('message', function(e) {
            // Îç∞Ïù¥ÌÑ∞ ÏùëÎãµ Ï≤òÎ¶¨ (ÏÉàÎ°úÍ≥†Ïπ® ÏöîÏ≤≠Ïóê ÎåÄÌïú ÏùëÎãµ)
            if (e.data.type === 'gameDataResponse') {
                localGameData = e.data.gameData;
                updateCurrentSceneBtn();
                showScene(currentScene, false);
                pathHistory.pop(); // showSceneÏóêÏÑú Ï∂îÍ∞ÄÌïú Í≤É Ï†úÍ±∞
                return;
            }

            // ÏùºÎ∞ò refresh Î©îÏãúÏßÄ Ï≤òÎ¶¨
            if (e.data.type === 'refresh') {
                if (e.data.gameData) {
                    localGameData = e.data.gameData;
                }
                if (e.data.restart) {
                    restart(e.data.scene || 1);
                } else {
                    showScene(e.data.scene || currentScene, false);
                    pathHistory.pop();
                }
                updateCurrentSceneBtn();
            }
        });

        // Ï¥àÍ∏∞Ìôî
        try {
            showScene(${initialScene}, false);
            updateCurrentSceneBtn();
        } catch(e) {
            document.getElementById('content').innerHTML = '<div class="content-box"><div class="warning"><div class="warning-icon">‚ö†Ô∏è</div><div>Ï¥àÍ∏∞Ìôî Ïò§Î•ò: ' + e.message + '</div></div></div>';
        }
    </` + `script>
</body>
</html>`;
        }

        // ÌåùÏóÖ ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò (Ìé∏Ïßë ÌõÑ Ìò∏Ï∂ú)
        function refreshPreviewPopup() {
            if (previewPopup && !previewPopup.closed) {
                previewPopup.postMessage({ type: 'refresh', gameData: gameData }, '*');
            }
        }
    </script>
</body>
</html>