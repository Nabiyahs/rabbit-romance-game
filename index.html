<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catch! Love — Editor</title>
  <style>
    /* ==================== Styles ==================== */
    :root {
      --color-1: #A1C3D1;
      --color-2: #B39BC8;
      --color-3: #F0EBF4;
      --color-4: #F172A1;
      --color-5: #E64398;
      --color-success: #44cc44;
      --color-failure: #ff4444;
      --shadow: 0 2px 8px rgba(0,0,0,0.1);
      --radius: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--color-3) 0%, #fff 100%);
      min-height: 100vh;
      padding: 0;
      color: #333;
    }

    /* TopBar */
    .topbar {
      background: linear-gradient(90deg, var(--color-1), var(--color-2));
      color: white;
      padding: 1rem 1.5rem;
      box-shadow: var(--shadow);
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .topbar h1 {
      font-size: 1.5rem;
      margin-right: auto;
      font-weight: 600;
    }

    .topbar button, .topbar select, .topbar input[type="file"] {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .topbar button:hover {
      background: var(--color-3);
      transform: translateY(-1px);
    }

    .topbar select {
      min-width: 150px;
    }

    /* Main Layout */
    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 1rem;
      max-width: 1800px;
      margin: 0 auto;
    }

    @media (min-width: 1024px) {
      .container {
        grid-template-columns: 30% 70%;
        padding: 1.5rem;
      }
    }

    /* Card Base */
    .card {
      background: white;
      border-radius: var(--radius);
      padding: 1.5rem;
      box-shadow: var(--shadow);
    }

    /* Scene List */
    .scene-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .scene-list-header {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid var(--color-3);
    }

    .scene-list-header input {
      padding: 0.5rem;
      border: 2px solid var(--color-1);
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .scene-list-header select {
      padding: 0.5rem;
      border: 2px solid var(--color-2);
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .scene-item {
      padding: 1rem;
      border: 2px solid var(--color-3);
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .scene-item:hover {
      border-color: var(--color-4);
      transform: translateX(4px);
    }

    .scene-item.active {
      border-color: var(--color-5);
      background: linear-gradient(90deg, #fff, var(--color-3));
      box-shadow: 0 4px 12px rgba(230, 67, 152, 0.2);
    }

    .scene-item.archived {
      opacity: 0.5;
      background: #f5f5f5;
    }

    .scene-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .scene-item-id {
      font-weight: 700;
      color: var(--color-5);
      font-size: 0.85rem;
    }

    .scene-item-name {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .scene-item-badges {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .badge {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-ending {
      background: var(--color-4);
      color: white;
    }

    .badge-archived {
      background: #999;
      color: white;
    }

    .badge-success {
      background: var(--color-success);
      color: white;
    }

    .badge-failure {
      background: var(--color-failure);
      color: white;
    }

    .scene-item-choices {
      font-size: 0.8rem;
      color: #666;
      line-height: 1.4;
    }

    .scene-item-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .scene-item-actions button {
      padding: 0.25rem 0.75rem;
      border: none;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-delete {
      background: #ff4444;
      color: white;
    }

    .btn-archive {
      background: #999;
      color: white;
    }

    .btn-unarchive {
      background: var(--color-1);
      color: white;
    }

    /* Right Panel */
    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Scene Editor */
    .scene-editor h2 {
      color: var(--color-5);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--color-3);
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .form-group input[type="text"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 0.75rem;
      border: 2px solid var(--color-1);
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-family: inherit;
    }

    .form-group textarea {
      min-height: 120px;
      resize: vertical;
    }

    .form-group input[type="checkbox"],
    .form-group input[type="radio"] {
      width: auto;
      margin-right: 0.5rem;
    }

    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--color-5);
    }

    .form-group input:read-only {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
    }

    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .radio-option {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .radio-option:hover {
      background: var(--color-3);
    }

    .radio-option label {
      cursor: pointer;
      margin-bottom: 0 !important;
      font-weight: normal !important;
    }

    .ending-info {
      background: var(--color-3);
      padding: 1rem;
      border-radius: var(--radius);
      margin-top: 0.5rem;
    }

    .choices-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }

    @media (min-width: 768px) {
      .choices-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .choice-card {
      border: 2px solid var(--color-2);
      border-radius: var(--radius);
      padding: 1rem;
      background: linear-gradient(135deg, #fff, var(--color-3));
    }

    .choice-card h4 {
      color: var(--color-5);
      margin-bottom: 0.75rem;
    }

    .choice-type-scene {
      margin-top: 0.5rem;
    }

    /* Player */
    .player {
      background: linear-gradient(135deg, var(--color-1), var(--color-2));
      color: white;
      min-height: 400px;
    }

    .player h2 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid rgba(255,255,255,0.3);
    }

    .player-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
    }

    .player-controls button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .player-controls button:hover {
      background: var(--color-3);
      transform: translateY(-2px);
    }

    .player-breadcrumb {
      background: rgba(255,255,255,0.2);
      padding: 0.75rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      font-size: 0.85rem;
      word-break: break-all;
    }

    .player-scene {
      background: white;
      color: #333;
      padding: 1.5rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
    }

    .player-scene-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .player-scene-content {
      line-height: 1.8;
      margin-bottom: 1.5rem;
      white-space: pre-wrap;
    }

    .player-choices {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .player-choice-btn {
      padding: 1rem;
      border: 2px solid var(--color-4);
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.2s;
      text-align: left;
    }

    .player-choice-btn:hover:not(:disabled) {
      background: var(--color-4);
      color: white;
      transform: translateX(8px);
    }

    .player-choice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .player-ending {
      text-align: center;
      padding: 2rem;
      border-radius: var(--radius);
      color: white;
    }

    .player-ending.success {
      background: linear-gradient(135deg, var(--color-success), #66dd66);
    }

    .player-ending.failure {
      background: linear-gradient(135deg, var(--color-failure), #ff6666);
    }

    .player-ending.normal {
      background: linear-gradient(135deg, var(--color-4), var(--color-5));
    }

    .player-ending h3 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .player-ending-code {
      font-size: 0.9rem;
      opacity: 0.9;
      margin-bottom: 0.5rem;
    }

    .player-ending-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .player-ending-summary {
      line-height: 1.6;
      opacity: 0.95;
    }

    /* Validation Panel */
    .validation-panel {
      background: white;
      border: 2px solid var(--color-4);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .validation-panel h3 {
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .validation-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      border-left: 4px solid;
    }

    .validation-item.error {
      background: #ffe5e5;
      border-color: #ff4444;
    }

    .validation-item.warning {
      background: #fff8e5;
      border-color: #ffaa00;
    }

    .validation-item.success {
      background: #e5ffe5;
      border-color: #44ff44;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <!-- ==================== Layout ==================== -->

  <!-- TopBar -->
  <div class="topbar">
    <h1>Catch! Love — Editor</h1>
    <button id="btn-add-scene" aria-label="새 씬 추가">➕ 새 씬</button>
    <select id="select-start-scene" aria-label="시작 씬 선택">
      <option value="">시작 씬 선택</option>
    </select>
    <button id="btn-validate" aria-label="유효성 검사">✓ 검사</button>
    <button id="btn-export" aria-label="JSON 내보내기">💾 내보내기</button>
    <label style="padding: 0.5rem 1rem; background: white; border-radius: var(--radius); cursor: pointer; font-weight: 500;">
      📂 불러오기
      <input type="file" id="input-import" accept=".json" style="display: none;" aria-label="JSON 불러오기">
    </label>
    <button id="btn-play" aria-label="플레이 모드 시작">▶ 플레이</button>
  </div>

  <!-- Main Container -->
  <div class="container">
    <!-- Left Panel: Scene List -->
    <div class="card scene-list">
      <div class="scene-list-header">
        <h2 style="color: var(--color-5);">씬 목록</h2>
        <input type="text" id="search-scene" placeholder="🔍 검색 (이름/ID)" aria-label="씬 검색">
        <select id="sort-scene" aria-label="씬 정렬">
          <option value="created">생성순</option>
          <option value="id">ID순</option>
        </select>
      </div>
      <div id="scene-list-items">
        <!-- Scene items will be rendered here -->
      </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <!-- Scene Editor -->
      <div class="card scene-editor">
        <h2>씬 에디터</h2>
        <div id="editor-content">
          <p style="color: #999; text-align: center; padding: 2rem;">좌측에서 씬을 선택하세요</p>
        </div>
      </div>

      <!-- Player Preview -->
      <div class="card player">
        <h2>플레이어 미리보기</h2>
        <div class="player-controls">
          <button id="btn-player-start">시작</button>
          <button id="btn-player-restart">재시작</button>
        </div>
        <div id="player-content">
          <p style="opacity: 0.8;">'시작' 버튼을 눌러 플레이를 시작하세요</p>
        </div>
      </div>

      <!-- Validation Panel (hidden by default) -->
      <div id="validation-panel" class="validation-panel hidden">
        <h3>유효성 검사 결과</h3>
        <div id="validation-results"></div>
      </div>
    </div>
  </div>

  <script>
    // ==================== State ====================

    let game = {
      id: 'game-001',
      title: 'Catch! Love',
      palette: ['#A1C3D1', '#B39BC8', '#F0EBF4', '#F172A1', '#E64398'],
      startSceneId: 'S001',
      scenes: [],
      createdAt: nowISO(),
      updatedAt: nowISO(),
      version: 1
    };

    let currentSceneId = null; // Currently selected scene in editor
    let playerSceneId = null;  // Current scene in player
    let playerPath = [];       // Breadcrumb trail

    // ==================== Utils ====================

    function nowISO() {
      return new Date().toISOString();
    }

    function byId(id) {
      return document.getElementById(id);
    }

    function getNextSceneNumber() {
      if (game.scenes.length === 0) return 1;
      const numbers = game.scenes.map(s => {
        const match = s.id.match(/^S(\d+)$/);
        return match ? parseInt(match[1], 10) : 0;
      });
      return Math.max(...numbers) + 1;
    }

    function generateSceneId() {
      const num = getNextSceneNumber();
      return 'S' + String(num).padStart(3, '0');
    }

    function generateChoiceIds(sceneId) {
      return [sceneId.replace('S', 'C') + 'A', sceneId.replace('S', 'C') + 'B'];
    }

    function findScene(sceneId) {
      return game.scenes.find(s => s.id === sceneId);
    }

    function ensureTwo(arr) {
      while (arr.length < 2) {
        arr.push({ id: '', label: '', type: 'scene', nextSceneId: '', note: '' });
      }
      return arr.slice(0, 2);
    }

    function getChoiceDisplay(choice) {
      if (choice.type === 'success') {
        return '[성공 엔딩]';
      } else if (choice.type === 'failure') {
        return '[실패 엔딩]';
      } else {
        return choice.nextSceneId || '?';
      }
    }

    // ==================== Renderers ====================

    function renderSceneList() {
      const container = byId('scene-list-items');
      const searchTerm = byId('search-scene').value.toLowerCase();
      const sortBy = byId('sort-scene').value;

      let filtered = game.scenes.filter(s => {
        if (searchTerm === '') return true;
        return s.id.toLowerCase().includes(searchTerm) ||
               s.name.toLowerCase().includes(searchTerm);
      });

      if (sortBy === 'id') {
        filtered.sort((a, b) => a.id.localeCompare(b.id));
      } else {
        filtered.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      }

      container.innerHTML = '';

      filtered.forEach(scene => {
        const div = document.createElement('div');
        div.className = 'scene-item';
        if (scene.id === currentSceneId) div.classList.add('active');
        if (scene.isArchived) div.classList.add('archived');

        let badges = '';
        if (scene.isEnding) {
          badges += '<span class="badge badge-ending">ENDING</span>';
        }
        if (scene.isArchived) {
          badges += '<span class="badge badge-archived">보관됨</span>';
        }

        const choices = ensureTwo(scene.choices || []);
        const choiceA = choices[0];
        const choiceB = choices[1];

        const choiceText = `A: ${choiceA.label || '(없음)'} → ${getChoiceDisplay(choiceA)}<br>B: ${choiceB.label || '(없음)'} → ${getChoiceDisplay(choiceB)}`;

        div.innerHTML = `
          <div class="scene-item-header">
            <span class="scene-item-id">${scene.id}</span>
          </div>
          <div class="scene-item-name">${scene.name || '(이름 없음)'}</div>
          ${badges ? `<div class="scene-item-badges">${badges}</div>` : ''}
          <div class="scene-item-choices">${choiceText}</div>
          <div class="scene-item-actions">
            <button class="btn-delete" data-id="${scene.id}">삭제</button>
            ${scene.isArchived
              ? `<button class="btn-unarchive" data-id="${scene.id}">복원</button>`
              : `<button class="btn-archive" data-id="${scene.id}">보관</button>`
            }
          </div>
        `;

        div.addEventListener('click', (e) => {
          if (e.target.tagName === 'BUTTON') return;
          currentSceneId = scene.id;
          renderSceneList();
          renderEditor();
        });

        container.appendChild(div);
      });

      // Attach action handlers
      container.querySelectorAll('.btn-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteScene(btn.dataset.id);
        });
      });

      container.querySelectorAll('.btn-archive').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleArchive(btn.dataset.id, true);
        });
      });

      container.querySelectorAll('.btn-unarchive').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleArchive(btn.dataset.id, false);
        });
      });
    }

    function renderEditor() {
      const container = byId('editor-content');

      if (!currentSceneId) {
        container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">좌측에서 씬을 선택하세요</p>';
        return;
      }

      const scene = findScene(currentSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #f44; text-align: center; padding: 2rem;">씬을 찾을 수 없습니다</p>';
        return;
      }

      const choices = ensureTwo(scene.choices || []);
      const choiceA = choices[0];
      const choiceB = choices[1];

      const sceneOptions = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceA.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      const sceneOptionsB = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceB.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      container.innerHTML = `
        <div class="form-group">
          <label>씬 ID</label>
          <input type="text" id="edit-id" value="${scene.id}" readonly>
        </div>

        <div class="form-group">
          <label>씬 이름</label>
          <input type="text" id="edit-name" value="${scene.name || ''}">
        </div>

        <div class="form-group">
          <div class="checkbox-group">
            <input type="checkbox" id="edit-is-ending" ${scene.isEnding ? 'checked' : ''}>
            <label for="edit-is-ending">엔딩 씬으로 설정</label>
          </div>
        </div>

        <div id="ending-info-container" class="${scene.isEnding ? '' : 'hidden'}">
          <div class="ending-info">
            <div class="form-group">
              <label>엔딩 코드</label>
              <input type="text" id="edit-ending-code" value="${scene.endingInfo?.code || ''}">
            </div>
            <div class="form-group">
              <label>엔딩 타이틀</label>
              <input type="text" id="edit-ending-title" value="${scene.endingInfo?.title || ''}">
            </div>
            <div class="form-group">
              <label>엔딩 요약</label>
              <textarea id="edit-ending-summary">${scene.endingInfo?.summary || ''}</textarea>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>씬 본문</label>
          <textarea id="edit-content">${scene.content || ''}</textarea>
        </div>

        <h3 style="color: var(--color-5); margin: 1.5rem 0 1rem;">선택지</h3>
        <div class="choices-container">
          <div class="choice-card">
            <h4>선택지 A</h4>
            <div class="form-group">
              <label>라벨</label>
              <input type="text" id="edit-choice-a-label" value="${choiceA.label || ''}">
            </div>
            <div class="form-group">
              <label>타입</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-scene" name="choice-a-type" value="scene" ${(choiceA.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-scene">다음 씬으로 진행</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-success" name="choice-a-type" value="success" ${choiceA.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-success">성공 엔딩</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-failure" name="choice-a-type" value="failure" ${choiceA.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-failure">실패 엔딩</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-a-scene-select" ${(choiceA.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>다음 씬</label>
              <select id="edit-choice-a-next">
                <option value="">선택 안함</option>
                ${sceneOptions}
              </select>
            </div>
            <div class="form-group">
              <label>메모 (선택)</label>
              <input type="text" id="edit-choice-a-note" value="${choiceA.note || ''}">
            </div>
          </div>

          <div class="choice-card">
            <h4>선택지 B</h4>
            <div class="form-group">
              <label>라벨</label>
              <input type="text" id="edit-choice-b-label" value="${choiceB.label || ''}">
            </div>
            <div class="form-group">
              <label>타입</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-scene" name="choice-b-type" value="scene" ${(choiceB.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-scene">다음 씬으로 진행</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-success" name="choice-b-type" value="success" ${choiceB.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-success">성공 엔딩</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-failure" name="choice-b-type" value="failure" ${choiceB.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-failure">실패 엔딩</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-b-scene-select" ${(choiceB.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>다음 씬</label>
              <select id="edit-choice-b-next">
                <option value="">선택 안함</option>
                ${sceneOptionsB}
              </select>
            </div>
            <div class="form-group">
              <label>메모 (선택)</label>
              <input type="text" id="edit-choice-b-note" value="${choiceB.note || ''}">
            </div>
          </div>
        </div>
      `;

      // Attach event listeners
      byId('edit-name').addEventListener('input', updateScene);
      byId('edit-is-ending').addEventListener('change', updateScene);
      byId('edit-content').addEventListener('input', updateScene);

      if (scene.isEnding) {
        byId('edit-ending-code').addEventListener('input', updateScene);
        byId('edit-ending-title').addEventListener('input', updateScene);
        byId('edit-ending-summary').addEventListener('input', updateScene);
      }

      byId('edit-choice-a-label').addEventListener('input', updateScene);
      byId('edit-choice-a-next').addEventListener('change', updateScene);
      byId('edit-choice-a-note').addEventListener('input', updateScene);
      byId('edit-choice-b-label').addEventListener('input', updateScene);
      byId('edit-choice-b-next').addEventListener('change', updateScene);
      byId('edit-choice-b-note').addEventListener('input', updateScene);

      // Choice type handlers
      ['a', 'b'].forEach(choice => {
        ['scene', 'success', 'failure'].forEach(type => {
          const radio = byId(`edit-choice-${choice}-type-${type}`);
          if (radio) {
            radio.addEventListener('change', () => {
              const sceneSelect = byId(`choice-${choice}-scene-select`);
              if (type === 'scene') {
                sceneSelect.style.display = 'block';
              } else {
                sceneSelect.style.display = 'none';
              }
              updateScene();
            });
          }
        });
      });
    }

    function renderPlayer() {
      const container = byId('player-content');

      if (!playerSceneId) {
        container.innerHTML = '<p style="opacity: 0.8;">\'시작\' 버튼을 눌러 플레이를 시작하세요</p>';
        return;
      }

      // Check if it's a special ending
      if (playerSceneId === '__SUCCESS__' || playerSceneId === '__FAILURE__') {
        const endingType = playerSceneId === '__SUCCESS__' ? 'success' : 'failure';
        const endingTitle = playerSceneId === '__SUCCESS__' ? '성공 엔딩' : '실패 엔딩';
        const breadcrumb = playerPath.length > 0
          ? `<div class="player-breadcrumb">경로: ${playerPath.join(' → ')}</div>`
          : '';

        container.innerHTML = `
          ${breadcrumb}
          <div class="player-ending ${endingType}">
            <h3>THE END</h3>
            <div class="player-ending-title">${endingTitle}</div>
          </div>
        `;
        return;
      }

      const scene = findScene(playerSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #f44;">씬을 찾을 수 없습니다: ' + playerSceneId + '</p>';
        return;
      }

      // Breadcrumb
      const breadcrumb = playerPath.length > 0
        ? `<div class="player-breadcrumb">경로: ${playerPath.join(' → ')}</div>`
        : '';

      // Scene display
      let sceneHTML = `
        ${breadcrumb}
        <div class="player-scene">
          <div class="player-scene-name">${scene.name || '(이름 없음)'}</div>
          <div class="player-scene-content">${scene.content || ''}</div>
        </div>
      `;

      if (scene.isEnding) {
        // Ending display
        sceneHTML += `
          <div class="player-ending normal">
            <h3>THE END</h3>
            ${scene.endingInfo?.code ? `<div class="player-ending-code">CODE: ${scene.endingInfo.code}</div>` : ''}
            ${scene.endingInfo?.title ? `<div class="player-ending-title">${scene.endingInfo.title}</div>` : ''}
            ${scene.endingInfo?.summary ? `<div class="player-ending-summary">${scene.endingInfo.summary}</div>` : ''}
          </div>
        `;
      } else {
        // Choices
        const choices = ensureTwo(scene.choices || []);
        sceneHTML += '<div class="player-choices">';

        choices.forEach((choice, idx) => {
          const label = choice.label || `선택지 ${String.fromCharCode(65 + idx)}`;
          const type = choice.type || 'scene';
          const disabled = (type === 'scene' && !choice.nextSceneId) ? 'disabled' : '';

          sceneHTML += `
            <button class="player-choice-btn" data-type="${type}" data-next="${choice.nextSceneId || ''}" ${disabled}>
              ${label}
            </button>
          `;
        });

        sceneHTML += '</div>';
      }

      container.innerHTML = sceneHTML;

      // Attach choice handlers
      container.querySelectorAll('.player-choice-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          const nextId = btn.dataset.next;

          playerPath.push(scene.name || scene.id);

          if (type === 'success') {
            playerSceneId = '__SUCCESS__';
          } else if (type === 'failure') {
            playerSceneId = '__FAILURE__';
          } else if (nextId) {
            playerSceneId = nextId;
          }

          renderPlayer();
        });
      });
    }

    function refreshStartSelect() {
      const select = byId('select-start-scene');
      select.innerHTML = '<option value="">시작 씬 선택</option>';

      game.scenes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = `${s.id} - ${s.name}`;
        if (s.id === game.startSceneId) opt.selected = true;
        select.appendChild(opt);
      });
    }

    // ==================== Events ====================

    function addScene() {
      const newId = generateSceneId();
      const choiceIds = generateChoiceIds(newId);

      const newScene = {
        id: newId,
        name: '새 씬',
        isEnding: false,
        content: 'TODO',
        choices: [
          { id: choiceIds[0], label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: choiceIds[1], label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes.push(newScene);
      game.updatedAt = nowISO();

      currentSceneId = newId;

      renderSceneList();
      renderEditor();
      refreshStartSelect();
    }

    function deleteScene(sceneId) {
      // Check if referenced by other scenes
      const references = [];
      game.scenes.forEach(s => {
        if (s.id === sceneId) return;
        const choices = ensureTwo(s.choices || []);
        choices.forEach(c => {
          if (c.nextSceneId === sceneId) {
            references.push(`${s.id} (${s.name})`);
          }
        });
      });

      if (references.length > 0) {
        const msg = `다음 씬에서 이 씬을 참조하고 있습니다:\n${references.join('\n')}\n\n정말 삭제하시겠습니까?`;
        if (!confirm(msg)) return;
      } else {
        if (!confirm(`씬 ${sceneId}을(를) 삭제하시겠습니까?`)) return;
      }

      game.scenes = game.scenes.filter(s => s.id !== sceneId);
      game.updatedAt = nowISO();

      if (currentSceneId === sceneId) {
        currentSceneId = null;
      }

      if (game.startSceneId === sceneId) {
        game.startSceneId = game.scenes.length > 0 ? game.scenes[0].id : '';
      }

      renderSceneList();
      renderEditor();
      refreshStartSelect();
    }

    function toggleArchive(sceneId, archived) {
      const scene = findScene(sceneId);
      if (!scene) return;

      scene.isArchived = archived;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderSceneList();
    }

    function updateScene() {
      const scene = findScene(currentSceneId);
      if (!scene) return;

      scene.name = byId('edit-name').value;
      scene.isEnding = byId('edit-is-ending').checked;
      scene.content = byId('edit-content').value;

      if (scene.isEnding) {
        if (!scene.endingInfo) scene.endingInfo = {};
        scene.endingInfo.code = byId('edit-ending-code')?.value || '';
        scene.endingInfo.title = byId('edit-ending-title')?.value || '';
        scene.endingInfo.summary = byId('edit-ending-summary')?.value || '';

        // Show ending info
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.remove('hidden');
      } else {
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.add('hidden');
      }

      const choices = ensureTwo(scene.choices || []);

      // Choice A
      choices[0].label = byId('edit-choice-a-label').value;
      choices[0].note = byId('edit-choice-a-note').value;
      const typeA = document.querySelector('input[name="choice-a-type"]:checked')?.value || 'scene';
      choices[0].type = typeA;
      if (typeA === 'scene') {
        choices[0].nextSceneId = byId('edit-choice-a-next').value;
      } else {
        choices[0].nextSceneId = '';
      }

      // Choice B
      choices[1].label = byId('edit-choice-b-label').value;
      choices[1].note = byId('edit-choice-b-note').value;
      const typeB = document.querySelector('input[name="choice-b-type"]:checked')?.value || 'scene';
      choices[1].type = typeB;
      if (typeB === 'scene') {
        choices[1].nextSceneId = byId('edit-choice-b-next').value;
      } else {
        choices[1].nextSceneId = '';
      }

      scene.choices = choices;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderSceneList();

      // Update player if currently viewing this scene
      if (playerSceneId === currentSceneId) {
        renderPlayer();
      }
    }

    function startPlayer() {
      if (!game.startSceneId) {
        alert('시작 씬이 설정되지 않았습니다');
        return;
      }

      playerSceneId = game.startSceneId;
      playerPath = [];
      renderPlayer();
    }

    function restartPlayer() {
      startPlayer();
    }

    // ==================== Validation ====================

    function validate() {
      const results = [];

      // Check startSceneId exists
      if (!game.startSceneId) {
        results.push({ type: 'error', msg: '시작 씬이 설정되지 않았습니다' });
      } else if (!findScene(game.startSceneId)) {
        results.push({ type: 'error', msg: `시작 씬 ${game.startSceneId}이(가) 존재하지 않습니다` });
      } else {
        const startScene = findScene(game.startSceneId);
        if (startScene.isEnding) {
          results.push({ type: 'warning', msg: '시작 씬이 엔딩 씬입니다' });
        }
      }

      // Check duplicate IDs
      const ids = game.scenes.map(s => s.id);
      const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);
      if (duplicates.length > 0) {
        results.push({ type: 'error', msg: `중복 ID 발견: ${duplicates.join(', ')}` });
      }

      // Check each scene
      game.scenes.forEach(scene => {
        // Check choices length
        if (!scene.choices || scene.choices.length !== 2) {
          results.push({ type: 'error', msg: `씬 ${scene.id}: 선택지가 정확히 2개여야 합니다` });
        }

        // Check nextSceneId validity
        const choices = ensureTwo(scene.choices || []);
        choices.forEach((choice, idx) => {
          const type = choice.type || 'scene';

          if (type === 'scene' && !choice.nextSceneId) {
            results.push({
              type: 'error',
              msg: `씬 ${scene.id}, 선택지 ${String.fromCharCode(65 + idx)}: 타입이 '다음 씬'인데 씬이 지정되지 않았습니다`
            });
          }

          if (type === 'scene' && choice.nextSceneId && !findScene(choice.nextSceneId)) {
            results.push({
              type: 'error',
              msg: `씬 ${scene.id}, 선택지 ${String.fromCharCode(65 + idx)}: 존재하지 않는 씬 참조 (${choice.nextSceneId})`
            });
          }
        });
      });

      // Check unreachable scenes
      if (game.startSceneId && findScene(game.startSceneId)) {
        const reachable = new Set();
        const queue = [game.startSceneId];

        while (queue.length > 0) {
          const id = queue.shift();
          if (reachable.has(id)) continue;
          reachable.add(id);

          const scene = findScene(id);
          if (!scene) continue;

          const choices = ensureTwo(scene.choices || []);
          choices.forEach(c => {
            const type = c.type || 'scene';
            if (type === 'scene' && c.nextSceneId && !reachable.has(c.nextSceneId)) {
              queue.push(c.nextSceneId);
            }
          });
        }

        const unreachable = game.scenes.filter(s => !reachable.has(s.id));
        if (unreachable.length > 0) {
          results.push({
            type: 'warning',
            msg: `시작 씬에서 도달 불가능한 씬: ${unreachable.map(s => s.id).join(', ')}`
          });
        }
      }

      // Display results
      const panel = byId('validation-panel');
      const resultsContainer = byId('validation-results');

      if (results.length === 0) {
        results.push({ type: 'success', msg: '✓ 모든 검사를 통과했습니다!' });
      }

      resultsContainer.innerHTML = results.map(r =>
        `<div class="validation-item ${r.type}">${r.msg}</div>`
      ).join('');

      panel.classList.remove('hidden');

      // Auto-hide success after 3s
      if (results.every(r => r.type === 'success')) {
        setTimeout(() => panel.classList.add('hidden'), 3000);
      }
    }

    // ==================== Import/Export ====================

    function exportJSON() {
      const json = JSON.stringify(game, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${game.title.replace(/\s+/g, '-')}-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function importJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Basic validation
          if (!data.scenes || !Array.isArray(data.scenes)) {
            throw new Error('Invalid JSON: scenes 배열이 없습니다');
          }

          game = data;
          currentSceneId = null;
          playerSceneId = null;
          playerPath = [];

          renderSceneList();
          renderEditor();
          refreshStartSelect();
          renderPlayer();

          alert('JSON을 성공적으로 불러왔습니다');
        } catch (err) {
          alert('JSON 불러오기 실패: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ==================== Boot ====================

    function init() {
      // Create initial scenes
      const s001 = {
        id: 'S001',
        name: '시작',
        isEnding: false,
        content: 'TODO: 시작 씬 내용을 작성하세요',
        choices: [
          { id: 'C001A', label: 'TODO', type: 'scene', nextSceneId: 'S002', note: '' },
          { id: 'C001B', label: 'TODO', type: 'scene', nextSceneId: 'S003', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s002 = {
        id: 'S002',
        name: '중간 씬',
        isEnding: false,
        content: 'TODO: 중간 씬 내용을 작성하세요',
        choices: [
          { id: 'C002A', label: '성공적으로 해결', type: 'success', nextSceneId: '', note: '' },
          { id: 'C002B', label: '실패하고 포기', type: 'failure', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s003 = {
        id: 'S003',
        name: '엔딩',
        isEnding: true,
        endingInfo: {
          code: 'END-001',
          title: 'TODO Ending',
          summary: 'TODO: 엔딩 요약을 작성하세요'
        },
        content: 'TODO: 엔딩 씬 내용을 작성하세요',
        choices: [
          { id: 'C003A', label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: 'C003B', label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes = [s001, s002, s003];

      // Attach event listeners
      byId('btn-add-scene').addEventListener('click', addScene);
      byId('btn-validate').addEventListener('click', validate);
      byId('btn-export').addEventListener('click', exportJSON);
      byId('input-import').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          importJSON(e.target.files[0]);
        }
      });
      byId('btn-play').addEventListener('click', startPlayer);
      byId('btn-player-start').addEventListener('click', startPlayer);
      byId('btn-player-restart').addEventListener('click', restartPlayer);

      byId('select-start-scene').addEventListener('change', (e) => {
        game.startSceneId = e.target.value;
        game.updatedAt = nowISO();
      });

      byId('search-scene').addEventListener('input', renderSceneList);
      byId('sort-scene').addEventListener('change', renderSceneList);

      // Initial render
      renderSceneList();
      renderEditor();
      refreshStartSelect();
      renderPlayer();
    }

    // Start the app
    init();
  </script>
</body>
</html>
