<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game Tree Editor - Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header {
            padding: 15px;
            border-bottom: 2px solid #eee;
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        /* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */
        .tab-nav {
            display: none;
            background: #f8f9fa;
            padding: 10px;
            gap: 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .tab-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            min-height: 500px;
            position: relative;
        }

        .panel {
            padding: 20px;
            overflow-y: auto;
        }

        .tree-panel {
            width: 100%;
            background: #fafafa;
            border-bottom: 1px solid #ddd;
            max-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .tree-panel-header {
            padding: 10px 0;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }

        .tree-panel-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .tree-panel-controls button {
            flex: 1;
            padding: 8px 12px;
            font-size: 13px;
        }

        .resizer {
            display: none;
        }

        .editor-panel {
            flex: 1;
            background: white;
            max-height: 500px;
            border-top: 1px solid #ddd;
        }

        /* Tree Styles */
        .tree {
            font-size: 14px;
        }

        .tree ul {
            list-style: none;
            margin: 0;
            padding-left: 0;
        }

        .tree li {
            margin: 3px 0;
            position: relative;
        }

        .tree li ul {
            margin-left: 20px;
        }

        .tree li::before {
            content: '';
            position: absolute;
            top: 12px;
            left: -12px;
            width: 10px;
            height: 1px;
            background: #999;
        }

        .tree li::after {
            content: '';
            position: absolute;
            left: -12px;
            top: -8px;
            bottom: 12px;
            width: 1px;
            background: #999;
        }

        .tree > ul > li::before,
        .tree > ul > li::after {
            display: none;
        }

        .scene-node, .choice-node {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            margin: 2px 0;
            user-select: none;
        }

        .scene-node {
            background: white;
            border: 2px solid #007bff;
        }

        .scene-node:active {
            transform: scale(0.98);
        }

        .scene-node.selected {
            background: #007bff;
            color: white;
        }

        .scene-node.empty {
            border-style: dashed;
            opacity: 0.6;
        }

        .scene-node.ending {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .choice-node {
            background: #f0f0f0;
            border: 1px solid #999;
            font-size: 12px;
        }

        .choice-node.selected {
            background: #6c757d;
            color: white;
        }

        /* Editor Styles */
        .editor-section {
            margin-bottom: 20px;
        }

        .editor-label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
        }

        .editor-input, .editor-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px; /* iOS ì¤Œ ë°©ì§€ */
        }

        .editor-textarea {
            min-height: 120px;
            resize: vertical;
            font-family: inherit;
        }

        .choice-container {
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 12px;
            background: #f9f9f9;
        }

        .choice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .next-scene-control {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .next-scene-input {
            width: 100px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 16px;
        }

        .auto-btn {
            padding: 8px 12px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 13px;
        }

        .delete-btn {
            padding: 6px 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }

        .add-choice-btn {
            padding: 10px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
        }

        .editor-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .editor-controls button {
            flex: 1;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }

        .checkbox-label input {
            width: 20px;
            height: 20px;
        }

        .status-bar {
            padding: 12px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            font-size: 13px;
            text-align: center;
        }

        .stats-info {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .stat-value {
            font-weight: bold;
            color: #007bff;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }

        /* ëª¨ë°”ì¼ ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
                box-shadow: none;
            }

            .header {
                position: sticky;
                top: 0;
                background: white;
                z-index: 100;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }

            .tree-panel {
                max-height: none;
            }

            .title {
                font-size: 18px;
            }

            .buttons {
                gap: 5px;
            }

            button {
                padding: 8px 12px;
                font-size: 13px;
            }

            .tab-nav {
                display: flex;
                position: sticky;
                top: 60px;
                z-index: 99;
                background: white;
                border-bottom: 1px solid #ddd;
            }

            .panel {
                display: none;
                min-height: calc(100vh - 200px);
                max-height: none !important;
            }

            .panel.active {
                display: block;
            }

            /* ëª¨ë°”ì¼ì—ì„œ íŠ¸ë¦¬ í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
            .scene-node, .choice-node {
                padding: 10px 14px;
                font-size: 14px;
                margin: 4px 0;
            }

            .editor-input, .editor-textarea, .next-scene-input {
                font-size: 16px; /* iOS ì¤Œ ë°©ì§€ */
            }

            .editor-controls {
                flex-direction: column;
            }

            .editor-controls button {
                width: 100%;
                padding: 12px;
            }

            .next-scene-control {
                flex-direction: column;
                align-items: stretch;
            }

            .next-scene-input {
                width: 100%;
            }

            .auto-btn {
                width: 100%;
                padding: 10px;
            }

            /* ìŠ¤í¬ë¡¤ ê°œì„  */
            .tree-panel, .editor-panel {
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
            }

            /* í„°ì¹˜ í”¼ë“œë°± */
            button:active, .scene-node:active, .choice-node:active {
                opacity: 0.8;
            }
        }

        /* íƒœë¸”ë¦¿ */
        @media (min-width: 769px) and (max-width: 1024px) {
            .tree-panel, .editor-panel {
                max-height: 350px;
            }
        }

        /* ê°€ë¡œ ëª¨ë“œ ìµœì í™” */
        @media (max-width: 768px) and (orientation: landscape) {
            .header {
                padding: 10px;
            }

            .title {
                font-size: 16px;
                margin-bottom: 5px;
            }

            .panel {
                min-height: calc(100vh - 150px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ğŸ® Game Tree Editor</h1>
            <div class="buttons">
                <button class="btn-primary" onclick="saveToLocal()">ğŸ’¾ ì €ì¥</button>
                <button class="btn-primary" onclick="loadFromLocal()">ğŸ“‚ ì—´ê¸°</button>
                <button class="btn-success" onclick="exportJSON()">ğŸ“¤ JSON</button>
                <button class="btn-info" onclick="importJSON()">ğŸ“¥ ê°€ì ¸ì˜¤ê¸°</button>
                <button style="background: #9b59b6; color: white;" onclick="startTestPlay()">â–¶ï¸ ì²˜ìŒë¶€í„°</button>
                <button id="testFromCurrentBtn" style="background: #8e44ad; color: white; display: none;" onclick="startTestPlayFromCurrent()">â–¶ï¸ í˜„ì¬ ì”¬</button>
                <button style="background: #e67e22; color: white;" onclick="openPreviewPopup()">ğŸ”² íŒì—… ë¯¸ë¦¬ë³´ê¸°</button>
                <button class="btn-danger" onclick="clearAll()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
        </div>

        <!-- ìŠ¤í† ë¦¬ ë²„ì „ ì„ íƒ ë°” -->
        <div class="version-bar" style="padding: 10px 15px; background: #f8f9fa; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <span style="font-weight: bold; color: #555;">ğŸ“š ìŠ¤í† ë¦¬:</span>
            <div id="versionTabs" style="display: flex; gap: 5px; flex-wrap: wrap;"></div>
            <button onclick="addNewVersion()" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;" id="addVersionBtn">â• ìƒˆ ë²„ì „</button>
            <button onclick="importAsNewVersion()" style="padding: 6px 12px; background: #17a2b8; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">ğŸ“¥ ìƒˆ ë²„ì „ìœ¼ë¡œ</button>
            <button onclick="appendToCurrentVersion()" style="padding: 6px 12px; background: #fd7e14; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 12px;">ğŸ“ ì´ì–´ë¶™ì´ê¸°</button>
        </div>

        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('tree')">ğŸŒ³ íŠ¸ë¦¬</button>
            <button class="tab-btn" onclick="switchTab('editor')">âœï¸ í¸ì§‘</button>
        </div>

        <div class="main-content">
            <div class="panel tree-panel active" id="treePanel">
                <div class="tree-panel-header">
                    <div class="tree-panel-controls">
                        <button class="btn-success" onclick="showAddSceneDialog()">â• ìƒˆ ì”¬</button>
                        <button class="btn-info" onclick="showAllScenes()">ğŸ“‹ ì „ì²´ ëª©ë¡</button>
                    </div>
                </div>
                <div class="tree" id="tree" style="flex: 1; overflow-y: auto;">
                    <div class="empty-state">ë¡œë”© ì¤‘...</div>
                </div>
            </div>

            <div class="resizer" id="resizer"></div>

            <div class="panel editor-panel" id="editorPanel">
                <div id="editor">
                    <div class="empty-state">
                        íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusMessage">ì¤€ë¹„ë¨</div>
            <div class="stats-info">
                <div>ì‚¬ìš©: <span class="stat-value" id="usedScenes">1</span></div>
                <div>ë‚¨ìŒ: <span class="stat-value" id="availableScenes">999</span></div>
                <div>ì „ì²´: <span class="stat-value">1000</span></div>
                <div style="border-left: 1px solid #ddd; padding-left: 15px;">â±ï¸ ì˜ˆìƒ: <span class="stat-value" id="estimatedTime">0ë¶„</span></div>
            </div>
        </div>
    </div>

    <!-- í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ëª¨ë‹¬ -->
    <div id="testPlayModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; overflow-y: auto;">
        <div style="max-width: 800px; margin: 20px auto; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; min-height: calc(100vh - 40px);">
            <div style="padding: 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid rgba(255,255,255,0.2);">
                <h2 style="color: white; margin: 0; font-size: 18px;">ğŸ® í…ŒìŠ¤íŠ¸ í”Œë ˆì´</h2>
                <div style="display: flex; gap: 10px;">
                    <button id="testBackBtn" onclick="goBackTestPlay()" style="padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; display: none;">â¬…ï¸ ì´ì „</button>
                    <button onclick="restartTestPlay()" style="padding: 8px 15px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">ğŸ”„ ì²˜ìŒë¶€í„°</button>
                    <button onclick="closeTestPlay()" style="padding: 8px 15px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">âœ• ë‹«ê¸°</button>
                </div>
            </div>
            <div style="padding: 20px;">
                <div id="testPlayContent" style="background: white; border-radius: 10px; padding: 25px; margin-bottom: 20px; min-height: 200px;">
                    <div id="testSceneNumber" style="font-size: 12px; color: #999; margin-bottom: 10px;"></div>
                    <div id="testSceneContent" style="font-size: 16px; line-height: 1.8; color: #333; white-space: pre-wrap;"></div>
                </div>
                <div id="testChoices" style="display: flex; flex-direction: column; gap: 12px;"></div>
                <div id="testHistory" style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="color: rgba(255,255,255,0.7); font-size: 12px; margin-bottom: 8px;">ğŸ“ ê²½ë¡œ:</div>
                    <div id="testPathHistory" style="color: white; font-size: 13px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ìŠ¤í† ë¦¬ ë²„ì „ ê´€ë¦¬
        const MAX_VERSIONS = 5;
        let storyVersions = []; // [{name: "ë²„ì „1", data: {...}, title: "Catch! Love"}, ...]
        let currentVersionIndex = 0;

        // í˜„ì¬ ë²„ì „ì˜ ë°ì´í„° (ê¸°ì¡´ ì½”ë“œì™€ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ getter/setter ì‚¬ìš©)
        let gameData = {};
        let selectedNode = null;
        let selectedType = null;
        let usedSceneNumbers = new Set();
        let isMobile = window.innerWidth <= 768;
        let gameTitle = "Catch! Love"; // ê²Œì„ ì œëª©
        let currentEditingScene = null; // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ì”¬ ë²ˆí˜¸
        let currentEditingChoice = null; // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ì„ íƒì§€ {scene, index}
        let autoSaveTimer = null; // ìë™ ì €ì¥ íƒ€ì´ë¨¸

        // ë²„ì „ íƒ­ ë Œë”ë§
        function renderVersionTabs() {
            const container = document.getElementById('versionTabs');
            let html = '';

            storyVersions.forEach((version, index) => {
                const isActive = index === currentVersionIndex;
                const sceneCount = Object.keys(version.data).filter(k => version.data[k]?.content).length;
                html += `
                    <div style="display: flex; align-items: center; gap: 2px;">
                        <button onclick="switchVersion(${index})" style="
                            padding: 6px 12px;
                            background: ${isActive ? '#007bff' : '#e9ecef'};
                            color: ${isActive ? 'white' : '#333'};
                            border: ${isActive ? '2px solid #0056b3' : '1px solid #ccc'};
                            border-radius: 5px 0 0 5px;
                            cursor: pointer;
                            font-size: 12px;
                            font-weight: ${isActive ? 'bold' : 'normal'};
                        ">${version.name} (${sceneCount}ì”¬)</button>
                        ${storyVersions.length > 1 ? `
                            <button onclick="deleteVersion(${index})" style="
                                padding: 6px 8px;
                                background: ${isActive ? '#dc3545' : '#f8d7da'};
                                color: ${isActive ? 'white' : '#721c24'};
                                border: 1px solid ${isActive ? '#c82333' : '#f5c6cb'};
                                border-radius: 0 5px 5px 0;
                                cursor: pointer;
                                font-size: 10px;
                            ">âœ•</button>
                        ` : `
                            <span style="
                                padding: 6px 8px;
                                background: #e9ecef;
                                color: #aaa;
                                border: 1px solid #ccc;
                                border-radius: 0 5px 5px 0;
                                font-size: 10px;
                            ">âœ•</span>
                        `}
                    </div>`;
            });

            container.innerHTML = html;

            // ë²„ì „ ì¶”ê°€ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
            const addBtn = document.getElementById('addVersionBtn');
            if (storyVersions.length >= MAX_VERSIONS) {
                addBtn.disabled = true;
                addBtn.style.opacity = '0.5';
                addBtn.title = 'ìµœëŒ€ 5ê°œê¹Œì§€ë§Œ ìƒì„± ê°€ëŠ¥í•©ë‹ˆë‹¤';
            } else {
                addBtn.disabled = false;
                addBtn.style.opacity = '1';
                addBtn.title = '';
            }
        }

        // ë²„ì „ ì „í™˜
        function switchVersion(index) {
            if (index < 0 || index >= storyVersions.length) return;

            // í˜„ì¬ ë²„ì „ ì €ì¥
            autoSaveCurrentEdit();
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            // ìƒˆ ë²„ì „ìœ¼ë¡œ ì „í™˜
            currentVersionIndex = index;
            gameData = storyVersions[index].data;
            gameTitle = storyVersions[index].title || "Catch! Love";

            // UI ì—…ë°ì´íŠ¸
            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();

            // ì—ë””í„° ì´ˆê¸°í™”
            document.getElementById('editor').innerHTML = '<div class="empty-state">ì”¬ì„ ì„ íƒí•˜ì„¸ìš”</div>';
            selectedNode = null;
            selectedType = null;
            currentEditingScene = null;
            currentEditingChoice = null;
            updateTestFromCurrentButton();

            updateStatus(`"${storyVersions[index].name}" ë²„ì „ìœ¼ë¡œ ì „í™˜ë¨`);
        }

        // ìƒˆ ë²„ì „ ì¶”ê°€
        function addNewVersion() {
            if (storyVersions.length >= MAX_VERSIONS) {
                alert(`ìµœëŒ€ ${MAX_VERSIONS}ê°œê¹Œì§€ë§Œ ìƒì„± ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                return;
            }

            const name = prompt('ìƒˆ ë²„ì „ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', `ë²„ì „ ${storyVersions.length + 1}`);
            if (!name) return;

            // í˜„ì¬ ë²„ì „ ì €ì¥
            autoSaveCurrentEdit();
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            // ìƒˆ ë²„ì „ ìƒì„± (ë¹ˆ ìŠ¤í† ë¦¬)
            const newVersion = {
                name: name,
                title: "Catch! Love",
                data: { 1: { content: '', isEnding: false, choices: [] } }
            };

            storyVersions.push(newVersion);
            currentVersionIndex = storyVersions.length - 1;
            gameData = newVersion.data;
            gameTitle = newVersion.title;

            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();
            updateStatus(`"${name}" ë²„ì „ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // íŒŒì¼ì„ ìƒˆ ë²„ì „ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¤ê¸°
        function importAsNewVersion() {
            if (storyVersions.length >= MAX_VERSIONS) {
                alert(`ìµœëŒ€ ${MAX_VERSIONS}ê°œê¹Œì§€ë§Œ ìƒì„± ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);

                        // í˜„ì¬ ë²„ì „ ì €ì¥
                        autoSaveCurrentEdit();
                        storyVersions[currentVersionIndex].data = gameData;
                        storyVersions[currentVersionIndex].title = gameTitle;

                        // ìƒˆ ë²„ì „ ìƒì„±
                        const name = prompt('ë²„ì „ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', story.title || `ë²„ì „ ${storyVersions.length + 1}`);
                        if (!name) return;

                        const newVersion = {
                            name: name,
                            title: story.title || "Catch! Love",
                            data: {}
                        };

                        // STORY í˜•ì‹ì„ ì—ë””í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                        if (story.scenes && Array.isArray(story.scenes)) {
                            story.scenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const num = parseInt(match[1]);
                                if (num < 1 || num > 1000) return;

                                newVersion.data[num] = {
                                    content: scene.content || '',
                                    isEnding: scene.isEnding || false,
                                    choices: []
                                };

                                if (!scene.isEnding && scene.choices) {
                                    scene.choices.forEach(choice => {
                                        if (choice.label) {
                                            let nextNum = 0;
                                            if (choice.nextSceneId) {
                                                const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                                if (nextMatch) nextNum = parseInt(nextMatch[1]);
                                            }
                                            newVersion.data[num].choices.push({
                                                text: choice.label,
                                                next: nextNum,
                                                outcome: choice.outcome || 'continue'
                                            });
                                        }
                                    });
                                }
                            });
                        }

                        // ìµœì†Œ ì”¬ 1ì´ë¼ë„ ìˆê²Œ
                        if (!newVersion.data[1]) {
                            newVersion.data[1] = { content: '', isEnding: false, choices: [] };
                        }

                        storyVersions.push(newVersion);
                        currentVersionIndex = storyVersions.length - 1;
                        gameData = newVersion.data;
                        gameTitle = newVersion.title;

                        updateUsedScenes();
                        renderTree();
                        renderVersionTabs();
                        saveAllVersionsToLocal();
                        updateStatus(`"${name}" ë²„ì „ìœ¼ë¡œ íŒŒì¼ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);

                    } catch (err) {
                        alert('JSON íŒŒì‹± ì‹¤íŒ¨: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // í˜„ì¬ ë²„ì „ì— íŒŒì¼ ë‚´ìš© ì´ì–´ë¶™ì´ê¸°
        function appendToCurrentVersion() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);

                        // í˜„ì¬ í¸ì§‘ ë‚´ìš© ì €ì¥
                        autoSaveCurrentEdit();

                        // í˜„ì¬ ë²„ì „ì—ì„œ ì‚¬ìš© ì¤‘ì¸ ìµœëŒ€ ì”¬ ë²ˆí˜¸ ì°¾ê¸°
                        let maxSceneNum = 0;
                        for (let i = 1; i <= 1000; i++) {
                            if (gameData[i] && gameData[i].content) {
                                maxSceneNum = i;
                            }
                        }

                        // ë¶ˆëŸ¬ì˜¨ íŒŒì¼ì˜ ì”¬ ë²ˆí˜¸ ë§¤í•‘ (ê¸°ì¡´ ì”¬ ì´í›„ë¡œ ì´ì–´ë¶™ì´ê¸°)
                        const sceneMapping = {}; // ì›ë˜ ì”¬ ë²ˆí˜¸ -> ìƒˆ ì”¬ ë²ˆí˜¸
                        let importedCount = 0;

                        if (story.scenes && Array.isArray(story.scenes)) {
                            // ë¨¼ì € ì”¬ ë²ˆí˜¸ ë§¤í•‘ ìƒì„±
                            const sortedScenes = [...story.scenes].sort((a, b) => {
                                const numA = parseInt(a.id.match(/S(\d+)/)?.[1] || 0);
                                const numB = parseInt(b.id.match(/S(\d+)/)?.[1] || 0);
                                return numA - numB;
                            });

                            sortedScenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const originalNum = parseInt(match[1]);
                                const newNum = maxSceneNum + originalNum;

                                if (newNum > 1000) return; // 1000 ì´ˆê³¼í•˜ë©´ ìŠ¤í‚µ

                                sceneMapping[originalNum] = newNum;
                            });

                            // ì”¬ ë°ì´í„° ì¶”ê°€
                            sortedScenes.forEach(scene => {
                                const match = scene.id.match(/S(\d+)/);
                                if (!match) return;

                                const originalNum = parseInt(match[1]);
                                const newNum = sceneMapping[originalNum];

                                if (!newNum || newNum > 1000) return;

                                gameData[newNum] = {
                                    content: scene.content || '',
                                    isEnding: scene.isEnding || false,
                                    choices: []
                                };

                                if (!scene.isEnding && scene.choices) {
                                    scene.choices.forEach(choice => {
                                        // label ë˜ëŠ” text ë‘˜ ë‹¤ ì§€ì›
                                        const choiceText = choice.label || choice.text || '';
                                        if (choiceText) {
                                            let nextNum = 0;
                                            // nextSceneId ë˜ëŠ” next ë‘˜ ë‹¤ ì§€ì›
                                            const nextSceneId = choice.nextSceneId || '';
                                            const directNext = choice.next || 0;

                                            if (nextSceneId) {
                                                const nextMatch = nextSceneId.match(/S(\d+)/);
                                                if (nextMatch) {
                                                    const originalNext = parseInt(nextMatch[1]);
                                                    nextNum = sceneMapping[originalNext] || 0;
                                                }
                                            } else if (directNext > 0) {
                                                // ì§ì ‘ ìˆ«ìë¡œ ëœ nextë„ ë§¤í•‘
                                                nextNum = sceneMapping[directNext] || 0;
                                            }

                                            gameData[newNum].choices.push({
                                                text: choiceText,
                                                next: nextNum,
                                                outcome: choice.outcome || 'continue'
                                            });
                                        }
                                    });
                                }

                                importedCount++;
                            });
                        }

                        // ë²„ì „ ë°ì´í„° ë™ê¸°í™”
                        storyVersions[currentVersionIndex].data = gameData;

                        updateUsedScenes();
                        renderTree();
                        renderVersionTabs();
                        saveAllVersionsToLocal();
                        updateStatus(`${importedCount}ê°œ ì”¬ì„ í˜„ì¬ ë²„ì „ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤. (ì”¬ ${maxSceneNum + 1}ë¶€í„°)`);

                    } catch (err) {
                        alert('JSON íŒŒì‹± ì‹¤íŒ¨: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ë²„ì „ ì‚­ì œ
        function deleteVersion(index) {
            if (storyVersions.length <= 1) {
                alert('ìµœì†Œ 1ê°œì˜ ë²„ì „ì€ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }

            const version = storyVersions[index];
            if (!confirm(`"${version.name}" ë²„ì „ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nëª¨ë“  ì”¬ì´ ì‚­ì œë©ë‹ˆë‹¤.`)) {
                return;
            }

            storyVersions.splice(index, 1);

            // í˜„ì¬ ë²„ì „ì´ ì‚­ì œë˜ì—ˆê±°ë‚˜ ì¸ë±ìŠ¤ ì¡°ì • í•„ìš”
            if (currentVersionIndex >= storyVersions.length) {
                currentVersionIndex = storyVersions.length - 1;
            } else if (currentVersionIndex > index) {
                currentVersionIndex--;
            }

            // í˜„ì¬ ë²„ì „ ë°ì´í„° ë¡œë“œ
            gameData = storyVersions[currentVersionIndex].data;
            gameTitle = storyVersions[currentVersionIndex].title || "Catch! Love";

            updateUsedScenes();
            renderTree();
            renderVersionTabs();
            saveAllVersionsToLocal();
            updateStatus(`ë²„ì „ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // ëª¨ë“  ë²„ì „ì„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        function saveAllVersionsToLocal() {
            // í˜„ì¬ ë²„ì „ ë°ì´í„° ë™ê¸°í™”
            storyVersions[currentVersionIndex].data = gameData;
            storyVersions[currentVersionIndex].title = gameTitle;

            localStorage.setItem('gameTreeVersions', JSON.stringify({
                versions: storyVersions,
                currentIndex: currentVersionIndex
            }));
        }

        // ëª¨ë“  ë²„ì „ì„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
        function loadAllVersionsFromLocal() {
            const saved = localStorage.getItem('gameTreeVersions');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    storyVersions = data.versions || [];
                    currentVersionIndex = data.currentIndex || 0;

                    if (storyVersions.length === 0) {
                        initDefaultVersion();
                    } else {
                        // ì¸ë±ìŠ¤ ìœ íš¨ì„± ê²€ì‚¬
                        if (currentVersionIndex >= storyVersions.length) {
                            currentVersionIndex = 0;
                        }
                        gameData = storyVersions[currentVersionIndex].data;
                        gameTitle = storyVersions[currentVersionIndex].title || "Catch! Love";
                    }
                    return true;
                } catch (e) {
                    console.error('ë²„ì „ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', e);
                }
            }
            return false;
        }

        // ê¸°ë³¸ ë²„ì „ ì´ˆê¸°í™”
        function initDefaultVersion() {
            storyVersions = [{
                name: 'ë²„ì „ 1',
                title: 'Catch! Love',
                data: { 1: { content: '', isEnding: false, choices: [] } }
            }];
            currentVersionIndex = 0;
            gameData = storyVersions[0].data;
            gameTitle = storyVersions[0].title;
        }

        // í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ê´€ë ¨ ë³€ìˆ˜
        let testCurrentScene = 1;
        let testPathHistory = []; // í‘œì‹œìš© ê²½ë¡œ
        let testSceneStack = []; // ë’¤ë¡œê°€ê¸°ìš© ì”¬ ìŠ¤íƒ

        // í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ì‹œì‘ (ì”¬ 1ë¶€í„°)
        function startTestPlay() {
            // í˜„ì¬ í¸ì§‘ ë‚´ìš© ì €ì¥
            autoSaveCurrentEdit();

            // ì”¬ 1ì´ ìˆëŠ”ì§€ í™•ì¸
            if (!gameData[1] || !gameData[1].content) {
                alert('ì”¬ 1ì— ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            testCurrentScene = 1;
            testPathHistory = [];
            testSceneStack = [];
            document.getElementById('testPlayModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            showTestScene(1, false);
        }

        // í˜„ì¬ ì„ íƒëœ ì”¬ë¶€í„° í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ì‹œì‘
        function startTestPlayFromCurrent() {
            // í˜„ì¬ í¸ì§‘ ë‚´ìš© ì €ì¥
            autoSaveCurrentEdit();

            const startScene = currentEditingScene || 1;

            // ì„ íƒëœ ì”¬ì´ ìˆëŠ”ì§€ í™•ì¸
            if (!gameData[startScene] || !gameData[startScene].content) {
                alert(`ì”¬ ${startScene}ì— ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.`);
                return;
            }

            testCurrentScene = startScene;
            testPathHistory = [];
            testSceneStack = [];
            document.getElementById('testPlayModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            showTestScene(startScene, false);
        }

        // "í˜„ì¬ ì”¬" í…ŒìŠ¤íŠ¸ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
        function updateTestFromCurrentButton() {
            const btn = document.getElementById('testFromCurrentBtn');
            if (currentEditingScene && currentEditingScene !== 1) {
                btn.style.display = 'inline-block';
                btn.textContent = `â–¶ï¸ ì”¬ ${currentEditingScene}ë¶€í„°`;
            } else {
                btn.style.display = 'none';
            }
        }

        // í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ë‹«ê¸°
        function closeTestPlay() {
            document.getElementById('testPlayModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        // í…ŒìŠ¤íŠ¸ í”Œë ˆì´ ì¬ì‹œì‘
        function restartTestPlay() {
            testCurrentScene = 1;
            testPathHistory = [];
            testSceneStack = [];
            showTestScene(1, false);
        }

        // ì´ì „ ì”¬ìœ¼ë¡œ ëŒì•„ê°€ê¸°
        function goBackTestPlay() {
            if (testSceneStack.length > 0) {
                // í˜„ì¬ ì”¬ì—ì„œ ì¶”ê°€ëœ ê²½ë¡œ ì œê±° (ì”¬ + ì„ íƒ)
                if (testPathHistory.length > 0) testPathHistory.pop(); // ì„ íƒ ì œê±°
                if (testPathHistory.length > 0) testPathHistory.pop(); // ì”¬ ì œê±°

                const prevScene = testSceneStack.pop();
                showTestScene(prevScene, false);
            }
        }

        // ë’¤ë¡œê°€ê¸° ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
        function updateBackButton() {
            const backBtn = document.getElementById('testBackBtn');
            if (testSceneStack.length > 0) {
                backBtn.style.display = 'inline-block';
            } else {
                backBtn.style.display = 'none';
            }
        }

        // í…ŒìŠ¤íŠ¸ ì”¬ í‘œì‹œ
        function showTestScene(sceneNum, addToStack = true) {
            const scene = gameData[sceneNum];

            // ìŠ¤íƒì— í˜„ì¬ ì”¬ ì €ì¥ (ë’¤ë¡œê°€ê¸°ìš©)
            if (addToStack && testCurrentScene !== sceneNum) {
                testSceneStack.push(testCurrentScene);
            }

            testCurrentScene = sceneNum;

            // ê²½ë¡œ ê¸°ë¡
            testPathHistory.push(`ì”¬ ${sceneNum}`);
            document.getElementById('testPathHistory').textContent = testPathHistory.join(' â†’ ');

            // ì”¬ ë²ˆí˜¸ í‘œì‹œ
            document.getElementById('testSceneNumber').textContent = `ğŸ“ ì”¬ ${sceneNum}`;

            // ë’¤ë¡œê°€ê¸° ë²„íŠ¼ ì—…ë°ì´íŠ¸
            updateBackButton();

            if (!scene || !scene.content) {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="color: #dc3545; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 15px;">âš ï¸</div>
                        <div style="font-size: 18px; font-weight: bold;">ì”¬ ${sceneNum}ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div>
                        <div style="color: #666; margin-top: 10px;">ì—ë””í„°ì—ì„œ ì´ ì”¬ì˜ ë‚´ìš©ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.</div>
                    </div>`;
                document.getElementById('testChoices').innerHTML = '';
                return;
            }

            // ì”¬ ë‚´ìš© í‘œì‹œ
            document.getElementById('testSceneContent').textContent = scene.content;

            // ì„ íƒì§€ ë˜ëŠ” ì—”ë”© í‘œì‹œ
            const choicesDiv = document.getElementById('testChoices');

            if (scene.isEnding) {
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 30px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px;">
                        <div style="font-size: 48px; margin-bottom: 15px;">ğŸ‰</div>
                        <div style="font-size: 24px; color: white; font-weight: bold;">~ THE END ~</div>
                        <div style="color: rgba(255,255,255,0.9); margin-top: 10px;">ì—”ë”©ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!</div>
                    </div>`;
            } else if (scene.choices && scene.choices.length > 0) {
                let choicesHTML = '';
                scene.choices.forEach((choice, index) => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';
                        let btnColor = '#007bff';
                        let outcomeLabel = '';

                        if (outcome === 'success') {
                            btnColor = '#28a745';
                            outcomeLabel = ' ğŸ‰';
                        } else if (outcome === 'failure') {
                            btnColor = '#dc3545';
                            outcomeLabel = ' ğŸ’”';
                        }

                        choicesHTML += `
                            <button onclick="selectTestChoice(${sceneNum}, ${index})" style="
                                padding: 15px 20px;
                                background: ${btnColor};
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-size: 15px;
                                cursor: pointer;
                                text-align: left;
                                transition: all 0.3s;
                            " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
                                ${index + 1}. ${choice.text}${outcomeLabel}
                            </button>`;
                    }
                });

                if (choicesHTML === '') {
                    choicesHTML = `<div style="color: white; text-align: center; padding: 20px;">ì„ íƒì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ì—ë””í„°ì—ì„œ ì„ íƒì§€ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>`;
                }

                choicesDiv.innerHTML = choicesHTML;
            } else {
                choicesDiv.innerHTML = `<div style="color: white; text-align: center; padding: 20px;">ì„ íƒì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ì—ë””í„°ì—ì„œ ì„ íƒì§€ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>`;
            }
        }

        // í…ŒìŠ¤íŠ¸ ì„ íƒì§€ ì„ íƒ
        function selectTestChoice(sceneNum, choiceIndex) {
            const choice = gameData[sceneNum].choices[choiceIndex];
            if (!choice) return;

            const outcome = choice.outcome || 'continue';

            // ê²½ë¡œì— ì„ íƒ ê¸°ë¡
            testPathHistory.push(`"${choice.text.substring(0, 15)}${choice.text.length > 15 ? '...' : ''}"`);

            if (outcome === 'success') {
                showTestEnding('success');
            } else if (outcome === 'failure') {
                showTestEnding('failure');
            } else if (choice.next && choice.next > 0) {
                showTestScene(choice.next);
            } else {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="color: #ffc107; text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 15px;">âš ï¸</div>
                        <div style="font-size: 18px; font-weight: bold;">ë‹¤ìŒ ì”¬ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤</div>
                        <div style="color: #666; margin-top: 10px;">ì—ë””í„°ì—ì„œ ì´ ì„ íƒì§€ì˜ ë‹¤ìŒ ì”¬ ë²ˆí˜¸ë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.</div>
                    </div>`;
                document.getElementById('testChoices').innerHTML = '';
            }
        }

        // í…ŒìŠ¤íŠ¸ ì—”ë”© í‘œì‹œ
        function showTestEnding(type) {
            document.getElementById('testPathHistory').textContent = testPathHistory.join(' â†’ ');

            const choicesDiv = document.getElementById('testChoices');

            if (type === 'success') {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">ğŸ’•</div>
                        <div style="font-size: 28px; color: #e91e63; font-weight: bold;">SUCCESS!</div>
                        <div style="color: #666; margin-top: 15px; font-size: 16px;">ì¶•í•˜í•©ë‹ˆë‹¤! ì„±ê³µ ì—”ë”©ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤.</div>
                    </div>`;
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border-radius: 10px;">
                        <div style="font-size: 20px; color: white; font-weight: bold;">ğŸ‰ THE END ğŸ‰</div>
                    </div>`;
            } else {
                document.getElementById('testSceneContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">ğŸ’”</div>
                        <div style="font-size: 28px; color: #607d8b; font-weight: bold;">MAYBE NEXT TIME...</div>
                        <div style="color: #666; margin-top: 15px; font-size: 16px;">ë‹¤ë¥¸ ì„ íƒì„ í•´ë³´ì„¸ìš”.</div>
                    </div>`;
                choicesDiv.innerHTML = `
                    <div style="text-align: center; padding: 20px; background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); border-radius: 10px;">
                        <div style="font-size: 20px; color: #455a64; font-weight: bold;">~ THE END ~</div>
                    </div>`;
            }
        }

        // ëª¨ë°”ì¼ ê°ì§€ ë° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        window.addEventListener('resize', () => {
            isMobile = window.innerWidth <= 768;
        });

        // íŒ¨ë„ ë¦¬ì‚¬ì´ì € ê¸°ëŠ¥
        function initResizer() {
            const resizer = document.getElementById('resizer');
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            let isResizing = false;

            resizer.addEventListener('mousedown', function(e) {
                if (isMobile) return;
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing || isMobile) return;

                const container = document.querySelector('.main-content');
                const containerRect = container.getBoundingClientRect();
                const newWidth = e.clientX - containerRect.left;
                const minWidth = 250;
                const maxWidth = containerRect.width - 300;

                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    const percentage = (newWidth / containerRect.width) * 100;
                    treePanel.style.width = percentage + '%';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // íƒ­ ì „í™˜ (ëª¨ë°”ì¼)
        function switchTab(tab) {
            if (!isMobile) return;
            
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            const tabBtns = document.querySelectorAll('.tab-btn');
            
            tabBtns.forEach(btn => btn.classList.remove('active'));
            
            if (tab === 'tree') {
                treePanel.classList.add('active');
                editorPanel.classList.remove('active');
                tabBtns[0].classList.add('active');
            } else {
                treePanel.classList.remove('active');
                editorPanel.classList.add('active');
                tabBtns[1].classList.add('active');
            }
        }

        // ì´ˆê¸°í™”
        function init() {
            for (let i = 1; i <= 1000; i++) {
                gameData[i] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }
            gameData[1].content = 'ê²Œì„ ì‹œì‘';
            updateUsedScenes();
            renderTree();
        }

        // ì‚¬ìš©ëœ ì”¬ ì—…ë°ì´íŠ¸
        function updateUsedScenes() {
            usedSceneNumbers.clear();
            usedSceneNumbers.add(1);
            
            function traverse(sceneNum) {
                const scene = gameData[sceneNum];
                if (!scene) return;
                
                scene.choices.forEach(choice => {
                    if (choice.next && choice.next > 0 && choice.next <= 1000) {
                        if (!usedSceneNumbers.has(choice.next)) {
                            usedSceneNumbers.add(choice.next);
                            traverse(choice.next);
                        }
                    }
                });
            }
            
            traverse(1);
            
            for (let i = 1; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim()) {
                    usedSceneNumbers.add(i);
                }
            }
            
            updateStats();
        }

        // ë‹¤ìŒ ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ ì°¾ê¸°
        function getNextAvailableScene() {
            for (let i = 2; i <= 1000; i++) {
                if (!usedSceneNumbers.has(i)) {
                    return i;
                }
            }
            return 0;
        }

        // ìƒˆ ì”¬ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸
        function showAddSceneDialog() {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            const nextScene = getNextAvailableScene();
            if (nextScene === 0) {
                alert('ë” ì´ìƒ ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const sceneNum = prompt(`ìƒˆ ì”¬ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì¶”ì²œ: ${nextScene})`, nextScene);
            if (sceneNum === null) return;

            const num = parseInt(sceneNum);
            if (isNaN(num) || num < 1 || num > 1000) {
                alert('1~1000 ì‚¬ì´ì˜ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            if (usedSceneNumbers.has(num)) {
                if (!confirm(`ì”¬ ${num}ì€(ëŠ”) ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. ìˆ˜ì •í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    return;
                }
            }

            // ìƒˆ ì”¬ ìƒì„± ë˜ëŠ” ìˆ˜ì •
            if (!gameData[num]) {
                gameData[num] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }

            selectScene(num);
            updateUsedScenes();
            renderTree();
            updateStatus(`ì”¬ ${num} ì¤€ë¹„ë¨`);
        }

        // ì „ì²´ ì”¬ ëª©ë¡ ë³´ê¸°
        function showAllScenes() {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì „ì²´ ì”¬ ëª©ë¡ (${sceneList.length}ê°œ)</h3>
                </div>

                <div class="editor-section">
                    <div style="display: grid; gap: 8px; max-height: 500px; overflow-y: auto;">`;

            sceneList.forEach(num => {
                const scene = gameData[num];
                const preview = scene.content ? scene.content.substring(0, 30) : '(ë‚´ìš© ì—†ìŒ)';
                const endingBadge = scene.isEnding ? '<span style="color: #dc3545; font-weight: bold;"> [END]</span>' : '';
                const choicesInfo = !scene.isEnding ? ` (ì„ íƒì§€: ${scene.choices.length})` : '';

                html += `
                    <div style="
                        padding: 12px;
                        background: ${num === 1 ? '#e3f2fd' : 'white'};
                        border: 2px solid ${scene.isEnding ? '#dc3545' : '#007bff'};
                        border-radius: 5px;
                        cursor: pointer;
                        transition: all 0.2s;
                    " onclick="selectScene(${num})"
                       onmouseover="this.style.background='#f0f0f0'"
                       onmouseout="this.style.background='${num === 1 ? '#e3f2fd' : 'white'}'">
                        <div style="font-weight: bold; margin-bottom: 5px;">
                            ì”¬ ${num}${endingBadge}${choicesInfo}
                        </div>
                        <div style="color: #666; font-size: 13px;">
                            ${preview}${scene.content && scene.content.length > 30 ? '...' : ''}
                        </div>
                    </div>`;
            });

            html += `
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-info" onclick="renderTree(); document.getElementById('editor').innerHTML='<div class=\\'empty-state\\'>íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>'">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>
                </div>`;

            document.getElementById('editor').innerHTML = html;

            if (isMobile) {
                switchTab('editor');
            }
        }

        // íŠ¸ë¦¬ ë Œë”ë§
        function renderTree() {
            const treeDiv = document.getElementById('tree');
            const connectedScenes = new Set();

            // ë©”ì¸ íŠ¸ë¦¬ (ì”¬ 1ë¶€í„° ì—°ê²°ëœ ì”¬ë“¤)
            let html = buildTreeHTML(1, new Set(), connectedScenes);

            // ì—°ê²°ë˜ì§€ ì•Šì€ ì”¬ë“¤ (ê³ ì•„ ì”¬) ì°¾ê¸°
            const orphanScenes = [];
            for (let i = 2; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim() && !connectedScenes.has(i)) {
                    orphanScenes.push(i);
                }
            }

            // ê³ ì•„ ì”¬ë“¤ í‘œì‹œ
            if (orphanScenes.length > 0) {
                html += `<div style="margin-top: 20px; padding-top: 15px; border-top: 2px dashed #ffc107;">
                    <div style="color: #856404; font-weight: bold; margin-bottom: 10px; font-size: 13px;">
                        âš ï¸ ì—°ê²°ë˜ì§€ ì•Šì€ ì”¬ (${orphanScenes.length}ê°œ)
                    </div>`;
                orphanScenes.forEach(num => {
                    // ì´ë¯¸ ë Œë”ë§ëœ ì”¬ì€ ê±´ë„ˆë›°ë„ë¡ connectedScenesë¥¼ visitedë¡œ ì „ë‹¬
                    html += buildTreeHTML(num, new Set(connectedScenes), connectedScenes);
                });
                html += '</div>';
            }

            treeDiv.innerHTML = html;
        }

        // íŠ¸ë¦¬ HTML ìƒì„±
        function buildTreeHTML(sceneNum, visited, connectedScenes = null) {
            if (visited.has(sceneNum)) {
                return `<li><span class="scene-node empty">ì”¬ ${sceneNum} (ìˆœí™˜)</span></li>`;
            }

            visited.add(sceneNum);
            if (connectedScenes) connectedScenes.add(sceneNum);
            const scene = gameData[sceneNum];

            // ì”¬ì´ ì—†ìœ¼ë©´ ë¹ˆ ë…¸ë“œ í‘œì‹œ
            if (!scene) {
                return `<ul><li><span class="scene-node empty" onclick="selectScene(${sceneNum})">ğŸ“„ ì”¬ ${sceneNum}: (ì—†ìŒ)</span></li></ul>`;
            }

            const hasContent = scene.content && scene.content.trim();
            const nodeClass = `scene-node ${hasContent ? '' : 'empty'} ${scene.isEnding ? 'ending' : ''} ${selectedNode === sceneNum && selectedType === 'scene' ? 'selected' : ''}`;
            
            let html = '<ul><li>';
            html += `<span class="${nodeClass}" onclick="selectScene(${sceneNum})">`;
            html += `ğŸ“„ ì”¬ ${sceneNum}`;
            if (hasContent) {
                const preview = scene.content.substring(0, 12);
                html += `: ${preview}${scene.content.length > 12 ? '...' : ''}`;
            }
            if (scene.isEnding) {
                html += ' [END]';
            }
            html += '</span>';
            
            if (!scene.isEnding && scene.choices.length > 0) {
                html += '<ul>';
                scene.choices.forEach((choice, index) => {
                    const choiceClass = `choice-node ${choice.text ? '' : 'empty'} ${selectedNode === `${sceneNum}-${index}` && selectedType === 'choice' ? 'selected' : ''}`;
                    html += '<li>';
                    html += `<span class="${choiceClass}" onclick="selectChoice(${sceneNum}, ${index})">`;
                    html += `â–¶ ${index + 1}. ${choice.text ? choice.text.substring(0, 15) + (choice.text.length > 15 ? '...' : '') : '(ë¹ˆ ì„ íƒì§€)'}`;
                    if (choice.next) {
                        html += ` â†’ ${choice.next}`;
                    }
                    html += '</span>';
                    
                    if (choice.next && choice.next > 0) {
                        html += buildTreeHTML(choice.next, new Set([...visited]), connectedScenes);
                    }
                    
                    html += '</li>';
                });
                html += '</ul>';
            }
            
            html += '</li></ul>';
            
            return html;
        }

        // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ë‚´ìš© ìë™ ì €ì¥
        function autoSaveCurrentEdit() {
            // ì”¬ í¸ì§‘ ì¤‘ì´ë©´ ì €ì¥
            if (currentEditingScene !== null && selectedType === 'scene') {
                const contentEl = document.getElementById('sceneContent');
                const isEndingEl = document.getElementById('isEnding');

                if (contentEl) {
                    gameData[currentEditingScene].content = contentEl.value;
                }
                if (isEndingEl) {
                    gameData[currentEditingScene].isEnding = isEndingEl.checked;
                }

                // ì„ íƒì§€ë“¤ë„ ì €ì¥
                if (!gameData[currentEditingScene].isEnding) {
                    gameData[currentEditingScene].choices.forEach((choice, index) => {
                        const textInput = document.getElementById(`choice-text-${index}`);
                        const nextInput = document.getElementById(`choice-next-${index}`);
                        const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                        if (textInput) choice.text = textInput.value;
                        if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                        if (outcomeInput) choice.outcome = outcomeInput.value;
                    });
                }

                saveToLocal();
            }

            // ì„ íƒì§€ í¸ì§‘ ì¤‘ì´ë©´ ì €ì¥
            if (currentEditingChoice !== null && selectedType === 'choice') {
                const textEl = document.getElementById('choiceText');
                const outcomeEl = document.getElementById('choiceOutcome');
                const nextEl = document.getElementById('choiceNext');

                if (textEl && gameData[currentEditingChoice.scene]?.choices[currentEditingChoice.index]) {
                    const choice = gameData[currentEditingChoice.scene].choices[currentEditingChoice.index];
                    choice.text = textEl.value;
                    if (outcomeEl) choice.outcome = outcomeEl.value;
                    if (nextEl && choice.outcome === 'continue') {
                        choice.next = parseInt(nextEl.value) || 0;
                    }
                    saveToLocal();
                }
            }
        }

        // ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œì‘ (5ì´ˆë§ˆë‹¤)
        function startAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            autoSaveTimer = setInterval(() => {
                autoSaveCurrentEdit();
                updateStatus('ìë™ ì €ì¥ë¨');
            }, 5000);
        }

        // ì”¬ ì„ íƒ
        function selectScene(sceneNum) {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            selectedNode = sceneNum;
            selectedType = 'scene';
            currentEditingScene = sceneNum;
            currentEditingChoice = null;

            renderTree();
            showSceneEditor(sceneNum);

            // "í˜„ì¬ ì”¬ë¶€í„° í…ŒìŠ¤íŠ¸" ë²„íŠ¼ ì—…ë°ì´íŠ¸
            updateTestFromCurrentButton();

            // ëª¨ë°”ì¼ì—ì„œëŠ” ìë™ìœ¼ë¡œ í¸ì§‘ íƒ­ìœ¼ë¡œ ì „í™˜
            if (isMobile) {
                switchTab('editor');
            }
        }

        // ì„ íƒì§€ ì„ íƒ
        function selectChoice(sceneNum, choiceIndex) {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            selectedNode = `${sceneNum}-${choiceIndex}`;
            selectedType = 'choice';
            currentEditingScene = null;
            currentEditingChoice = { scene: sceneNum, index: choiceIndex };

            renderTree();
            showChoiceEditor(sceneNum, choiceIndex);

            if (isMobile) {
                switchTab('editor');
            }
        }

        // ì”¬ ì—ë””í„°
        function showSceneEditor(sceneNum) {
            const scene = gameData[sceneNum];
            const editor = document.getElementById('editor');
            
            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì”¬ ${sceneNum}</h3>
                </div>
                
                <div class="editor-section">
                    <div class="editor-label">ì”¬ ë‚´ìš©</div>
                    <textarea class="editor-textarea" id="sceneContent" 
                              placeholder="ì´ ì”¬ì˜ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”...">${scene.content}</textarea>
                </div>
                
                <div class="editor-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="isEnding" ${scene.isEnding ? 'checked' : ''} 
                               onchange="toggleEnding(${sceneNum})">
                        <span>ì—”ë”© ì”¬ìœ¼ë¡œ ì„¤ì •</span>
                    </label>
                </div>
                
                <div class="editor-section" id="choicesSection" ${scene.isEnding ? 'style="display:none"' : ''}>
                    <div class="editor-label">ì„ íƒì§€ (${scene.choices.length}/3)</div>`;
            
            scene.choices.forEach((choice, index) => {
                const outcomeValue = choice.outcome || 'continue';
                html += `
                    <div class="choice-container">
                        <div class="choice-header">
                            <span class="choice-number">ì„ íƒì§€ ${index + 1}</span>
                            <button class="delete-btn" onclick="deleteChoice(${sceneNum}, ${index})">ì‚­ì œ</button>
                        </div>
                        <input type="text" class="editor-input" id="choice-text-${index}"
                               placeholder="ì„ íƒì§€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." value="${choice.text}">
                        <div class="next-scene-control">
                            <select class="editor-input" id="choice-outcome-${index}" style="width: auto; min-width: 120px;">
                                <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>ë‹¤ìŒ ì”¬ìœ¼ë¡œ</option>
                                <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ì„±ê³µ ì—”ë”©</option>
                                <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>ì‹¤íŒ¨ ì—”ë”©</option>
                            </select>
                            <input type="number" class="next-scene-input" id="choice-next-${index}"
                                   min="1" max="1000" value="${choice.next || ''}"
                                   placeholder="ë‹¤ìŒ ì”¬" ${outcomeValue !== 'continue' ? 'disabled' : ''}>
                            <button class="auto-btn" onclick="autoAssignNext(${sceneNum}, ${index})" ${outcomeValue !== 'continue' ? 'disabled' : ''}>ìë™</button>
                            ${choice.next && choice.next > 0 && outcomeValue === 'continue' ? `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${choice.next})">â†’ ì”¬ ${choice.next}</button>` : ''}
                        </div>
                    </div>`;
            });
            
            if (scene.choices.length < 3 && !scene.isEnding) {
                html += `<button class="add-choice-btn" onclick="addChoice(${sceneNum})">+ ì„ íƒì§€ ì¶”ê°€</button>`;
            }
            
            html += `</div>`;

            // ë°”ë¡œê°€ê¸° ì„¹ì…˜ ì¶”ê°€
            const parentScenes = findParentScenes(sceneNum);
            const childScenes = scene.choices.filter(c => c.next && c.next > 0 && (c.outcome || 'continue') === 'continue').map(c => c.next);

            if (parentScenes.length > 0 || childScenes.length > 0) {
                html += `<div class="editor-section">
                    <div class="editor-label">ğŸ”— ë°”ë¡œê°€ê¸°</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">`;

                parentScenes.forEach(p => {
                    html += `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${p.scene})">â† ì”¬ ${p.scene} (ì„ íƒì§€ ${p.choiceIdx + 1})</button>`;
                });

                childScenes.forEach(nextScene => {
                    html += `<button class="auto-btn" style="background: #17a2b8;" onclick="selectScene(${nextScene})">â†’ ì”¬ ${nextScene}</button>`;
                });

                html += `</div></div>`;
            }

            html += `
                <div class="editor-controls">
                    <button class="btn-success" onclick="saveScene(${sceneNum})">ì €ì¥</button>
                    ${sceneNum !== 1 ? `<button class="btn-danger" onclick="deleteScene(${sceneNum})">ì”¬ ì‚­ì œ</button>` : ''}
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>` : ''}
                </div>`;

            editor.innerHTML = html;
        }

        // íŠ¹ì • ì”¬ì„ ì—°ê²°í•˜ëŠ” ë¶€ëª¨ ì”¬ë“¤ ì°¾ê¸°
        function findParentScenes(targetScene) {
            const parents = [];
            Object.keys(gameData).forEach(key => {
                const sceneNum = parseInt(key);
                const scene = gameData[sceneNum];
                if (scene && scene.choices) {
                    scene.choices.forEach((choice, idx) => {
                        if (choice.next === targetScene && (choice.outcome || 'continue') === 'continue') {
                            parents.push({ scene: sceneNum, choiceIdx: idx });
                        }
                    });
                }
            });
            return parents;
        }

        // ì„ íƒì§€ ì—ë””í„°
        function showChoiceEditor(sceneNum, choiceIndex) {
            const choice = gameData[sceneNum].choices[choiceIndex];
            const editor = document.getElementById('editor');
            const outcomeValue = choice.outcome || 'continue';

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì”¬ ${sceneNum} - ì„ íƒì§€ ${choiceIndex + 1}</h3>
                </div>

                <div class="editor-section">
                    <div class="editor-label">ì„ íƒì§€ í…ìŠ¤íŠ¸</div>
                    <input type="text" class="editor-input" id="choiceText"
                           placeholder="ì„ íƒì§€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." value="${choice.text || ''}">
                </div>

                <div class="editor-section">
                    <div class="editor-label">ê²°ê³¼ ìœ í˜•</div>
                    <select class="editor-input" id="choiceOutcome" onchange="toggleNextSceneInput()">
                        <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</option>
                        <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ì„±ê³µ ì—”ë”©</option>
                        <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>ì‹¤íŒ¨ ì—”ë”©</option>
                    </select>
                </div>

                <div class="editor-section" id="nextSceneSection" ${outcomeValue !== 'continue' ? 'style="display:none"' : ''}>
                    <div class="editor-label">ë‹¤ìŒ ì”¬ ë²ˆí˜¸</div>
                    <div class="next-scene-control">
                        <input type="number" class="editor-input" id="choiceNext"
                               min="1" max="1000" value="${choice.next || ''}"
                               placeholder="1-1000">
                        <button class="auto-btn" onclick="autoAssignNextForChoice(${sceneNum}, ${choiceIndex})">ìë™ ì±„ë²ˆ</button>
                        ${choice.next && choice.next > 0 ? `<button class="auto-btn" style="background: #6c757d;" onclick="selectScene(${choice.next})">â†’ ì”¬ ${choice.next} í¸ì§‘</button>` : ''}
                    </div>
                </div>

                <div class="editor-section">
                    <div class="editor-label">ë°”ë¡œê°€ê¸°</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="auto-btn" style="background: #007bff;" onclick="selectScene(${sceneNum})">â† ì”¬ ${sceneNum}ìœ¼ë¡œ</button>
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-success" onclick="saveChoice(${sceneNum}, ${choiceIndex})">ì €ì¥</button>
                    <button class="btn-danger" onclick="deleteChoice(${sceneNum}, ${choiceIndex})">ì‚­ì œ</button>
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>` : ''}
                </div>`;

            editor.innerHTML = html;
        }

        // ë‹¤ìŒ ì”¬ ì…ë ¥ì°½ í† ê¸€
        function toggleNextSceneInput() {
            const outcome = document.getElementById('choiceOutcome').value;
            const section = document.getElementById('nextSceneSection');
            if (section) {
                section.style.display = outcome === 'continue' ? 'block' : 'none';
            }
        }

        // ì—”ë”© í† ê¸€
        function toggleEnding(sceneNum) {
            const isEnding = document.getElementById('isEnding').checked;
            gameData[sceneNum].isEnding = isEnding;
            
            const choicesSection = document.getElementById('choicesSection');
            if (isEnding) {
                choicesSection.style.display = 'none';
                gameData[sceneNum].choices = [];
            } else {
                choicesSection.style.display = 'block';
            }
            
            updateUsedScenes();
            renderTree();
        }

        // ìë™ ì±„ë²ˆ (í˜„ì¬ í™”ë©´ì˜ ì…ë ¥ê°’ë„ ê³ ë ¤)
        function autoAssignNext(sceneNum, choiceIndex) {
            // í˜„ì¬ í™”ë©´ì— ì´ë¯¸ ì…ë ¥ëœ ë‹¤ìŒ ì”¬ ë²ˆí˜¸ë“¤ ìˆ˜ì§‘
            const usedInCurrentForm = new Set();
            const scene = gameData[sceneNum];
            if (scene && scene.choices) {
                scene.choices.forEach((choice, idx) => {
                    // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ì„ íƒì§€ê°€ ì•„ë‹Œ ê²½ìš°, ì…ë ¥ í•„ë“œì—ì„œ ê°’ í™•ì¸
                    const inputEl = document.getElementById(`choice-next-${idx}`);
                    if (inputEl && inputEl.value) {
                        usedInCurrentForm.add(parseInt(inputEl.value));
                    }
                });
            }

            const nextScene = getNextAvailableSceneExcluding(usedInCurrentForm);
            if (nextScene > 0) {
                document.getElementById(`choice-next-${choiceIndex}`).value = nextScene;
                updateStatus(`ì”¬ ${nextScene} ìë™ í• ë‹¹`);
            } else {
                alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        function autoAssignNextForChoice(sceneNum, choiceIndex) {
            // ê°™ì€ ì”¬ì˜ ë‹¤ë¥¸ ì„ íƒì§€ì—ì„œ ì‚¬ìš© ì¤‘ì¸ ë²ˆí˜¸ ìˆ˜ì§‘
            const usedInCurrentScene = new Set();
            const scene = gameData[sceneNum];
            if (scene && scene.choices) {
                scene.choices.forEach((choice, idx) => {
                    if (idx !== choiceIndex && choice.next > 0) {
                        usedInCurrentScene.add(choice.next);
                    }
                });
            }

            const nextScene = getNextAvailableSceneExcluding(usedInCurrentScene);
            if (nextScene > 0) {
                document.getElementById('choiceNext').value = nextScene;
                updateStatus(`ì”¬ ${nextScene} ìë™ í• ë‹¹`);
            } else {
                alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        // íŠ¹ì • ë²ˆí˜¸ë“¤ì„ ì œì™¸í•˜ê³  ë‹¤ìŒ ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ ì°¾ê¸°
        function getNextAvailableSceneExcluding(excludeSet) {
            for (let i = 2; i <= 1000; i++) {
                if (!usedSceneNumbers.has(i) && !excludeSet.has(i)) {
                    return i;
                }
            }
            return 0;
        }

        // ì”¬ ì €ì¥
        function saveScene(sceneNum) {
            const content = document.getElementById('sceneContent').value;
            const isEnding = document.getElementById('isEnding').checked;
            
            gameData[sceneNum].content = content;
            gameData[sceneNum].isEnding = isEnding;
            
            if (!isEnding) {
                gameData[sceneNum].choices.forEach((choice, index) => {
                    const textInput = document.getElementById(`choice-text-${index}`);
                    const nextInput = document.getElementById(`choice-next-${index}`);
                    const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                    if (textInput) choice.text = textInput.value;
                    if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                    if (outcomeInput) choice.outcome = outcomeInput.value;
                });
            }
            
            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('ì”¬ ' + sceneNum + ' ì €ì¥ë¨');
            
            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ì„ íƒì§€ ì €ì¥
        function saveChoice(sceneNum, choiceIndex) {
            const text = document.getElementById('choiceText').value;
            const outcomeEl = document.getElementById('choiceOutcome');
            const nextEl = document.getElementById('choiceNext');

            const outcome = outcomeEl ? outcomeEl.value : 'continue';
            const next = outcome === 'continue' ? (parseInt(nextEl?.value) || 0) : 0;

            gameData[sceneNum].choices[choiceIndex] = { text, next, outcome };

            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('ì„ íƒì§€ ì €ì¥ë¨');

            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ì„ íƒì§€ ì¶”ê°€
        function addChoice(sceneNum) {
            if (gameData[sceneNum].choices.length < 3) {
                gameData[sceneNum].choices.push({ text: '', next: 0, outcome: 'continue' });
                showSceneEditor(sceneNum);
                updateStatus('ì„ íƒì§€ ì¶”ê°€ë¨');
            }
        }

        // ì„ íƒì§€ ì‚­ì œ
        function deleteChoice(sceneNum, choiceIndex) {
            if (confirm('ì„ íƒì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                gameData[sceneNum].choices.splice(choiceIndex, 1);
                updateUsedScenes();
                renderTree();
                if (selectedType === 'choice') {
                    showSceneEditor(sceneNum);
                }
                saveToLocal();
                updateStatus('ì„ íƒì§€ ì‚­ì œë¨');
            }
        }

        // ì”¬ ì‚­ì œ
        function deleteScene(sceneNum) {
            if (sceneNum === 1) {
                alert('ì”¬ 1ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            if (confirm(`ì”¬ ${sceneNum}ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                gameData[sceneNum] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
                updateUsedScenes();
                renderTree();
                document.getElementById('editor').innerHTML = '<div class="empty-state">íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>';
                saveToLocal();
                updateStatus('ì”¬ ' + sceneNum + ' ì‚­ì œë¨');
                
                if (isMobile) {
                    switchTab('tree');
                }
            }
        }

        // ë¡œì»¬ ì €ì¥ (ë²„ì „ ì‹œìŠ¤í…œê³¼ í†µí•©)
        function saveToLocal() {
            saveAllVersionsToLocal();
            renderVersionTabs(); // ì”¬ ê°œìˆ˜ ì—…ë°ì´íŠ¸
        }

        // ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸° (í˜„ì¬ ë²„ì „ë§Œ ë‹¤ì‹œ ë¡œë“œ)
        function loadFromLocal() {
            if (loadAllVersionsFromLocal()) {
                updateUsedScenes();
                renderTree();
                renderVersionTabs();
                updateStatus('ë°ì´í„° ë¶ˆëŸ¬ì˜´');
            } else {
                updateStatus('ì €ì¥ëœ ë°ì´í„° ì—†ìŒ');
            }
        }

        // ì´ˆê¸°í™” (í˜„ì¬ ë²„ì „ë§Œ)
        function clearAll() {
            const currentName = storyVersions[currentVersionIndex].name;
            if (confirm(`"${currentName}" ë²„ì „ì˜ ëª¨ë“  ì”¬ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                gameData = { 1: { content: '', isEnding: false, choices: [] } };
                storyVersions[currentVersionIndex].data = gameData;
                usedSceneNumbers.clear();
                usedSceneNumbers.add(1);

                document.getElementById('editor').innerHTML = '<div class="empty-state">íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>';
                selectedNode = null;
                selectedType = null;
                currentEditingScene = null;
                currentEditingChoice = null;

                renderTree();
                renderVersionTabs();
                saveToLocal();
                updateStatus(`"${currentName}" ì´ˆê¸°í™” ì™„ë£Œ`);
            }
        }

        // game.html í˜¸í™˜ JSON ë‚´ë³´ë‚´ê¸°
        function exportJSON() {
            const story = convertToStoryFormat();
            const errors = validateStory(story);

            if (errors.length > 0) {
                alert('ìœ íš¨ì„± ê²€ì‚¬ ê²½ê³ :\n' + errors.join('\n') + '\n\në‚´ë³´ë‚´ê¸°ë¥¼ ê³„ì†í•©ë‹ˆë‹¤.');
            }

            const json = JSON.stringify(story, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${gameTitle.replace(/\s+/g, '-')}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('JSON íŒŒì¼ ìƒì„±ë¨ (game.html í˜¸í™˜)');
        }

        // ì—ë””í„° ë°ì´í„°ë¥¼ game.html STORY í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        function convertToStoryFormat() {
            const scenes = [];
            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            sceneList.forEach(num => {
                const scene = gameData[num];
                if (!scene || (!scene.content && scene.choices.length === 0)) return;

                const sceneId = `S${String(num).padStart(3, '0')}`;
                const sceneObj = {
                    id: sceneId,
                    name: `ì”¬ ${num}`,
                    content: scene.content || '',
                    isEnding: scene.isEnding || false,
                    choices: []
                };

                if (scene.isEnding) {
                    sceneObj.endingInfo = {
                        code: `END-${num}`,
                        title: `ì—”ë”© ${num}`,
                        summary: scene.content || ''
                    };
                    // ì—”ë”© ì”¬ë„ ë¹ˆ ì„ íƒì§€ 2ê°œ í•„ìš” (game.html í˜•ì‹)
                    sceneObj.choices = [
                        { id: `C${String(num).padStart(3, '0')}A`, label: '', outcome: 'continue', nextSceneId: '' },
                        { id: `C${String(num).padStart(3, '0')}B`, label: '', outcome: 'continue', nextSceneId: '' }
                    ];
                } else {
                    // ì„ íƒì§€ ë³€í™˜ (ìµœëŒ€ 2ê°œë§Œ)
                    for (let i = 0; i < 2; i++) {
                        const choice = scene.choices[i];
                        const choiceId = `C${String(num).padStart(3, '0')}${i === 0 ? 'A' : 'B'}`;

                        if (choice && choice.text) {
                            const outcome = choice.outcome || 'continue';
                            let nextSceneId = '';

                            if (outcome === 'continue' && choice.next > 0) {
                                nextSceneId = `S${String(choice.next).padStart(3, '0')}`;
                            }

                            sceneObj.choices.push({
                                id: choiceId,
                                label: choice.text,
                                outcome: outcome,
                                nextSceneId: nextSceneId
                            });
                        } else {
                            // ë¹ˆ ì„ íƒì§€
                            sceneObj.choices.push({
                                id: choiceId,
                                label: '',
                                outcome: 'continue',
                                nextSceneId: ''
                            });
                        }
                    }
                }

                scenes.push(sceneObj);
            });

            return {
                title: gameTitle,
                startSceneId: 'S001',
                scenes: scenes
            };
        }

        // STORY í˜•ì‹ ìœ íš¨ì„± ê²€ì‚¬
        function validateStory(story) {
            const errors = [];

            if (!story.startSceneId) {
                errors.push('ì‹œì‘ ì”¬ IDê°€ ì—†ìŠµë‹ˆë‹¤.');
            } else if (!story.scenes.find(s => s.id === story.startSceneId)) {
                errors.push(`ì‹œì‘ ì”¬ ${story.startSceneId}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
            }

            story.scenes.forEach(scene => {
                if (!scene.choices || scene.choices.length !== 2) {
                    errors.push(`ì”¬ ${scene.id}: ì„ íƒì§€ê°€ ì •í™•íˆ 2ê°œì—¬ì•¼ í•©ë‹ˆë‹¤.`);
                }

                if (scene.choices) {
                    scene.choices.forEach((choice, idx) => {
                        if (choice.outcome === 'continue' && choice.label && !choice.nextSceneId) {
                            errors.push(`ì”¬ ${scene.id}, ì„ íƒì§€ ${idx + 1}: outcomeì´ 'continue'ì¸ë° nextSceneIdê°€ ì—†ìŠµë‹ˆë‹¤.`);
                        }

                        if (choice.outcome === 'continue' && choice.nextSceneId) {
                            if (!story.scenes.find(s => s.id === choice.nextSceneId)) {
                                errors.push(`ì”¬ ${scene.id}, ì„ íƒì§€ ${idx + 1}: nextSceneId ${choice.nextSceneId}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                            }
                        }
                    });
                }
            });

            return errors;
        }

        // JSON ê°€ì ¸ì˜¤ê¸°
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);
                        convertFromStoryFormat(story);
                        updateStatus('JSON íŒŒì¼ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ');
                    } catch (err) {
                        alert('JSON íŒŒì‹± ì‹¤íŒ¨: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // game.html STORY í˜•ì‹ì„ ì—ë””í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        function convertFromStoryFormat(story) {
            if (story.title) {
                gameTitle = story.title;
            }

            // ê¸°ì¡´ ë°ì´í„° ì´ˆê¸°í™”
            init();

            if (story.scenes && Array.isArray(story.scenes)) {
                story.scenes.forEach(scene => {
                    // ì”¬ IDì—ì„œ ë²ˆí˜¸ ì¶”ì¶œ (S001 -> 1)
                    const match = scene.id.match(/S(\d+)/);
                    if (!match) return;

                    const num = parseInt(match[1]);
                    if (num < 1 || num > 1000) return;

                    gameData[num] = {
                        content: scene.content || '',
                        isEnding: scene.isEnding || false,
                        choices: []
                    };

                    if (!scene.isEnding && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.label) {
                                let nextNum = 0;
                                if (choice.nextSceneId) {
                                    const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                    if (nextMatch) {
                                        nextNum = parseInt(nextMatch[1]);
                                    }
                                }

                                gameData[num].choices.push({
                                    text: choice.label,
                                    next: nextNum,
                                    outcome: choice.outcome || 'continue'
                                });
                            }
                        });
                    }
                });
            }

            updateUsedScenes();
            renderTree();
            saveToLocal();
        }

        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
            updateStats();
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            const used = usedSceneNumbers.size;
            const available = 1000 - used;

            document.getElementById('usedScenes').textContent = used;
            document.getElementById('availableScenes').textContent = available;

            // ì˜ˆìƒ í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
            const estimatedTime = calculateEstimatedPlayTime();
            document.getElementById('estimatedTime').textContent = estimatedTime;
        }

        // ì˜ˆìƒ í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
        // í•œêµ­ì–´ í‰ê·  ì½ê¸° ì†ë„: ì•½ 200ì/ë¶„ (ì„±ì¸ ê¸°ì¤€)
        // ì„ íƒì§€ ê³ ë¯¼ ì‹œê°„: ì•½ 3-5ì´ˆ ì¶”ê°€
        function calculateEstimatedPlayTime() {
            const CHARS_PER_MINUTE = 200; // í•œêµ­ì–´ ì½ê¸° ì†ë„
            const CHOICE_THINKING_SECONDS = 4; // ì„ íƒì§€ë‹¹ ê³ ë¯¼ ì‹œê°„

            // ëª¨ë“  ê²½ë¡œ íƒìƒ‰í•˜ì—¬ í‰ê·  ê²½ë¡œ ê¸¸ì´ ê³„ì‚°
            const paths = findAllPaths();

            if (paths.length === 0) {
                return '0ë¶„';
            }

            // ê° ê²½ë¡œì˜ í”Œë ˆì´ ì‹œê°„ ê³„ì‚°
            const pathTimes = paths.map(path => {
                let totalChars = 0;
                let totalChoices = 0;

                path.forEach(sceneNum => {
                    const scene = gameData[sceneNum];
                    if (scene) {
                        // ì”¬ ë‚´ìš© ê¸€ì ìˆ˜
                        totalChars += (scene.content || '').length;

                        // ì„ íƒì§€ ê¸€ì ìˆ˜ ë° ê°œìˆ˜
                        if (scene.choices && !scene.isEnding) {
                            scene.choices.forEach(choice => {
                                if (choice.text) {
                                    totalChars += choice.text.length;
                                    totalChoices++;
                                }
                            });
                        }
                    }
                });

                // ì½ê¸° ì‹œê°„(ë¶„) + ì„ íƒ ê³ ë¯¼ ì‹œê°„(ë¶„)
                const readingMinutes = totalChars / CHARS_PER_MINUTE;
                const thinkingMinutes = (totalChoices * CHOICE_THINKING_SECONDS) / 60;

                return readingMinutes + thinkingMinutes;
            });

            // ìµœì†Œ, ìµœëŒ€, í‰ê·  ê³„ì‚°
            const minTime = Math.min(...pathTimes);
            const maxTime = Math.max(...pathTimes);
            const avgTime = pathTimes.reduce((a, b) => a + b, 0) / pathTimes.length;

            // í¬ë§·íŒ…
            if (avgTime < 1) {
                const seconds = Math.round(avgTime * 60);
                return `${seconds}ì´ˆ`;
            } else if (minTime === maxTime) {
                return `ì•½ ${Math.round(avgTime)}ë¶„`;
            } else {
                return `${Math.round(minTime)}-${Math.round(maxTime)}ë¶„`;
            }
        }

        // ì”¬ 1ë¶€í„° ëª¨ë“  ê°€ëŠ¥í•œ ê²½ë¡œ íƒìƒ‰ (DFS)
        function findAllPaths() {
            const paths = [];
            const maxDepth = 100; // ë¬´í•œ ë£¨í”„ ë°©ì§€

            function dfs(sceneNum, currentPath, visited) {
                if (currentPath.length > maxDepth) return;
                if (visited.has(sceneNum)) return; // ìˆœí™˜ ë°©ì§€

                const scene = gameData[sceneNum];
                if (!scene || !scene.content) return;

                const newPath = [...currentPath, sceneNum];
                const newVisited = new Set(visited);
                newVisited.add(sceneNum);

                // ì—”ë”©ì´ê±°ë‚˜ ì„ íƒì§€ê°€ ì—†ìœ¼ë©´ ê²½ë¡œ ì™„ì„±
                if (scene.isEnding || !scene.choices || scene.choices.length === 0) {
                    paths.push(newPath);
                    return;
                }

                // ìœ íš¨í•œ ì„ íƒì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
                let hasValidChoice = false;
                scene.choices.forEach(choice => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';

                        if (outcome === 'success' || outcome === 'failure') {
                            // ì—”ë”© ì„ íƒì§€ - ê²½ë¡œ ì™„ì„±
                            paths.push(newPath);
                            hasValidChoice = true;
                        } else if (choice.next > 0) {
                            // ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì´ë™
                            dfs(choice.next, newPath, newVisited);
                            hasValidChoice = true;
                        }
                    }
                });

                // ìœ íš¨í•œ ì„ íƒì§€ê°€ ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ ê²½ë¡œ ì¢…ë£Œ
                if (!hasValidChoice) {
                    paths.push(newPath);
                }
            }

            // ì”¬ 1ë¶€í„° ì‹œì‘
            if (gameData[1] && gameData[1].content) {
                dfs(1, [], new Set());
            }

            return paths;
        }

        // ì´ˆê¸°í™”
        window.onload = function() {
            // ìƒˆ ë²„ì „ ì‹œìŠ¤í…œ ë¡œë“œ ì‹œë„
            if (!loadAllVersionsFromLocal()) {
                // ê¸°ì¡´ ë‹¨ì¼ ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œë„
                const oldSaved = localStorage.getItem('gameTreeDataMobile');
                if (oldSaved) {
                    try {
                        const oldData = JSON.parse(oldSaved);
                        storyVersions = [{
                            name: 'ë²„ì „ 1',
                            title: 'Catch! Love',
                            data: oldData
                        }];
                        currentVersionIndex = 0;
                        gameData = oldData;
                        gameTitle = 'Catch! Love';
                        // ë§ˆì´ê·¸ë ˆì´ì…˜ í›„ ìƒˆ í˜•ì‹ìœ¼ë¡œ ì €ì¥
                        saveAllVersionsToLocal();
                    } catch (e) {
                        initDefaultVersion();
                    }
                } else {
                    initDefaultVersion();
                }
            }

            updateUsedScenes();
            renderTree();
            renderVersionTabs();

            // ë°ìŠ¤í¬í†±ì—ì„œëŠ” íŒ¨ë„ ëª¨ë‘ í‘œì‹œ
            if (!isMobile) {
                document.getElementById('treePanel').classList.add('active');
                document.getElementById('editorPanel').classList.add('active');
            }

            // ë¦¬ì‚¬ì´ì € ì´ˆê¸°í™”
            initResizer();

            // ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œì‘
            startAutoSave();
        };

        // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œ ì €ì¥
        window.onbeforeunload = function() {
            autoSaveCurrentEdit();
        };

        // íƒ­ì´ ë¹„í™œì„±í™”ë  ë•Œë„ ì €ì¥ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ìš©)
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                autoSaveCurrentEdit();
            }
        });

        // ========== íŒì—… ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥ ==========
        let previewPopup = null;

        function openPreviewPopup() {
            autoSaveCurrentEdit();

            if (!gameData[1] || !gameData[1].content) {
                alert('ì”¬ 1ì— ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ê¸°ì¡´ íŒì—…ì´ ì—´ë ¤ìˆìœ¼ë©´ í¬ì»¤ìŠ¤
            if (previewPopup && !previewPopup.closed) {
                previewPopup.focus();
                previewPopup.postMessage({ type: 'refresh', scene: 1 }, '*');
                return;
            }

            // íŒì—… HTML ìƒì„±
            const popupContent = generatePreviewPopupHTML();

            previewPopup = window.open('', 'PreviewPopup', 'width=500,height=700,scrollbars=yes,resizable=yes');
            previewPopup.document.write(popupContent);
            previewPopup.document.close();
        }

        function generatePreviewPopupHTML() {
            return `
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ğŸ® ë¯¸ë¦¬ë³´ê¸°</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 15px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }
        .header h1 { color: white; font-size: 18px; }
        .header-btns { display: flex; gap: 8px; }
        .header-btns button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .content-box {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            min-height: 150px;
        }
        .scene-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .scene-num { font-size: 12px; color: #999; }
        .edit-btn {
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .edit-btn:hover { background: #0056b3; }
        .scene-content {
            font-size: 15px;
            line-height: 1.8;
            color: #333;
            white-space: pre-wrap;
        }
        .choices { display: flex; flex-direction: column; gap: 10px; }
        .choice-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            text-align: left;
            transition: all 0.2s;
        }
        .choice-btn:hover { transform: translateY(-2px); opacity: 0.9; }
        .choice-btn.success { background: #28a745; }
        .choice-btn.failure { background: #dc3545; }
        .choice-text { flex: 1; }
        .choice-edit {
            padding: 4px 8px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            margin-left: 10px;
        }
        .choice-edit:hover { background: rgba(255,255,255,0.3); }
        .ending {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
        }
        .ending-icon { font-size: 48px; margin-bottom: 10px; }
        .ending-text { font-size: 20px; color: white; font-weight: bold; }
        .path-box {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }
        .path-label { color: rgba(255,255,255,0.7); font-size: 11px; margin-bottom: 5px; }
        .path-content { color: white; font-size: 12px; word-break: break-all; }
        .warning {
            text-align: center;
            color: #dc3545;
            padding: 20px;
        }
        .warning-icon { font-size: 40px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® ë¯¸ë¦¬ë³´ê¸°</h1>
        <div class="header-btns">
            <button onclick="goBack()" id="backBtn" style="background: #6c757d; color: white; display: none;">â¬…ï¸ ì´ì „</button>
            <button onclick="restart()" style="background: #28a745; color: white;">ğŸ”„ ì²˜ìŒë¶€í„°</button>
        </div>
    </div>
    <div id="content"></div>
    <div class="path-box">
        <div class="path-label">ğŸ“ ê²½ë¡œ:</div>
        <div class="path-content" id="pathDisplay"></div>
    </div>

    <script>
        let currentScene = 1;
        let pathHistory = [];
        let sceneStack = [];

        function getGameData() {
            return window.opener ? window.opener.gameData : {};
        }

        function showScene(sceneNum, addToStack = true) {
            const gameData = getGameData();
            const scene = gameData[sceneNum];

            if (addToStack && currentScene !== sceneNum) {
                sceneStack.push(currentScene);
            }
            currentScene = sceneNum;
            pathHistory.push('ì”¬ ' + sceneNum);

            document.getElementById('pathDisplay').textContent = pathHistory.join(' â†’ ');
            document.getElementById('backBtn').style.display = sceneStack.length > 0 ? 'inline-block' : 'none';

            const content = document.getElementById('content');

            if (!scene || !scene.content) {
                content.innerHTML = '<div class="content-box"><div class="warning"><div class="warning-icon">âš ï¸</div><div>ì”¬ ' + sceneNum + 'ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</div></div></div>';
                return;
            }

            let html = '<div class="content-box">';
            html += '<div class="scene-info"><span class="scene-num">ğŸ“ ì”¬ ' + sceneNum + '</span>';
            html += '<button class="edit-btn" onclick="editScene(' + sceneNum + ')">âœï¸ í¸ì§‘</button></div>';
            html += '<div class="scene-content">' + escapeHtml(scene.content) + '</div></div>';

            if (scene.isEnding) {
                html += '<div class="ending"><div class="ending-icon">ğŸ‰</div><div class="ending-text">~ THE END ~</div></div>';
            } else if (scene.choices && scene.choices.length > 0) {
                html += '<div class="choices">';
                scene.choices.forEach((choice, idx) => {
                    if (choice.text) {
                        const outcome = choice.outcome || 'continue';
                        let btnClass = '';
                        let label = '';
                        if (outcome === 'success') { btnClass = 'success'; label = ' ğŸ‰'; }
                        else if (outcome === 'failure') { btnClass = 'failure'; label = ' ğŸ’”'; }

                        html += '<button class="choice-btn ' + btnClass + '" onclick="selectChoice(' + sceneNum + ',' + idx + ')">';
                        html += '<span class="choice-text">' + (idx + 1) + '. ' + escapeHtml(choice.text) + label + '</span>';
                        html += '<span class="choice-edit" onclick="event.stopPropagation(); editChoice(' + sceneNum + ',' + idx + ')">í¸ì§‘</span>';
                        html += '</button>';
                    }
                });
                html += '</div>';
            } else {
                html += '<div class="content-box"><div class="warning">ì„ íƒì§€ê°€ ì—†ìŠµë‹ˆë‹¤</div></div>';
            }

            content.innerHTML = html;
        }

        function selectChoice(sceneNum, choiceIdx) {
            const gameData = getGameData();
            const choice = gameData[sceneNum].choices[choiceIdx];
            if (!choice) return;

            pathHistory.push('"' + choice.text.substring(0, 15) + (choice.text.length > 15 ? '...' : '') + '"');
            const outcome = choice.outcome || 'continue';

            if (outcome === 'success') {
                showEnding('success');
            } else if (outcome === 'failure') {
                showEnding('failure');
            } else if (choice.next && choice.next > 0) {
                showScene(choice.next);
            } else {
                document.getElementById('content').innerHTML = '<div class="content-box"><div class="warning"><div class="warning-icon">âš ï¸</div><div>ë‹¤ìŒ ì”¬ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤</div></div></div>';
            }
        }

        function showEnding(type) {
            document.getElementById('pathDisplay').textContent = pathHistory.join(' â†’ ');
            const icon = type === 'success' ? 'ğŸ’•' : 'ğŸ’”';
            const text = type === 'success' ? 'SUCCESS!' : 'MAYBE NEXT TIME...';
            const gradient = type === 'success' ? 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)' : 'linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%)';
            document.getElementById('content').innerHTML = '<div class="ending" style="background: ' + gradient + '"><div class="ending-icon">' + icon + '</div><div class="ending-text">' + text + '</div></div>';
        }

        function editScene(sceneNum) {
            if (window.opener && !window.opener.closed) {
                window.opener.selectScene(sceneNum);
                window.opener.focus();
            }
        }

        function editChoice(sceneNum, choiceIdx) {
            if (window.opener && !window.opener.closed) {
                window.opener.selectChoice(sceneNum, choiceIdx);
                window.opener.focus();
            }
        }

        function goBack() {
            if (sceneStack.length > 0) {
                if (pathHistory.length > 0) pathHistory.pop();
                if (pathHistory.length > 0) pathHistory.pop();
                const prevScene = sceneStack.pop();
                showScene(prevScene, false);
            }
        }

        function restart() {
            currentScene = 1;
            pathHistory = [];
            sceneStack = [];
            showScene(1, false);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ë¶€ëª¨ ì°½ì—ì„œ ë©”ì‹œì§€ ìˆ˜ì‹ 
        window.addEventListener('message', function(e) {
            if (e.data.type === 'refresh') {
                showScene(e.data.scene || currentScene, false);
            }
        });

        // ì´ˆê¸°í™”
        showScene(1, false);
    </script>
</body>
</html>`;
        }

        // íŒì—… ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜ (í¸ì§‘ í›„ í˜¸ì¶œ)
        function refreshPreviewPopup() {
            if (previewPopup && !previewPopup.closed) {
                previewPopup.postMessage({ type: 'refresh' }, '*');
            }
        }
    </script>
</body>
</html>