<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Game Tree Editor - Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header {
            padding: 15px;
            border-bottom: 2px solid #eee;
        }

        .title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        /* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */
        .tab-nav {
            display: none;
            background: #f8f9fa;
            padding: 10px;
            gap: 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .tab-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .main-content {
            display: flex;
            min-height: 500px;
            position: relative;
        }

        .panel {
            padding: 20px;
            overflow-y: auto;
        }

        .tree-panel {
            width: 40%;
            min-width: 250px;
            background: #fafafa;
            border-right: 1px solid #eee;
            max-height: 600px;
            display: flex;
            flex-direction: column;
        }

        .tree-panel-header {
            padding: 10px 0;
            border-bottom: 2px solid #ddd;
            margin-bottom: 15px;
        }

        .tree-panel-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .tree-panel-controls button {
            flex: 1;
            padding: 8px 12px;
            font-size: 13px;
        }

        .resizer {
            width: 5px;
            cursor: col-resize;
            background: #e0e0e0;
            position: relative;
            transition: background 0.2s;
        }

        .resizer:hover {
            background: #007bff;
        }

        .resizer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 40px;
            background: #999;
            border-radius: 2px;
        }

        .editor-panel {
            flex: 1;
            background: white;
            max-height: 600px;
        }

        /* Tree Styles */
        .tree {
            font-size: 14px;
        }

        .tree ul {
            list-style: none;
            margin: 0;
            padding-left: 0;
        }

        .tree li {
            margin: 3px 0;
            position: relative;
        }

        .tree li ul {
            margin-left: 20px;
        }

        .tree li::before {
            content: '';
            position: absolute;
            top: 12px;
            left: -12px;
            width: 10px;
            height: 1px;
            background: #999;
        }

        .tree li::after {
            content: '';
            position: absolute;
            left: -12px;
            top: -8px;
            bottom: 12px;
            width: 1px;
            background: #999;
        }

        .tree > ul > li::before,
        .tree > ul > li::after {
            display: none;
        }

        .scene-node, .choice-node {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            margin: 2px 0;
            user-select: none;
        }

        .scene-node {
            background: white;
            border: 2px solid #007bff;
        }

        .scene-node:active {
            transform: scale(0.98);
        }

        .scene-node.selected {
            background: #007bff;
            color: white;
        }

        .scene-node.empty {
            border-style: dashed;
            opacity: 0.6;
        }

        .scene-node.ending {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .choice-node {
            background: #f0f0f0;
            border: 1px solid #999;
            font-size: 12px;
        }

        .choice-node.selected {
            background: #6c757d;
            color: white;
        }

        /* Editor Styles */
        .editor-section {
            margin-bottom: 20px;
        }

        .editor-label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
        }

        .editor-input, .editor-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px; /* iOS ì¤Œ ë°©ì§€ */
        }

        .editor-textarea {
            min-height: 120px;
            resize: vertical;
            font-family: inherit;
        }

        .choice-container {
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 12px;
            margin-bottom: 12px;
            background: #f9f9f9;
        }

        .choice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .next-scene-control {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .next-scene-input {
            width: 100px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 16px;
        }

        .auto-btn {
            padding: 8px 12px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 13px;
        }

        .delete-btn {
            padding: 6px 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }

        .add-choice-btn {
            padding: 10px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            width: 100%;
        }

        .editor-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .editor-controls button {
            flex: 1;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }

        .checkbox-label input {
            width: 20px;
            height: 20px;
        }

        .status-bar {
            padding: 12px;
            background: #f8f9fa;
            border-top: 1px solid #eee;
            font-size: 13px;
            text-align: center;
        }

        .stats-info {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .stat-value {
            font-weight: bold;
            color: #007bff;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px 20px;
        }

        /* ëª¨ë°”ì¼ ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
                box-shadow: none;
            }

            .header {
                position: sticky;
                top: 0;
                background: white;
                z-index: 100;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }

            .resizer {
                display: none;
            }

            .tree-panel {
                width: 100% !important;
            }

            .title {
                font-size: 18px;
            }

            .buttons {
                gap: 5px;
            }

            button {
                padding: 8px 12px;
                font-size: 13px;
            }

            .tab-nav {
                display: flex;
                position: sticky;
                top: 60px;
                z-index: 99;
                background: white;
                border-bottom: 1px solid #ddd;
            }

            .main-content {
                flex-direction: column;
                gap: 0;
            }

            .panel {
                display: none;
                min-height: calc(100vh - 200px);
                max-height: none !important;
            }

            .panel.active {
                display: block;
            }

            .tree-panel {
                border-right: none;
                border-bottom: 1px solid #eee;
            }

            /* ëª¨ë°”ì¼ì—ì„œ íŠ¸ë¦¬ í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
            .scene-node, .choice-node {
                padding: 10px 14px;
                font-size: 14px;
                margin: 4px 0;
            }

            .editor-input, .editor-textarea, .next-scene-input {
                font-size: 16px; /* iOS ì¤Œ ë°©ì§€ */
            }

            .editor-controls {
                flex-direction: column;
            }

            .editor-controls button {
                width: 100%;
                padding: 12px;
            }

            .next-scene-control {
                flex-direction: column;
                align-items: stretch;
            }

            .next-scene-input {
                width: 100%;
            }

            .auto-btn {
                width: 100%;
                padding: 10px;
            }

            /* ìŠ¤í¬ë¡¤ ê°œì„  */
            .tree-panel, .editor-panel {
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
            }

            /* í„°ì¹˜ í”¼ë“œë°± */
            button:active, .scene-node:active, .choice-node:active {
                opacity: 0.8;
            }
        }

        /* íƒœë¸”ë¦¿ */
        @media (min-width: 769px) and (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }

            .panel {
                max-height: 400px;
            }
        }

        /* ê°€ë¡œ ëª¨ë“œ ìµœì í™” */
        @media (max-width: 768px) and (orientation: landscape) {
            .header {
                padding: 10px;
            }

            .title {
                font-size: 16px;
                margin-bottom: 5px;
            }

            .panel {
                min-height: calc(100vh - 150px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">ğŸ® Game Tree Editor</h1>
            <div class="buttons">
                <button class="btn-primary" onclick="saveToLocal()">ğŸ’¾ ì €ì¥</button>
                <button class="btn-primary" onclick="loadFromLocal()">ğŸ“‚ ì—´ê¸°</button>
                <button class="btn-success" onclick="exportJSON()">ğŸ“¤ JSON</button>
                <button class="btn-info" onclick="importJSON()">ğŸ“¥ ê°€ì ¸ì˜¤ê¸°</button>
                <button class="btn-danger" onclick="clearAll()">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
            </div>
        </div>

        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchTab('tree')">ğŸŒ³ íŠ¸ë¦¬</button>
            <button class="tab-btn" onclick="switchTab('editor')">âœï¸ í¸ì§‘</button>
        </div>

        <div class="main-content">
            <div class="panel tree-panel active" id="treePanel">
                <div class="tree-panel-header">
                    <div class="tree-panel-controls">
                        <button class="btn-success" onclick="showAddSceneDialog()">â• ìƒˆ ì”¬</button>
                        <button class="btn-info" onclick="showAllScenes()">ğŸ“‹ ì „ì²´ ëª©ë¡</button>
                    </div>
                </div>
                <div class="tree" id="tree" style="flex: 1; overflow-y: auto;">
                    <div class="empty-state">ë¡œë”© ì¤‘...</div>
                </div>
            </div>

            <div class="resizer" id="resizer"></div>

            <div class="panel editor-panel" id="editorPanel">
                <div id="editor">
                    <div class="empty-state">
                        íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”
                    </div>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusMessage">ì¤€ë¹„ë¨</div>
            <div class="stats-info">
                <div>ì‚¬ìš©: <span class="stat-value" id="usedScenes">1</span></div>
                <div>ë‚¨ìŒ: <span class="stat-value" id="availableScenes">999</span></div>
                <div>ì „ì²´: <span class="stat-value">1000</span></div>
            </div>
        </div>
    </div>

    <script>
        let gameData = {};
        let selectedNode = null;
        let selectedType = null;
        let usedSceneNumbers = new Set();
        let isMobile = window.innerWidth <= 768;
        let gameTitle = "Catch! Love"; // ê²Œì„ ì œëª©
        let currentEditingScene = null; // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ì”¬ ë²ˆí˜¸
        let currentEditingChoice = null; // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ì„ íƒì§€ {scene, index}
        let autoSaveTimer = null; // ìë™ ì €ì¥ íƒ€ì´ë¨¸

        // ëª¨ë°”ì¼ ê°ì§€ ë° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        window.addEventListener('resize', () => {
            isMobile = window.innerWidth <= 768;
        });

        // íŒ¨ë„ ë¦¬ì‚¬ì´ì € ê¸°ëŠ¥
        function initResizer() {
            const resizer = document.getElementById('resizer');
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            let isResizing = false;

            resizer.addEventListener('mousedown', function(e) {
                if (isMobile) return;
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing || isMobile) return;

                const container = document.querySelector('.main-content');
                const containerRect = container.getBoundingClientRect();
                const newWidth = e.clientX - containerRect.left;
                const minWidth = 250;
                const maxWidth = containerRect.width - 300;

                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    const percentage = (newWidth / containerRect.width) * 100;
                    treePanel.style.width = percentage + '%';
                }
            });

            document.addEventListener('mouseup', function() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // íƒ­ ì „í™˜ (ëª¨ë°”ì¼)
        function switchTab(tab) {
            if (!isMobile) return;
            
            const treePanel = document.getElementById('treePanel');
            const editorPanel = document.getElementById('editorPanel');
            const tabBtns = document.querySelectorAll('.tab-btn');
            
            tabBtns.forEach(btn => btn.classList.remove('active'));
            
            if (tab === 'tree') {
                treePanel.classList.add('active');
                editorPanel.classList.remove('active');
                tabBtns[0].classList.add('active');
            } else {
                treePanel.classList.remove('active');
                editorPanel.classList.add('active');
                tabBtns[1].classList.add('active');
            }
        }

        // ì´ˆê¸°í™”
        function init() {
            for (let i = 1; i <= 1000; i++) {
                gameData[i] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }
            gameData[1].content = 'ê²Œì„ ì‹œì‘';
            updateUsedScenes();
            renderTree();
        }

        // ì‚¬ìš©ëœ ì”¬ ì—…ë°ì´íŠ¸
        function updateUsedScenes() {
            usedSceneNumbers.clear();
            usedSceneNumbers.add(1);
            
            function traverse(sceneNum) {
                const scene = gameData[sceneNum];
                if (!scene) return;
                
                scene.choices.forEach(choice => {
                    if (choice.next && choice.next > 0 && choice.next <= 1000) {
                        if (!usedSceneNumbers.has(choice.next)) {
                            usedSceneNumbers.add(choice.next);
                            traverse(choice.next);
                        }
                    }
                });
            }
            
            traverse(1);
            
            for (let i = 1; i <= 1000; i++) {
                if (gameData[i] && gameData[i].content && gameData[i].content.trim()) {
                    usedSceneNumbers.add(i);
                }
            }
            
            updateStats();
        }

        // ë‹¤ìŒ ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ ì°¾ê¸°
        function getNextAvailableScene() {
            for (let i = 2; i <= 1000; i++) {
                if (!usedSceneNumbers.has(i)) {
                    return i;
                }
            }
            return 0;
        }

        // ìƒˆ ì”¬ ì¶”ê°€ ë‹¤ì´ì–¼ë¡œê·¸
        function showAddSceneDialog() {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            const nextScene = getNextAvailableScene();
            if (nextScene === 0) {
                alert('ë” ì´ìƒ ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const sceneNum = prompt(`ìƒˆ ì”¬ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì¶”ì²œ: ${nextScene})`, nextScene);
            if (sceneNum === null) return;

            const num = parseInt(sceneNum);
            if (isNaN(num) || num < 1 || num > 1000) {
                alert('1~1000 ì‚¬ì´ì˜ ìˆ«ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            if (usedSceneNumbers.has(num)) {
                if (!confirm(`ì”¬ ${num}ì€(ëŠ”) ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. ìˆ˜ì •í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    return;
                }
            }

            // ìƒˆ ì”¬ ìƒì„± ë˜ëŠ” ìˆ˜ì •
            if (!gameData[num]) {
                gameData[num] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
            }

            selectScene(num);
            updateUsedScenes();
            renderTree();
            updateStatus(`ì”¬ ${num} ì¤€ë¹„ë¨`);
        }

        // ì „ì²´ ì”¬ ëª©ë¡ ë³´ê¸°
        function showAllScenes() {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì „ì²´ ì”¬ ëª©ë¡ (${sceneList.length}ê°œ)</h3>
                </div>

                <div class="editor-section">
                    <div style="display: grid; gap: 8px; max-height: 500px; overflow-y: auto;">`;

            sceneList.forEach(num => {
                const scene = gameData[num];
                const preview = scene.content ? scene.content.substring(0, 30) : '(ë‚´ìš© ì—†ìŒ)';
                const endingBadge = scene.isEnding ? '<span style="color: #dc3545; font-weight: bold;"> [END]</span>' : '';
                const choicesInfo = !scene.isEnding ? ` (ì„ íƒì§€: ${scene.choices.length})` : '';

                html += `
                    <div style="
                        padding: 12px;
                        background: ${num === 1 ? '#e3f2fd' : 'white'};
                        border: 2px solid ${scene.isEnding ? '#dc3545' : '#007bff'};
                        border-radius: 5px;
                        cursor: pointer;
                        transition: all 0.2s;
                    " onclick="selectScene(${num})"
                       onmouseover="this.style.background='#f0f0f0'"
                       onmouseout="this.style.background='${num === 1 ? '#e3f2fd' : 'white'}'">
                        <div style="font-weight: bold; margin-bottom: 5px;">
                            ì”¬ ${num}${endingBadge}${choicesInfo}
                        </div>
                        <div style="color: #666; font-size: 13px;">
                            ${preview}${scene.content && scene.content.length > 30 ? '...' : ''}
                        </div>
                    </div>`;
            });

            html += `
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-info" onclick="renderTree(); document.getElementById('editor').innerHTML='<div class=\\'empty-state\\'>íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>'">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>
                </div>`;

            document.getElementById('editor').innerHTML = html;

            if (isMobile) {
                switchTab('editor');
            }
        }

        // íŠ¸ë¦¬ ë Œë”ë§
        function renderTree() {
            const treeDiv = document.getElementById('tree');
            const html = buildTreeHTML(1, new Set());
            treeDiv.innerHTML = html;
        }

        // íŠ¸ë¦¬ HTML ìƒì„±
        function buildTreeHTML(sceneNum, visited) {
            if (visited.has(sceneNum)) {
                return `<li><span class="scene-node empty">ì”¬ ${sceneNum} (ìˆœí™˜)</span></li>`;
            }

            visited.add(sceneNum);
            const scene = gameData[sceneNum];
            
            const hasContent = scene.content && scene.content.trim();
            const nodeClass = `scene-node ${hasContent ? '' : 'empty'} ${scene.isEnding ? 'ending' : ''} ${selectedNode === sceneNum && selectedType === 'scene' ? 'selected' : ''}`;
            
            let html = '<ul><li>';
            html += `<span class="${nodeClass}" onclick="selectScene(${sceneNum})">`;
            html += `ğŸ“„ ì”¬ ${sceneNum}`;
            if (hasContent) {
                const preview = scene.content.substring(0, 12);
                html += `: ${preview}${scene.content.length > 12 ? '...' : ''}`;
            }
            if (scene.isEnding) {
                html += ' [END]';
            }
            html += '</span>';
            
            if (!scene.isEnding && scene.choices.length > 0) {
                html += '<ul>';
                scene.choices.forEach((choice, index) => {
                    const choiceClass = `choice-node ${choice.text ? '' : 'empty'} ${selectedNode === `${sceneNum}-${index}` && selectedType === 'choice' ? 'selected' : ''}`;
                    html += '<li>';
                    html += `<span class="${choiceClass}" onclick="selectChoice(${sceneNum}, ${index})">`;
                    html += `â–¶ ${index + 1}. ${choice.text ? choice.text.substring(0, 15) + (choice.text.length > 15 ? '...' : '') : '(ë¹ˆ ì„ íƒì§€)'}`;
                    if (choice.next) {
                        html += ` â†’ ${choice.next}`;
                    }
                    html += '</span>';
                    
                    if (choice.next && choice.next > 0) {
                        html += buildTreeHTML(choice.next, new Set([...visited]));
                    }
                    
                    html += '</li>';
                });
                html += '</ul>';
            }
            
            html += '</li></ul>';
            
            return html;
        }

        // í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ë‚´ìš© ìë™ ì €ì¥
        function autoSaveCurrentEdit() {
            // ì”¬ í¸ì§‘ ì¤‘ì´ë©´ ì €ì¥
            if (currentEditingScene !== null && selectedType === 'scene') {
                const contentEl = document.getElementById('sceneContent');
                const isEndingEl = document.getElementById('isEnding');

                if (contentEl) {
                    gameData[currentEditingScene].content = contentEl.value;
                }
                if (isEndingEl) {
                    gameData[currentEditingScene].isEnding = isEndingEl.checked;
                }

                // ì„ íƒì§€ë“¤ë„ ì €ì¥
                if (!gameData[currentEditingScene].isEnding) {
                    gameData[currentEditingScene].choices.forEach((choice, index) => {
                        const textInput = document.getElementById(`choice-text-${index}`);
                        const nextInput = document.getElementById(`choice-next-${index}`);
                        const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                        if (textInput) choice.text = textInput.value;
                        if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                        if (outcomeInput) choice.outcome = outcomeInput.value;
                    });
                }

                saveToLocal();
            }

            // ì„ íƒì§€ í¸ì§‘ ì¤‘ì´ë©´ ì €ì¥
            if (currentEditingChoice !== null && selectedType === 'choice') {
                const textEl = document.getElementById('choiceText');
                const outcomeEl = document.getElementById('choiceOutcome');
                const nextEl = document.getElementById('choiceNext');

                if (textEl && gameData[currentEditingChoice.scene]?.choices[currentEditingChoice.index]) {
                    const choice = gameData[currentEditingChoice.scene].choices[currentEditingChoice.index];
                    choice.text = textEl.value;
                    if (outcomeEl) choice.outcome = outcomeEl.value;
                    if (nextEl && choice.outcome === 'continue') {
                        choice.next = parseInt(nextEl.value) || 0;
                    }
                    saveToLocal();
                }
            }
        }

        // ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œì‘ (5ì´ˆë§ˆë‹¤)
        function startAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
            }
            autoSaveTimer = setInterval(() => {
                autoSaveCurrentEdit();
                updateStatus('ìë™ ì €ì¥ë¨');
            }, 5000);
        }

        // ì”¬ ì„ íƒ
        function selectScene(sceneNum) {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            selectedNode = sceneNum;
            selectedType = 'scene';
            currentEditingScene = sceneNum;
            currentEditingChoice = null;

            renderTree();
            showSceneEditor(sceneNum);

            // ëª¨ë°”ì¼ì—ì„œëŠ” ìë™ìœ¼ë¡œ í¸ì§‘ íƒ­ìœ¼ë¡œ ì „í™˜
            if (isMobile) {
                switchTab('editor');
            }
        }

        // ì„ íƒì§€ ì„ íƒ
        function selectChoice(sceneNum, choiceIndex) {
            // ê¸°ì¡´ í¸ì§‘ ë‚´ìš© ë¨¼ì € ì €ì¥
            autoSaveCurrentEdit();

            selectedNode = `${sceneNum}-${choiceIndex}`;
            selectedType = 'choice';
            currentEditingScene = null;
            currentEditingChoice = { scene: sceneNum, index: choiceIndex };

            renderTree();
            showChoiceEditor(sceneNum, choiceIndex);

            if (isMobile) {
                switchTab('editor');
            }
        }

        // ì”¬ ì—ë””í„°
        function showSceneEditor(sceneNum) {
            const scene = gameData[sceneNum];
            const editor = document.getElementById('editor');
            
            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì”¬ ${sceneNum}</h3>
                </div>
                
                <div class="editor-section">
                    <div class="editor-label">ì”¬ ë‚´ìš©</div>
                    <textarea class="editor-textarea" id="sceneContent" 
                              placeholder="ì´ ì”¬ì˜ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”...">${scene.content}</textarea>
                </div>
                
                <div class="editor-section">
                    <label class="checkbox-label">
                        <input type="checkbox" id="isEnding" ${scene.isEnding ? 'checked' : ''} 
                               onchange="toggleEnding(${sceneNum})">
                        <span>ì—”ë”© ì”¬ìœ¼ë¡œ ì„¤ì •</span>
                    </label>
                </div>
                
                <div class="editor-section" id="choicesSection" ${scene.isEnding ? 'style="display:none"' : ''}>
                    <div class="editor-label">ì„ íƒì§€ (${scene.choices.length}/3)</div>`;
            
            scene.choices.forEach((choice, index) => {
                const outcomeValue = choice.outcome || 'continue';
                html += `
                    <div class="choice-container">
                        <div class="choice-header">
                            <span class="choice-number">ì„ íƒì§€ ${index + 1}</span>
                            <button class="delete-btn" onclick="deleteChoice(${sceneNum}, ${index})">ì‚­ì œ</button>
                        </div>
                        <input type="text" class="editor-input" id="choice-text-${index}"
                               placeholder="ì„ íƒì§€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." value="${choice.text}">
                        <div class="next-scene-control">
                            <select class="editor-input" id="choice-outcome-${index}" style="width: auto; min-width: 120px;">
                                <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>ë‹¤ìŒ ì”¬ìœ¼ë¡œ</option>
                                <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ì„±ê³µ ì—”ë”©</option>
                                <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>ì‹¤íŒ¨ ì—”ë”©</option>
                            </select>
                            <input type="number" class="next-scene-input" id="choice-next-${index}"
                                   min="1" max="1000" value="${choice.next || ''}"
                                   placeholder="ë‹¤ìŒ ì”¬" ${outcomeValue !== 'continue' ? 'disabled' : ''}>
                            <button class="auto-btn" onclick="autoAssignNext(${sceneNum}, ${index})" ${outcomeValue !== 'continue' ? 'disabled' : ''}>ìë™</button>
                        </div>
                    </div>`;
            });
            
            if (scene.choices.length < 3 && !scene.isEnding) {
                html += `<button class="add-choice-btn" onclick="addChoice(${sceneNum})">+ ì„ íƒì§€ ì¶”ê°€</button>`;
            }
            
            html += `</div>
                
                <div class="editor-controls">
                    <button class="btn-success" onclick="saveScene(${sceneNum})">ì €ì¥</button>
                    ${sceneNum !== 1 ? `<button class="btn-danger" onclick="deleteScene(${sceneNum})">ì”¬ ì‚­ì œ</button>` : ''}
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>` : ''}
                </div>`;
            
            editor.innerHTML = html;
        }

        // ì„ íƒì§€ ì—ë””í„°
        function showChoiceEditor(sceneNum, choiceIndex) {
            const choice = gameData[sceneNum].choices[choiceIndex];
            const editor = document.getElementById('editor');
            const outcomeValue = choice.outcome || 'continue';

            let html = `
                <div class="editor-section">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ì”¬ ${sceneNum} - ì„ íƒì§€ ${choiceIndex + 1}</h3>
                </div>

                <div class="editor-section">
                    <div class="editor-label">ì„ íƒì§€ í…ìŠ¤íŠ¸</div>
                    <input type="text" class="editor-input" id="choiceText"
                           placeholder="ì„ íƒì§€ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." value="${choice.text || ''}">
                </div>

                <div class="editor-section">
                    <div class="editor-label">ê²°ê³¼ ìœ í˜•</div>
                    <select class="editor-input" id="choiceOutcome" onchange="toggleNextSceneInput()">
                        <option value="continue" ${outcomeValue === 'continue' ? 'selected' : ''}>ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</option>
                        <option value="success" ${outcomeValue === 'success' ? 'selected' : ''}>ì„±ê³µ ì—”ë”©</option>
                        <option value="failure" ${outcomeValue === 'failure' ? 'selected' : ''}>ì‹¤íŒ¨ ì—”ë”©</option>
                    </select>
                </div>

                <div class="editor-section" id="nextSceneSection" ${outcomeValue !== 'continue' ? 'style="display:none"' : ''}>
                    <div class="editor-label">ë‹¤ìŒ ì”¬ ë²ˆí˜¸</div>
                    <div class="next-scene-control">
                        <input type="number" class="editor-input" id="choiceNext"
                               min="1" max="1000" value="${choice.next || ''}"
                               placeholder="1-1000">
                        <button class="auto-btn" onclick="autoAssignNextForChoice(${sceneNum}, ${choiceIndex})">ìë™ ì±„ë²ˆ</button>
                    </div>
                </div>

                <div class="editor-controls">
                    <button class="btn-success" onclick="saveChoice(${sceneNum}, ${choiceIndex})">ì €ì¥</button>
                    <button class="btn-danger" onclick="deleteChoice(${sceneNum}, ${choiceIndex})">ì‚­ì œ</button>
                    ${isMobile ? `<button class="btn-info" onclick="switchTab('tree')">íŠ¸ë¦¬ë¡œ ëŒì•„ê°€ê¸°</button>` : ''}
                </div>`;

            editor.innerHTML = html;
        }

        // ë‹¤ìŒ ì”¬ ì…ë ¥ì°½ í† ê¸€
        function toggleNextSceneInput() {
            const outcome = document.getElementById('choiceOutcome').value;
            const section = document.getElementById('nextSceneSection');
            if (section) {
                section.style.display = outcome === 'continue' ? 'block' : 'none';
            }
        }

        // ì—”ë”© í† ê¸€
        function toggleEnding(sceneNum) {
            const isEnding = document.getElementById('isEnding').checked;
            gameData[sceneNum].isEnding = isEnding;
            
            const choicesSection = document.getElementById('choicesSection');
            if (isEnding) {
                choicesSection.style.display = 'none';
                gameData[sceneNum].choices = [];
            } else {
                choicesSection.style.display = 'block';
            }
            
            updateUsedScenes();
            renderTree();
        }

        // ìë™ ì±„ë²ˆ
        function autoAssignNext(sceneNum, choiceIndex) {
            const nextScene = getNextAvailableScene();
            if (nextScene > 0) {
                document.getElementById(`choice-next-${choiceIndex}`).value = nextScene;
                updateStatus(`ì”¬ ${nextScene} ìë™ í• ë‹¹`);
            } else {
                alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        function autoAssignNextForChoice(sceneNum, choiceIndex) {
            const nextScene = getNextAvailableScene();
            if (nextScene > 0) {
                document.getElementById('choiceNext').value = nextScene;
                updateStatus(`ì”¬ ${nextScene} ìë™ í• ë‹¹`);
            } else {
                alert('ì‚¬ìš© ê°€ëŠ¥í•œ ì”¬ì´ ì—†ìŠµë‹ˆë‹¤');
            }
        }

        // ì”¬ ì €ì¥
        function saveScene(sceneNum) {
            const content = document.getElementById('sceneContent').value;
            const isEnding = document.getElementById('isEnding').checked;
            
            gameData[sceneNum].content = content;
            gameData[sceneNum].isEnding = isEnding;
            
            if (!isEnding) {
                gameData[sceneNum].choices.forEach((choice, index) => {
                    const textInput = document.getElementById(`choice-text-${index}`);
                    const nextInput = document.getElementById(`choice-next-${index}`);
                    const outcomeInput = document.getElementById(`choice-outcome-${index}`);
                    if (textInput) choice.text = textInput.value;
                    if (nextInput) choice.next = parseInt(nextInput.value) || 0;
                    if (outcomeInput) choice.outcome = outcomeInput.value;
                });
            }
            
            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('ì”¬ ' + sceneNum + ' ì €ì¥ë¨');
            
            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ì„ íƒì§€ ì €ì¥
        function saveChoice(sceneNum, choiceIndex) {
            const text = document.getElementById('choiceText').value;
            const outcomeEl = document.getElementById('choiceOutcome');
            const nextEl = document.getElementById('choiceNext');

            const outcome = outcomeEl ? outcomeEl.value : 'continue';
            const next = outcome === 'continue' ? (parseInt(nextEl?.value) || 0) : 0;

            gameData[sceneNum].choices[choiceIndex] = { text, next, outcome };

            updateUsedScenes();
            renderTree();
            saveToLocal();
            updateStatus('ì„ íƒì§€ ì €ì¥ë¨');

            if (isMobile) {
                setTimeout(() => switchTab('tree'), 500);
            }
        }

        // ì„ íƒì§€ ì¶”ê°€
        function addChoice(sceneNum) {
            if (gameData[sceneNum].choices.length < 3) {
                gameData[sceneNum].choices.push({ text: '', next: 0, outcome: 'continue' });
                showSceneEditor(sceneNum);
                updateStatus('ì„ íƒì§€ ì¶”ê°€ë¨');
            }
        }

        // ì„ íƒì§€ ì‚­ì œ
        function deleteChoice(sceneNum, choiceIndex) {
            if (confirm('ì„ íƒì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                gameData[sceneNum].choices.splice(choiceIndex, 1);
                updateUsedScenes();
                renderTree();
                if (selectedType === 'choice') {
                    showSceneEditor(sceneNum);
                }
                saveToLocal();
                updateStatus('ì„ íƒì§€ ì‚­ì œë¨');
            }
        }

        // ì”¬ ì‚­ì œ
        function deleteScene(sceneNum) {
            if (sceneNum === 1) {
                alert('ì”¬ 1ì€ ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            if (confirm(`ì”¬ ${sceneNum}ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                gameData[sceneNum] = {
                    content: '',
                    isEnding: false,
                    choices: []
                };
                updateUsedScenes();
                renderTree();
                document.getElementById('editor').innerHTML = '<div class="empty-state">íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>';
                saveToLocal();
                updateStatus('ì”¬ ' + sceneNum + ' ì‚­ì œë¨');
                
                if (isMobile) {
                    switchTab('tree');
                }
            }
        }

        // ë¡œì»¬ ì €ì¥
        function saveToLocal() {
            localStorage.setItem('gameTreeDataMobile', JSON.stringify(gameData));
        }

        // ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
        function loadFromLocal() {
            const saved = localStorage.getItem('gameTreeDataMobile');
            if (saved) {
                gameData = JSON.parse(saved);
                updateUsedScenes();
                renderTree();
                updateStatus('ë°ì´í„° ë¶ˆëŸ¬ì˜´');
            } else {
                updateStatus('ì €ì¥ëœ ë°ì´í„° ì—†ìŒ');
            }
        }

        // ì´ˆê¸°í™”
        function clearAll() {
            if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                init();
                document.getElementById('editor').innerHTML = '<div class="empty-state">íŠ¸ë¦¬ì—ì„œ ì”¬ì´ë‚˜ ì„ íƒì§€ë¥¼ íƒ­í•˜ì—¬ í¸ì§‘í•˜ì„¸ìš”</div>';
                saveToLocal();
                updateStatus('ì´ˆê¸°í™” ì™„ë£Œ');
            }
        }

        // game.html í˜¸í™˜ JSON ë‚´ë³´ë‚´ê¸°
        function exportJSON() {
            const story = convertToStoryFormat();
            const errors = validateStory(story);

            if (errors.length > 0) {
                alert('ìœ íš¨ì„± ê²€ì‚¬ ê²½ê³ :\n' + errors.join('\n') + '\n\në‚´ë³´ë‚´ê¸°ë¥¼ ê³„ì†í•©ë‹ˆë‹¤.');
            }

            const json = JSON.stringify(story, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${gameTitle.replace(/\s+/g, '-')}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('JSON íŒŒì¼ ìƒì„±ë¨ (game.html í˜¸í™˜)');
        }

        // ì—ë””í„° ë°ì´í„°ë¥¼ game.html STORY í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        function convertToStoryFormat() {
            const scenes = [];
            const sceneList = Array.from(usedSceneNumbers).sort((a, b) => a - b);

            sceneList.forEach(num => {
                const scene = gameData[num];
                if (!scene || (!scene.content && scene.choices.length === 0)) return;

                const sceneId = `S${String(num).padStart(3, '0')}`;
                const sceneObj = {
                    id: sceneId,
                    name: `ì”¬ ${num}`,
                    content: scene.content || '',
                    isEnding: scene.isEnding || false,
                    choices: []
                };

                if (scene.isEnding) {
                    sceneObj.endingInfo = {
                        code: `END-${num}`,
                        title: `ì—”ë”© ${num}`,
                        summary: scene.content || ''
                    };
                    // ì—”ë”© ì”¬ë„ ë¹ˆ ì„ íƒì§€ 2ê°œ í•„ìš” (game.html í˜•ì‹)
                    sceneObj.choices = [
                        { id: `C${String(num).padStart(3, '0')}A`, label: '', outcome: 'continue', nextSceneId: '' },
                        { id: `C${String(num).padStart(3, '0')}B`, label: '', outcome: 'continue', nextSceneId: '' }
                    ];
                } else {
                    // ì„ íƒì§€ ë³€í™˜ (ìµœëŒ€ 2ê°œë§Œ)
                    for (let i = 0; i < 2; i++) {
                        const choice = scene.choices[i];
                        const choiceId = `C${String(num).padStart(3, '0')}${i === 0 ? 'A' : 'B'}`;

                        if (choice && choice.text) {
                            const outcome = choice.outcome || 'continue';
                            let nextSceneId = '';

                            if (outcome === 'continue' && choice.next > 0) {
                                nextSceneId = `S${String(choice.next).padStart(3, '0')}`;
                            }

                            sceneObj.choices.push({
                                id: choiceId,
                                label: choice.text,
                                outcome: outcome,
                                nextSceneId: nextSceneId
                            });
                        } else {
                            // ë¹ˆ ì„ íƒì§€
                            sceneObj.choices.push({
                                id: choiceId,
                                label: '',
                                outcome: 'continue',
                                nextSceneId: ''
                            });
                        }
                    }
                }

                scenes.push(sceneObj);
            });

            return {
                title: gameTitle,
                startSceneId: 'S001',
                scenes: scenes
            };
        }

        // STORY í˜•ì‹ ìœ íš¨ì„± ê²€ì‚¬
        function validateStory(story) {
            const errors = [];

            if (!story.startSceneId) {
                errors.push('ì‹œì‘ ì”¬ IDê°€ ì—†ìŠµë‹ˆë‹¤.');
            } else if (!story.scenes.find(s => s.id === story.startSceneId)) {
                errors.push(`ì‹œì‘ ì”¬ ${story.startSceneId}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
            }

            story.scenes.forEach(scene => {
                if (!scene.choices || scene.choices.length !== 2) {
                    errors.push(`ì”¬ ${scene.id}: ì„ íƒì§€ê°€ ì •í™•íˆ 2ê°œì—¬ì•¼ í•©ë‹ˆë‹¤.`);
                }

                if (scene.choices) {
                    scene.choices.forEach((choice, idx) => {
                        if (choice.outcome === 'continue' && choice.label && !choice.nextSceneId) {
                            errors.push(`ì”¬ ${scene.id}, ì„ íƒì§€ ${idx + 1}: outcomeì´ 'continue'ì¸ë° nextSceneIdê°€ ì—†ìŠµë‹ˆë‹¤.`);
                        }

                        if (choice.outcome === 'continue' && choice.nextSceneId) {
                            if (!story.scenes.find(s => s.id === choice.nextSceneId)) {
                                errors.push(`ì”¬ ${scene.id}, ì„ íƒì§€ ${idx + 1}: nextSceneId ${choice.nextSceneId}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                            }
                        }
                    });
                }
            });

            return errors;
        }

        // JSON ê°€ì ¸ì˜¤ê¸°
        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const story = JSON.parse(event.target.result);
                        convertFromStoryFormat(story);
                        updateStatus('JSON íŒŒì¼ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ');
                    } catch (err) {
                        alert('JSON íŒŒì‹± ì‹¤íŒ¨: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // game.html STORY í˜•ì‹ì„ ì—ë””í„° í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        function convertFromStoryFormat(story) {
            if (story.title) {
                gameTitle = story.title;
            }

            // ê¸°ì¡´ ë°ì´í„° ì´ˆê¸°í™”
            init();

            if (story.scenes && Array.isArray(story.scenes)) {
                story.scenes.forEach(scene => {
                    // ì”¬ IDì—ì„œ ë²ˆí˜¸ ì¶”ì¶œ (S001 -> 1)
                    const match = scene.id.match(/S(\d+)/);
                    if (!match) return;

                    const num = parseInt(match[1]);
                    if (num < 1 || num > 1000) return;

                    gameData[num] = {
                        content: scene.content || '',
                        isEnding: scene.isEnding || false,
                        choices: []
                    };

                    if (!scene.isEnding && scene.choices) {
                        scene.choices.forEach(choice => {
                            if (choice.label) {
                                let nextNum = 0;
                                if (choice.nextSceneId) {
                                    const nextMatch = choice.nextSceneId.match(/S(\d+)/);
                                    if (nextMatch) {
                                        nextNum = parseInt(nextMatch[1]);
                                    }
                                }

                                gameData[num].choices.push({
                                    text: choice.label,
                                    next: nextNum,
                                    outcome: choice.outcome || 'continue'
                                });
                            }
                        });
                    }
                });
            }

            updateUsedScenes();
            renderTree();
            saveToLocal();
        }

        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message) {
            document.getElementById('statusMessage').textContent = message;
            updateStats();
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            const used = usedSceneNumbers.size;
            const available = 1000 - used;
            
            document.getElementById('usedScenes').textContent = used;
            document.getElementById('availableScenes').textContent = available;
        }

        // ì´ˆê¸°í™”
        window.onload = function() {
            const saved = localStorage.getItem('gameTreeDataMobile');
            if (saved) {
                gameData = JSON.parse(saved);
                updateUsedScenes();
                renderTree();
            } else {
                init();
            }

            // ë°ìŠ¤í¬í†±ì—ì„œëŠ” íŒ¨ë„ ëª¨ë‘ í‘œì‹œ
            if (!isMobile) {
                document.getElementById('treePanel').classList.add('active');
                document.getElementById('editorPanel').classList.add('active');
            }

            // ë¦¬ì‚¬ì´ì € ì´ˆê¸°í™”
            initResizer();

            // ìë™ ì €ì¥ íƒ€ì´ë¨¸ ì‹œì‘
            startAutoSave();
        };

        // í˜ì´ì§€ë¥¼ ë– ë‚  ë•Œ ì €ì¥
        window.onbeforeunload = function() {
            autoSaveCurrentEdit();
        };

        // íƒ­ì´ ë¹„í™œì„±í™”ë  ë•Œë„ ì €ì¥ (ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ìš©)
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                autoSaveCurrentEdit();
            }
        });
    </script>
</body>
</html>
