<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catch! Love â€” Editor</title>
  <style>
    /* ==================== Styles ==================== */
    :root {
      --color-1: #cccccc;
      --color-2: #999999;
      --color-3: #f5f5f5;
      --color-4: #666666;
      --color-5: #333333;
      --color-success: #555555;
      --color-failure: #777777;
      --shadow: 0 1px 2px rgba(0,0,0,0.05);
      --radius: 2px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #fafafa;
      min-height: 100vh;
      padding: 0;
      color: #333;
    }

    /* TopBar */
    .topbar {
      background: #e0e0e0;
      color: #333;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .topbar h1 {
      font-size: 1.5rem;
      margin-right: auto;
      font-weight: 600;
    }

    .topbar button, .topbar select, .topbar input[type="file"] {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .topbar button:hover {
      background: var(--color-3);
    }

    .topbar select {
      min-width: 150px;
    }

    /* Main Layout */
    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 1rem;
      max-width: 1800px;
      margin: 0 auto;
    }

    @media (min-width: 1024px) {
      .container {
        grid-template-columns: 30% 70%;
        padding: 1.5rem;
      }
    }

    /* Card Base */
    .card {
      background: white;
      border-radius: var(--radius);
      padding: 1.5rem;
      border: 1px solid #ddd;
    }

    /* Scene List */
    .scene-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .scene-list-header {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #ddd;
    }

    .scene-list-header input {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .scene-list-header select {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.9rem;
    }

    .scene-item {
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .scene-item:hover {
      border-color: var(--color-4);
    }

    .scene-item.active {
      border-color: var(--color-5);
      background: var(--color-3);
    }

    .scene-item.archived {
      opacity: 0.5;
      background: #f5f5f5;
    }

    .scene-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .scene-item-id {
      font-weight: 700;
      color: var(--color-5);
      font-size: 0.85rem;
    }

    .scene-item-name {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .scene-item-badges {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .badge {
      padding: 0.25rem 0.5rem;
      border-radius: 2px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-ending {
      background: var(--color-4);
      color: white;
    }

    .badge-archived {
      background: #999;
      color: white;
    }

    .badge-success {
      background: var(--color-success);
      color: white;
    }

    .badge-failure {
      background: var(--color-failure);
      color: white;
    }

    .scene-item-choices {
      font-size: 0.8rem;
      color: #666;
      line-height: 1.4;
    }

    .scene-item-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .scene-item-actions button {
      padding: 0.25rem 0.75rem;
      border: 1px solid #999;
      border-radius: 2px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-delete {
      background: #888;
      color: white;
      border-color: #888;
    }

    .btn-archive {
      background: #999;
      color: white;
      border-color: #999;
    }

    .btn-unarchive {
      background: var(--color-1);
      color: #333;
      border-color: var(--color-1);
    }

    /* Right Panel */
    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Scene Editor */
    .scene-editor h2 {
      color: var(--color-5);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ddd;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .form-group input[type="text"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-family: inherit;
    }

    .form-group textarea {
      min-height: 120px;
      resize: vertical;
    }

    .form-group input[type="checkbox"],
    .form-group input[type="radio"] {
      width: auto;
      margin-right: 0.5rem;
    }

    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--color-5);
    }

    .form-group input:read-only {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
    }

    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .radio-option {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      border-radius: 2px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .radio-option:hover {
      background: var(--color-3);
    }

    .radio-option label {
      cursor: pointer;
      margin-bottom: 0 !important;
      font-weight: normal !important;
    }

    .ending-info {
      background: var(--color-3);
      padding: 1rem;
      border-radius: var(--radius);
      margin-top: 0.5rem;
      border: 1px solid #ddd;
    }

    .choices-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }

    @media (min-width: 768px) {
      .choices-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .choice-card {
      border: 1px solid #ccc;
      border-radius: var(--radius);
      padding: 1rem;
      background: #fafafa;
    }

    .choice-card h4 {
      color: var(--color-5);
      margin-bottom: 0.75rem;
    }

    .choice-type-scene {
      margin-top: 0.5rem;
    }

    /* Player */
    .player {
      background: #e8e8e8;
      color: #333;
      min-height: 400px;
      border: 1px solid #ccc;
    }

    .player h2 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ccc;
    }

    .player-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
    }

    .player-controls button {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .player-controls button:hover {
      background: var(--color-3);
    }

    .player-breadcrumb {
      background: #d0d0d0;
      padding: 0.75rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      font-size: 0.85rem;
      word-break: break-all;
      border: 1px solid #bbb;
    }

    .player-scene {
      background: white;
      color: #333;
      padding: 1.5rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      border: 1px solid #ccc;
    }

    .player-scene-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .player-scene-content {
      line-height: 1.8;
      margin-bottom: 1.5rem;
      white-space: pre-wrap;
    }

    .player-choices {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .player-choice-btn {
      padding: 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.2s;
      text-align: left;
    }

    .player-choice-btn:hover:not(:disabled) {
      background: var(--color-3);
    }

    .player-choice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .player-ending {
      text-align: center;
      padding: 2rem;
      border-radius: var(--radius);
      color: #333;
      border: 1px solid #999;
    }

    .player-ending.success {
      background: #d0d0d0;
    }

    .player-ending.failure {
      background: #c0c0c0;
    }

    .player-ending.normal {
      background: #e0e0e0;
    }

    .player-ending h3 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .player-ending-code {
      font-size: 0.9rem;
      opacity: 0.9;
      margin-bottom: 0.5rem;
    }

    .player-ending-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .player-ending-summary {
      line-height: 1.6;
      opacity: 0.95;
    }

    /* Validation Panel */
    .validation-panel {
      background: white;
      border: 1px solid #999;
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .validation-panel h3 {
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .validation-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 2px;
      border-left: 3px solid;
    }

    .validation-item.error {
      background: #eeeeee;
      border-color: #888;
    }

    .validation-item.warning {
      background: #f5f5f5;
      border-color: #aaa;
    }

    .validation-item.success {
      background: #f0f0f0;
      border-color: #666;
    }

    .hidden {
      display: none;
    }

    /* Story Flow Visualizer */
    .story-flow {
      background: white;
      color: #333;
      min-height: 400px;
      border: 1px solid #ccc;
    }

    .story-flow h2 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ccc;
    }

    .flow-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .flow-controls button {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .flow-controls button:hover {
      background: var(--color-3);
    }

    .flow-tree {
      font-family: monospace;
      font-size: 0.85rem;
      line-height: 1.8;
      overflow-x: auto;
      padding: 1rem;
      background: #fafafa;
      border: 1px solid #ddd;
      border-radius: var(--radius);
    }

    .flow-node {
      cursor: pointer;
      padding: 0.15rem 0.5rem;
      border-radius: 2px;
      display: inline-block;
      margin: 0.15rem 0;
    }

    .flow-node:hover {
      background: #e0e0e0;
    }

    .flow-node.start {
      font-weight: 700;
      color: var(--color-5);
    }

    .flow-node.ending {
      color: var(--color-4);
      font-weight: 600;
    }

    .flow-node.success-choice {
      color: var(--color-success);
    }

    .flow-node.failure-choice {
      color: var(--color-failure);
    }

    .flow-stats {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--color-3);
      border: 1px solid #ddd;
      border-radius: var(--radius);
    }

    .flow-stats h3 {
      font-size: 1rem;
      margin-bottom: 0.75rem;
      color: var(--color-5);
    }

    .flow-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .flow-stat-item {
      padding: 0.75rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: var(--radius);
    }

    .flow-stat-label {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 0.25rem;
    }

    .flow-stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-5);
    }
  </style>
</head>
<body>
  <!-- ==================== Layout ==================== -->

  <!-- TopBar -->
  <div class="topbar">
    <h1>Catch! Love â€” Editor</h1>
    <button id="btn-add-scene" aria-label="ìƒˆ ì”¬ ì¶”ê°€">â• ìƒˆ ì”¬</button>
    <button id="btn-generate-template" aria-label="ì¶”ì²œ í…œí”Œë¦¿ ìƒì„±">ğŸ“‹ ì¶”ì²œ êµ¬ì¡° ìƒì„±</button>
    <select id="select-start-scene" aria-label="ì‹œì‘ ì”¬ ì„ íƒ">
      <option value="">ì‹œì‘ ì”¬ ì„ íƒ</option>
    </select>
    <button id="btn-validate" aria-label="ìœ íš¨ì„± ê²€ì‚¬">âœ“ ê²€ì‚¬</button>
    <button id="btn-export" aria-label="JSON ë‚´ë³´ë‚´ê¸°">ğŸ’¾ ë‚´ë³´ë‚´ê¸°</button>
    <label style="padding: 0.5rem 1rem; background: white; border-radius: var(--radius); cursor: pointer; font-weight: 500; border: 1px solid #999;">
      ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°
      <input type="file" id="input-import" accept=".json" style="display: none;" aria-label="JSON ë¶ˆëŸ¬ì˜¤ê¸°">
    </label>
    <button id="btn-play" aria-label="í”Œë ˆì´ ëª¨ë“œ ì‹œì‘">â–¶ í”Œë ˆì´</button>
    <button id="btn-toggle-flow" aria-label="ìŠ¤í† ë¦¬ êµ¬ì¡° ë³´ê¸°">ğŸ—ºï¸ ìŠ¤í† ë¦¬ êµ¬ì¡°</button>
  </div>

  <!-- Main Container -->
  <div class="container">
    <!-- Left Panel: Scene List -->
    <div class="card scene-list">
      <div class="scene-list-header">
        <h2 style="color: var(--color-5);">ì”¬ ëª©ë¡</h2>
        <input type="text" id="search-scene" placeholder="ğŸ” ê²€ìƒ‰ (ì´ë¦„/ID)" aria-label="ì”¬ ê²€ìƒ‰">
        <select id="sort-scene" aria-label="ì”¬ ì •ë ¬">
          <option value="created">ìƒì„±ìˆœ</option>
          <option value="id">IDìˆœ</option>
        </select>
      </div>
      <div id="scene-list-items">
        <!-- Scene items will be rendered here -->
      </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <!-- Scene Editor -->
      <div class="card scene-editor">
        <h2>ì”¬ ì—ë””í„°</h2>
        <div id="editor-content">
          <p style="color: #999; text-align: center; padding: 2rem;">ì¢Œì¸¡ì—ì„œ ì”¬ì„ ì„ íƒí•˜ì„¸ìš”</p>
        </div>
      </div>

      <!-- Player Preview -->
      <div class="card player">
        <h2>í”Œë ˆì´ì–´ ë¯¸ë¦¬ë³´ê¸°</h2>
        <div class="player-controls">
          <button id="btn-player-start">ì‹œì‘</button>
          <button id="btn-player-restart">ì¬ì‹œì‘</button>
        </div>
        <div id="player-content">
          <p style="opacity: 0.8;">'ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ í”Œë ˆì´ë¥¼ ì‹œì‘í•˜ì„¸ìš”</p>
        </div>
      </div>

      <!-- Story Flow Visualizer -->
      <div id="story-flow-panel" class="card story-flow hidden">
        <h2>ìŠ¤í† ë¦¬ êµ¬ì¡°</h2>
        <div class="flow-controls">
          <button id="btn-refresh-flow">ìƒˆë¡œê³ ì¹¨</button>
          <button id="btn-expand-all">ì „ì²´ í¼ì¹˜ê¸°</button>
        </div>
        <div id="flow-content">
          <p style="color: #999; text-align: center; padding: 2rem;">ìŠ¤í† ë¦¬ êµ¬ì¡°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
        </div>
      </div>

      <!-- Validation Panel (hidden by default) -->
      <div id="validation-panel" class="validation-panel hidden">
        <h3>ìœ íš¨ì„± ê²€ì‚¬ ê²°ê³¼</h3>
        <div id="validation-results"></div>
      </div>
    </div>
  </div>

  <script>
    // ==================== State ====================

    let game = {
      id: 'game-001',
      title: 'Catch! Love',
      palette: ['#A1C3D1', '#B39BC8', '#F0EBF4', '#F172A1', '#E64398'],
      startSceneId: 'S001',
      scenes: [],
      createdAt: nowISO(),
      updatedAt: nowISO(),
      version: 1
    };

    let currentSceneId = null; // Currently selected scene in editor
    let playerSceneId = null;  // Current scene in player
    let playerPath = [];       // Breadcrumb trail

    // ==================== Utils ====================

    function nowISO() {
      return new Date().toISOString();
    }

    function byId(id) {
      return document.getElementById(id);
    }

    function getNextSceneNumber() {
      if (game.scenes.length === 0) return 1;
      const numbers = game.scenes.map(s => {
        const match = s.id.match(/^S(\d+)$/);
        return match ? parseInt(match[1], 10) : 0;
      });
      return Math.max(...numbers) + 1;
    }

    function generateSceneId() {
      const num = getNextSceneNumber();
      return 'S' + String(num).padStart(3, '0');
    }

    function generateChoiceIds(sceneId) {
      return [sceneId.replace('S', 'C') + 'A', sceneId.replace('S', 'C') + 'B'];
    }

    function findScene(sceneId) {
      return game.scenes.find(s => s.id === sceneId);
    }

    function ensureTwo(arr) {
      while (arr.length < 2) {
        arr.push({ id: '', label: '', type: 'scene', nextSceneId: '', note: '' });
      }
      return arr.slice(0, 2);
    }

    function getChoiceDisplay(choice) {
      if (choice.type === 'success') {
        return '[ì„±ê³µ ì—”ë”©]';
      } else if (choice.type === 'failure') {
        return '[ì‹¤íŒ¨ ì—”ë”©]';
      } else {
        return choice.nextSceneId || '?';
      }
    }

    // ==================== Template Generator ====================

    function generateTemplateStory() {
      if (game.scenes.length > 0) {
        if (!confirm('í˜„ì¬ ì”¬ë“¤ì´ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          return;
        }
      }

      const scenes = [];
      const timestamp = nowISO();

      // ì‹œì‘ ì”¬ (1ê°œ)
      scenes.push({
        id: 'S001',
        name: 'ì‹œì‘',
        isEnding: false,
        content: 'TODO: ì‹œì‘ ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš” (3-4ë¬¸ì¥)',
        choices: [
          { id: 'C001A', label: 'TODO: ì„ íƒì§€ A', type: 'scene', nextSceneId: 'S002', note: '' },
          { id: 'C001B', label: 'TODO: ì„ íƒì§€ B', type: 'scene', nextSceneId: 'S003', note: '' }
        ],
        createdAt: timestamp,
        updatedAt: timestamp,
        isArchived: false
      });

      // ì´ˆë°˜ ì”¬ (3ê°œ)
      for (let i = 2; i <= 4; i++) {
        const id = `S00${i}`;
        const nextA = i === 2 ? 'S005' : i === 3 ? 'S006' : 'S007';
        const nextB = i === 2 ? 'S006' : i === 3 ? 'S007' : 'S008';

        scenes.push({
          id,
          name: `ì´ˆë°˜ ì”¬ ${i-1}`,
          isEnding: false,
          content: `TODO: ì´ˆë°˜ ì”¬ ${i-1} ë‚´ìš© (3-4ë¬¸ì¥)`,
          choices: [
            { id: `C00${i}A`, label: 'TODO: ì„ íƒì§€ A', type: 'scene', nextSceneId: nextA, note: '' },
            { id: `C00${i}B`, label: 'TODO: ì„ íƒì§€ B', type: 'scene', nextSceneId: nextB, note: '' }
          ],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      // ì¤‘ë°˜ ë¶„ê¸° ì”¬ (12ê°œ: S005-S016)
      for (let i = 5; i <= 16; i++) {
        const id = `S0${String(i).padStart(2, '0')}`;
        const num = i - 4;
        const nextA = i <= 14 ? `S0${String(i + 2).padStart(2, '0')}` : 'S017';
        const nextB = i <= 14 ? `S0${String(i + 3).padStart(2, '0')}` : 'S018';

        scenes.push({
          id,
          name: `ì¤‘ë°˜ ì”¬ ${num}`,
          isEnding: false,
          content: `TODO: ì¤‘ë°˜ ì”¬ ${num} ë‚´ìš© (3-4ë¬¸ì¥)`,
          choices: [
            { id: `C0${String(i).padStart(2, '0')}A`, label: 'TODO: ì„ íƒì§€ A', type: 'scene', nextSceneId: nextA, note: '' },
            { id: `C0${String(i).padStart(2, '0')}B`, label: 'TODO: ì„ íƒì§€ B', type: 'scene', nextSceneId: nextB, note: '' }
          ],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      // í›„ë°˜ ì”¬ (9ê°œ: S017-S025)
      for (let i = 17; i <= 25; i++) {
        const id = `S0${i}`;
        const num = i - 16;
        let nextA, nextB, typeA = 'scene', typeB = 'scene';

        if (i <= 23) {
          nextA = `S0${i + 1}`;
          nextB = `S0${i + 2}`;
        } else if (i === 24) {
          typeA = 'success';
          typeB = 'failure';
          nextA = '';
          nextB = '';
        } else {
          typeA = 'success';
          typeB = 'failure';
          nextA = '';
          nextB = '';
        }

        scenes.push({
          id,
          name: `í›„ë°˜ ì”¬ ${num}`,
          isEnding: false,
          content: `TODO: í›„ë°˜ ì”¬ ${num} ë‚´ìš© (3-4ë¬¸ì¥)`,
          choices: [
            { id: `C0${i}A`, label: 'TODO: ì„ íƒì§€ A', type: typeA, nextSceneId: nextA, note: '' },
            { id: `C0${i}B`, label: 'TODO: ì„ íƒì§€ B', type: typeB, nextSceneId: nextB, note: '' }
          ],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      // ì—”ë”© ì”¬ (5ê°œ: S026-S030)
      const endings = [
        { code: 'END-SUCCESS-1', title: 'ì§„ì •í•œ ì‚¬ë‘', summary: 'ì„±ê³µ ì—”ë”© 1' },
        { code: 'END-SUCCESS-2', title: 'í–‰ë³µí•œ ê²°ë§', summary: 'ì„±ê³µ ì—”ë”© 2' },
        { code: 'END-FAILURE-1', title: 'ë†“ì¹œ ê¸°íšŒ', summary: 'ì‹¤íŒ¨ ì—”ë”© 1' },
        { code: 'END-FAILURE-2', title: 'ì“´ ì´ë³„', summary: 'ì‹¤íŒ¨ ì—”ë”© 2' },
        { code: 'END-NEUTRAL', title: 'ìƒˆë¡œìš´ ì‹œì‘', summary: 'ì¤‘ë¦½ ì—”ë”©' }
      ];

      for (let i = 0; i < 5; i++) {
        const sceneNum = 26 + i;
        const id = `S0${sceneNum}`;

        scenes.push({
          id,
          name: endings[i].title,
          isEnding: true,
          endingInfo: endings[i],
          content: `TODO: ${endings[i].title} ì—”ë”© ë‚´ìš© (3-4ë¬¸ì¥)`,
          choices: [
            { id: `C0${sceneNum}A`, label: '', type: 'scene', nextSceneId: '', note: '' },
            { id: `C0${sceneNum}B`, label: '', type: 'scene', nextSceneId: '', note: '' }
          ],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      game.scenes = scenes;
      game.startSceneId = 'S001';
      game.updatedAt = timestamp;

      currentSceneId = null;

      renderSceneList();
      renderEditor();
      refreshStartSelect();
      renderStoryFlow();

      alert(`ì¶”ì²œ êµ¬ì¡° í…œí”Œë¦¿ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì´ ${scenes.length}ê°œ ì”¬:\n- ì‹œì‘: 1ê°œ\n- ì´ˆë°˜: 3ê°œ\n- ì¤‘ë°˜: 12ê°œ\n- í›„ë°˜: 9ê°œ\n- ì—”ë”©: 5ê°œ\n\nì´ì œ ê° ì”¬ì˜ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”.`);
    }

    // ==================== Story Flow Visualizer ====================

    function renderStoryFlow() {
      const container = byId('flow-content');

      if (game.scenes.length === 0) {
        container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">ì”¬ì´ ì—†ìŠµë‹ˆë‹¤. ì”¬ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì¶”ì²œ êµ¬ì¡°ë¥¼ ìƒì„±í•˜ì„¸ìš”.</p>';
        return;
      }

      // Build tree structure
      let html = '<div class="flow-tree">';

      const startScene = findScene(game.startSceneId);
      if (!startScene) {
        html += '<p style="color: #888;">ì‹œì‘ ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
      } else {
        const visited = new Set();
        html += buildFlowTree(startScene, '', visited, 0);
      }

      html += '</div>';

      // Add statistics
      const stats = calculateFlowStats();
      html += `
        <div class="flow-stats">
          <h3>ìŠ¤í† ë¦¬ í†µê³„</h3>
          <div class="flow-stats-grid">
            <div class="flow-stat-item">
              <div class="flow-stat-label">ì´ ì”¬ ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.totalScenes}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ì—”ë”© ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.endings}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ìµœëŒ€ ê¹Šì´</div>
              <div class="flow-stat-value">${stats.maxDepth}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">í‰ê·  í”Œë ˆì´ ê¸¸ì´</div>
              <div class="flow-stat-value">${stats.avgPath}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ë¶„ê¸°ì  ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.branches}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ë„ë‹¬ ë¶ˆê°€ëŠ¥</div>
              <div class="flow-stat-value">${stats.unreachable}</div>
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;

      // Attach click handlers
      container.querySelectorAll('.flow-node').forEach(node => {
        node.addEventListener('click', () => {
          const sceneId = node.dataset.sceneId;
          if (sceneId) {
            currentSceneId = sceneId;
            renderSceneList();
            renderEditor();
            // Scroll to editor
            byId('editor-content').scrollIntoView({ behavior: 'smooth' });
          }
        });
      });
    }

    function buildFlowTree(scene, prefix, visited, depth) {
      if (!scene || visited.has(scene.id)) {
        return '';
      }

      visited.add(scene.id);

      const isStart = scene.id === game.startSceneId;
      const classes = ['flow-node'];
      if (isStart) classes.push('start');
      if (scene.isEnding) classes.push('ending');

      let html = `${prefix}<span class="${classes.join(' ')}" data-scene-id="${scene.id}">${scene.id}: ${scene.name}</span>\n`;

      if (scene.isEnding) {
        return html;
      }

      const choices = ensureTwo(scene.choices || []);

      choices.forEach((choice, idx) => {
        const isLast = idx === choices.length - 1;
        const choicePrefix = isLast ? 'â””â”€' : 'â”œâ”€';
        const nextPrefix = isLast ? '   ' : 'â”‚  ';

        const choiceClasses = ['flow-node'];
        if (choice.type === 'success') choiceClasses.push('success-choice');
        if (choice.type === 'failure') choiceClasses.push('failure-choice');

        const label = choice.label || `ì„ íƒì§€ ${String.fromCharCode(65 + idx)}`;
        html += `${prefix}${choicePrefix} <span class="${choiceClasses.join(' ')}">[${String.fromCharCode(65 + idx)}] ${label}</span>`;

        if (choice.type === 'success') {
          html += ' â†’ <span class="flow-node success-choice">[ì„±ê³µ ì—”ë”©]</span>\n';
        } else if (choice.type === 'failure') {
          html += ' â†’ <span class="flow-node failure-choice">[ì‹¤íŒ¨ ì—”ë”©]</span>\n';
        } else if (choice.nextSceneId) {
          const nextScene = findScene(choice.nextSceneId);
          if (nextScene) {
            html += '\n';
            if (visited.has(nextScene.id)) {
              html += `${prefix}${nextPrefix}<span class="flow-node" data-scene-id="${nextScene.id}">â¤´ ${nextScene.id} (ìˆœí™˜ ì°¸ì¡°)</span>\n`;
            } else {
              html += buildFlowTree(nextScene, prefix + nextPrefix, visited, depth + 1);
            }
          } else {
            html += ` â†’ <span style="color: #888;">[ì”¬ ì—†ìŒ: ${choice.nextSceneId}]</span>\n`;
          }
        } else {
          html += ' â†’ <span style="color: #888;">[ì—°ê²° ì•ˆë¨]</span>\n';
        }
      });

      return html;
    }

    function calculateFlowStats() {
      const stats = {
        totalScenes: game.scenes.length,
        endings: game.scenes.filter(s => s.isEnding).length,
        maxDepth: 0,
        avgPath: 0,
        branches: 0,
        unreachable: 0
      };

      // Calculate reachable scenes
      if (game.startSceneId && findScene(game.startSceneId)) {
        const reachable = new Set();
        const queue = [{ id: game.startSceneId, depth: 0 }];
        let totalDepth = 0;
        let pathCount = 0;

        while (queue.length > 0) {
          const { id, depth } = queue.shift();
          if (reachable.has(id)) continue;
          reachable.add(id);

          stats.maxDepth = Math.max(stats.maxDepth, depth);

          const scene = findScene(id);
          if (!scene) continue;

          if (scene.isEnding) {
            totalDepth += depth;
            pathCount++;
          }

          const choices = ensureTwo(scene.choices || []);
          let validChoices = 0;

          choices.forEach(c => {
            const type = c.type || 'scene';
            if (type === 'scene' && c.nextSceneId) {
              validChoices++;
              if (!reachable.has(c.nextSceneId)) {
                queue.push({ id: c.nextSceneId, depth: depth + 1 });
              }
            } else if (type === 'success' || type === 'failure') {
              totalDepth += depth + 1;
              pathCount++;
            }
          });

          if (validChoices >= 2) {
            stats.branches++;
          }
        }

        stats.unreachable = game.scenes.length - reachable.size;
        stats.avgPath = pathCount > 0 ? Math.round(totalDepth / pathCount) : 0;
      }

      return stats;
    }

    // ==================== Renderers ====================

    function renderSceneList() {
      const container = byId('scene-list-items');
      const searchTerm = byId('search-scene').value.toLowerCase();
      const sortBy = byId('sort-scene').value;

      let filtered = game.scenes.filter(s => {
        if (searchTerm === '') return true;
        return s.id.toLowerCase().includes(searchTerm) ||
               s.name.toLowerCase().includes(searchTerm);
      });

      if (sortBy === 'id') {
        filtered.sort((a, b) => a.id.localeCompare(b.id));
      } else {
        filtered.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
      }

      container.innerHTML = '';

      filtered.forEach(scene => {
        const div = document.createElement('div');
        div.className = 'scene-item';
        if (scene.id === currentSceneId) div.classList.add('active');
        if (scene.isArchived) div.classList.add('archived');

        let badges = '';
        if (scene.isEnding) {
          badges += '<span class="badge badge-ending">ENDING</span>';
        }
        if (scene.isArchived) {
          badges += '<span class="badge badge-archived">ë³´ê´€ë¨</span>';
        }

        const choices = ensureTwo(scene.choices || []);
        const choiceA = choices[0];
        const choiceB = choices[1];

        const choiceText = `A: ${choiceA.label || '(ì—†ìŒ)'} â†’ ${getChoiceDisplay(choiceA)}<br>B: ${choiceB.label || '(ì—†ìŒ)'} â†’ ${getChoiceDisplay(choiceB)}`;

        div.innerHTML = `
          <div class="scene-item-header">
            <span class="scene-item-id">${scene.id}</span>
          </div>
          <div class="scene-item-name">${scene.name || '(ì´ë¦„ ì—†ìŒ)'}</div>
          ${badges ? `<div class="scene-item-badges">${badges}</div>` : ''}
          <div class="scene-item-choices">${choiceText}</div>
          <div class="scene-item-actions">
            <button class="btn-delete" data-id="${scene.id}">ì‚­ì œ</button>
            ${scene.isArchived
              ? `<button class="btn-unarchive" data-id="${scene.id}">ë³µì›</button>`
              : `<button class="btn-archive" data-id="${scene.id}">ë³´ê´€</button>`
            }
          </div>
        `;

        div.addEventListener('click', (e) => {
          if (e.target.tagName === 'BUTTON') return;
          currentSceneId = scene.id;
          renderSceneList();
          renderEditor();
        });

        container.appendChild(div);
      });

      // Attach action handlers
      container.querySelectorAll('.btn-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteScene(btn.dataset.id);
        });
      });

      container.querySelectorAll('.btn-archive').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleArchive(btn.dataset.id, true);
        });
      });

      container.querySelectorAll('.btn-unarchive').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleArchive(btn.dataset.id, false);
        });
      });
    }

    function renderEditor() {
      const container = byId('editor-content');

      if (!currentSceneId) {
        container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">ì¢Œì¸¡ì—ì„œ ì”¬ì„ ì„ íƒí•˜ì„¸ìš”</p>';
        return;
      }

      const scene = findScene(currentSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #888; text-align: center; padding: 2rem;">ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>';
        return;
      }

      const choices = ensureTwo(scene.choices || []);
      const choiceA = choices[0];
      const choiceB = choices[1];

      const sceneOptions = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceA.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      const sceneOptionsB = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceB.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      container.innerHTML = `
        <div class="form-group">
          <label>ì”¬ ID</label>
          <input type="text" id="edit-id" value="${scene.id}" readonly>
        </div>

        <div class="form-group">
          <label>ì”¬ ì´ë¦„</label>
          <input type="text" id="edit-name" value="${scene.name || ''}">
        </div>

        <div class="form-group">
          <div class="checkbox-group">
            <input type="checkbox" id="edit-is-ending" ${scene.isEnding ? 'checked' : ''}>
            <label for="edit-is-ending">ì—”ë”© ì”¬ìœ¼ë¡œ ì„¤ì •</label>
          </div>
        </div>

        <div id="ending-info-container" class="${scene.isEnding ? '' : 'hidden'}">
          <div class="ending-info">
            <div class="form-group">
              <label>ì—”ë”© ì½”ë“œ</label>
              <input type="text" id="edit-ending-code" value="${scene.endingInfo?.code || ''}">
            </div>
            <div class="form-group">
              <label>ì—”ë”© íƒ€ì´í‹€</label>
              <input type="text" id="edit-ending-title" value="${scene.endingInfo?.title || ''}">
            </div>
            <div class="form-group">
              <label>ì—”ë”© ìš”ì•½</label>
              <textarea id="edit-ending-summary">${scene.endingInfo?.summary || ''}</textarea>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>ì”¬ ë³¸ë¬¸</label>
          <textarea id="edit-content">${scene.content || ''}</textarea>
        </div>

        <h3 style="color: var(--color-5); margin: 1.5rem 0 1rem;">ì„ íƒì§€</h3>
        <div class="choices-container">
          <div class="choice-card">
            <h4>ì„ íƒì§€ A</h4>
            <div class="form-group">
              <label>ë¼ë²¨</label>
              <input type="text" id="edit-choice-a-label" value="${choiceA.label || ''}">
            </div>
            <div class="form-group">
              <label>íƒ€ì…</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-scene" name="choice-a-type" value="scene" ${(choiceA.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-scene">ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-success" name="choice-a-type" value="success" ${choiceA.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-success">ì„±ê³µ ì—”ë”©</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-failure" name="choice-a-type" value="failure" ${choiceA.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-failure">ì‹¤íŒ¨ ì—”ë”©</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-a-scene-select" ${(choiceA.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>ë‹¤ìŒ ì”¬</label>
              <select id="edit-choice-a-next">
                <option value="">ì„ íƒ ì•ˆí•¨</option>
                ${sceneOptions}
              </select>
            </div>
            <div class="form-group">
              <label>ë©”ëª¨ (ì„ íƒ)</label>
              <input type="text" id="edit-choice-a-note" value="${choiceA.note || ''}">
            </div>
          </div>

          <div class="choice-card">
            <h4>ì„ íƒì§€ B</h4>
            <div class="form-group">
              <label>ë¼ë²¨</label>
              <input type="text" id="edit-choice-b-label" value="${choiceB.label || ''}">
            </div>
            <div class="form-group">
              <label>íƒ€ì…</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-scene" name="choice-b-type" value="scene" ${(choiceB.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-scene">ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-success" name="choice-b-type" value="success" ${choiceB.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-success">ì„±ê³µ ì—”ë”©</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-failure" name="choice-b-type" value="failure" ${choiceB.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-failure">ì‹¤íŒ¨ ì—”ë”©</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-b-scene-select" ${(choiceB.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>ë‹¤ìŒ ì”¬</label>
              <select id="edit-choice-b-next">
                <option value="">ì„ íƒ ì•ˆí•¨</option>
                ${sceneOptionsB}
              </select>
            </div>
            <div class="form-group">
              <label>ë©”ëª¨ (ì„ íƒ)</label>
              <input type="text" id="edit-choice-b-note" value="${choiceB.note || ''}">
            </div>
          </div>
        </div>
      `;

      // Attach event listeners
      byId('edit-name').addEventListener('input', updateScene);
      byId('edit-is-ending').addEventListener('change', updateScene);
      byId('edit-content').addEventListener('input', updateScene);

      if (scene.isEnding) {
        byId('edit-ending-code').addEventListener('input', updateScene);
        byId('edit-ending-title').addEventListener('input', updateScene);
        byId('edit-ending-summary').addEventListener('input', updateScene);
      }

      byId('edit-choice-a-label').addEventListener('input', updateScene);
      byId('edit-choice-a-next').addEventListener('change', updateScene);
      byId('edit-choice-a-note').addEventListener('input', updateScene);
      byId('edit-choice-b-label').addEventListener('input', updateScene);
      byId('edit-choice-b-next').addEventListener('change', updateScene);
      byId('edit-choice-b-note').addEventListener('input', updateScene);

      // Choice type handlers
      ['a', 'b'].forEach(choice => {
        ['scene', 'success', 'failure'].forEach(type => {
          const radio = byId(`edit-choice-${choice}-type-${type}`);
          if (radio) {
            radio.addEventListener('change', () => {
              const sceneSelect = byId(`choice-${choice}-scene-select`);
              if (type === 'scene') {
                sceneSelect.style.display = 'block';
              } else {
                sceneSelect.style.display = 'none';
              }
              updateScene();
            });
          }
        });
      });
    }

    function renderPlayer() {
      const container = byId('player-content');

      if (!playerSceneId) {
        container.innerHTML = '<p style="opacity: 0.8;">\'ì‹œì‘\' ë²„íŠ¼ì„ ëˆŒëŸ¬ í”Œë ˆì´ë¥¼ ì‹œì‘í•˜ì„¸ìš”</p>';
        return;
      }

      // Check if it's a special ending
      if (playerSceneId === '__SUCCESS__' || playerSceneId === '__FAILURE__') {
        const endingType = playerSceneId === '__SUCCESS__' ? 'success' : 'failure';
        const endingTitle = playerSceneId === '__SUCCESS__' ? 'ì„±ê³µ ì—”ë”©' : 'ì‹¤íŒ¨ ì—”ë”©';
        const breadcrumb = playerPath.length > 0
          ? `<div class="player-breadcrumb">ê²½ë¡œ: ${playerPath.join(' â†’ ')}</div>`
          : '';

        container.innerHTML = `
          ${breadcrumb}
          <div class="player-ending ${endingType}">
            <h3>THE END</h3>
            <div class="player-ending-title">${endingTitle}</div>
          </div>
        `;
        return;
      }

      const scene = findScene(playerSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #888;">ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + playerSceneId + '</p>';
        return;
      }

      // Breadcrumb
      const breadcrumb = playerPath.length > 0
        ? `<div class="player-breadcrumb">ê²½ë¡œ: ${playerPath.join(' â†’ ')}</div>`
        : '';

      // Scene display
      let sceneHTML = `
        ${breadcrumb}
        <div class="player-scene">
          <div class="player-scene-name">${scene.name || '(ì´ë¦„ ì—†ìŒ)'}</div>
          <div class="player-scene-content">${scene.content || ''}</div>
        </div>
      `;

      if (scene.isEnding) {
        // Ending display
        sceneHTML += `
          <div class="player-ending normal">
            <h3>THE END</h3>
            ${scene.endingInfo?.code ? `<div class="player-ending-code">CODE: ${scene.endingInfo.code}</div>` : ''}
            ${scene.endingInfo?.title ? `<div class="player-ending-title">${scene.endingInfo.title}</div>` : ''}
            ${scene.endingInfo?.summary ? `<div class="player-ending-summary">${scene.endingInfo.summary}</div>` : ''}
          </div>
        `;
      } else {
        // Choices
        const choices = ensureTwo(scene.choices || []);
        sceneHTML += '<div class="player-choices">';

        choices.forEach((choice, idx) => {
          const label = choice.label || `ì„ íƒì§€ ${String.fromCharCode(65 + idx)}`;
          const type = choice.type || 'scene';
          const disabled = (type === 'scene' && !choice.nextSceneId) ? 'disabled' : '';

          sceneHTML += `
            <button class="player-choice-btn" data-type="${type}" data-next="${choice.nextSceneId || ''}" ${disabled}>
              ${label}
            </button>
          `;
        });

        sceneHTML += '</div>';
      }

      container.innerHTML = sceneHTML;

      // Attach choice handlers
      container.querySelectorAll('.player-choice-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          const nextId = btn.dataset.next;

          playerPath.push(scene.name || scene.id);

          if (type === 'success') {
            playerSceneId = '__SUCCESS__';
          } else if (type === 'failure') {
            playerSceneId = '__FAILURE__';
          } else if (nextId) {
            playerSceneId = nextId;
          }

          renderPlayer();
        });
      });
    }

    function refreshStartSelect() {
      const select = byId('select-start-scene');
      select.innerHTML = '<option value="">ì‹œì‘ ì”¬ ì„ íƒ</option>';

      game.scenes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = `${s.id} - ${s.name}`;
        if (s.id === game.startSceneId) opt.selected = true;
        select.appendChild(opt);
      });
    }

    // ==================== Events ====================

    function addScene() {
      const newId = generateSceneId();
      const choiceIds = generateChoiceIds(newId);

      const newScene = {
        id: newId,
        name: 'ìƒˆ ì”¬',
        isEnding: false,
        content: 'TODO',
        choices: [
          { id: choiceIds[0], label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: choiceIds[1], label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes.push(newScene);
      game.updatedAt = nowISO();

      currentSceneId = newId;

      renderSceneList();
      renderEditor();
      refreshStartSelect();
    }

    function deleteScene(sceneId) {
      // Check if referenced by other scenes
      const references = [];
      game.scenes.forEach(s => {
        if (s.id === sceneId) return;
        const choices = ensureTwo(s.choices || []);
        choices.forEach(c => {
          if (c.nextSceneId === sceneId) {
            references.push(`${s.id} (${s.name})`);
          }
        });
      });

      if (references.length > 0) {
        const msg = `ë‹¤ìŒ ì”¬ì—ì„œ ì´ ì”¬ì„ ì°¸ì¡°í•˜ê³  ìˆìŠµë‹ˆë‹¤:\n${references.join('\n')}\n\nì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        if (!confirm(msg)) return;
      } else {
        if (!confirm(`ì”¬ ${sceneId}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
      }

      game.scenes = game.scenes.filter(s => s.id !== sceneId);
      game.updatedAt = nowISO();

      if (currentSceneId === sceneId) {
        currentSceneId = null;
      }

      if (game.startSceneId === sceneId) {
        game.startSceneId = game.scenes.length > 0 ? game.scenes[0].id : '';
      }

      renderSceneList();
      renderEditor();
      refreshStartSelect();
    }

    function toggleArchive(sceneId, archived) {
      const scene = findScene(sceneId);
      if (!scene) return;

      scene.isArchived = archived;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderSceneList();
    }

    function updateScene() {
      const scene = findScene(currentSceneId);
      if (!scene) return;

      scene.name = byId('edit-name').value;
      scene.isEnding = byId('edit-is-ending').checked;
      scene.content = byId('edit-content').value;

      if (scene.isEnding) {
        if (!scene.endingInfo) scene.endingInfo = {};
        scene.endingInfo.code = byId('edit-ending-code')?.value || '';
        scene.endingInfo.title = byId('edit-ending-title')?.value || '';
        scene.endingInfo.summary = byId('edit-ending-summary')?.value || '';

        // Show ending info
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.remove('hidden');
      } else {
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.add('hidden');
      }

      const choices = ensureTwo(scene.choices || []);

      // Choice A
      choices[0].label = byId('edit-choice-a-label').value;
      choices[0].note = byId('edit-choice-a-note').value;
      const typeA = document.querySelector('input[name="choice-a-type"]:checked')?.value || 'scene';
      choices[0].type = typeA;
      if (typeA === 'scene') {
        choices[0].nextSceneId = byId('edit-choice-a-next').value;
      } else {
        choices[0].nextSceneId = '';
      }

      // Choice B
      choices[1].label = byId('edit-choice-b-label').value;
      choices[1].note = byId('edit-choice-b-note').value;
      const typeB = document.querySelector('input[name="choice-b-type"]:checked')?.value || 'scene';
      choices[1].type = typeB;
      if (typeB === 'scene') {
        choices[1].nextSceneId = byId('edit-choice-b-next').value;
      } else {
        choices[1].nextSceneId = '';
      }

      scene.choices = choices;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderSceneList();

      // Update player if currently viewing this scene
      if (playerSceneId === currentSceneId) {
        renderPlayer();
      }
    }

    function startPlayer() {
      if (!game.startSceneId) {
        alert('ì‹œì‘ ì”¬ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        return;
      }

      playerSceneId = game.startSceneId;
      playerPath = [];
      renderPlayer();
    }

    function restartPlayer() {
      startPlayer();
    }

    // ==================== Validation ====================

    function validate() {
      const results = [];

      // Check startSceneId exists
      if (!game.startSceneId) {
        results.push({ type: 'error', msg: 'ì‹œì‘ ì”¬ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤' });
      } else if (!findScene(game.startSceneId)) {
        results.push({ type: 'error', msg: `ì‹œì‘ ì”¬ ${game.startSceneId}ì´(ê°€) ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤` });
      } else {
        const startScene = findScene(game.startSceneId);
        if (startScene.isEnding) {
          results.push({ type: 'warning', msg: 'ì‹œì‘ ì”¬ì´ ì—”ë”© ì”¬ì…ë‹ˆë‹¤' });
        }
      }

      // Check duplicate IDs
      const ids = game.scenes.map(s => s.id);
      const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);
      if (duplicates.length > 0) {
        results.push({ type: 'error', msg: `ì¤‘ë³µ ID ë°œê²¬: ${duplicates.join(', ')}` });
      }

      // Check each scene
      game.scenes.forEach(scene => {
        // Check choices length
        if (!scene.choices || scene.choices.length !== 2) {
          results.push({ type: 'error', msg: `ì”¬ ${scene.id}: ì„ íƒì§€ê°€ ì •í™•íˆ 2ê°œì—¬ì•¼ í•©ë‹ˆë‹¤` });
        }

        // Check nextSceneId validity
        const choices = ensureTwo(scene.choices || []);
        choices.forEach((choice, idx) => {
          const type = choice.type || 'scene';

          if (type === 'scene' && !choice.nextSceneId) {
            results.push({
              type: 'error',
              msg: `ì”¬ ${scene.id}, ì„ íƒì§€ ${String.fromCharCode(65 + idx)}: íƒ€ì…ì´ 'ë‹¤ìŒ ì”¬'ì¸ë° ì”¬ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤`
            });
          }

          if (type === 'scene' && choice.nextSceneId && !findScene(choice.nextSceneId)) {
            results.push({
              type: 'error',
              msg: `ì”¬ ${scene.id}, ì„ íƒì§€ ${String.fromCharCode(65 + idx)}: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì”¬ ì°¸ì¡° (${choice.nextSceneId})`
            });
          }
        });
      });

      // Check unreachable scenes
      if (game.startSceneId && findScene(game.startSceneId)) {
        const reachable = new Set();
        const queue = [game.startSceneId];

        while (queue.length > 0) {
          const id = queue.shift();
          if (reachable.has(id)) continue;
          reachable.add(id);

          const scene = findScene(id);
          if (!scene) continue;

          const choices = ensureTwo(scene.choices || []);
          choices.forEach(c => {
            const type = c.type || 'scene';
            if (type === 'scene' && c.nextSceneId && !reachable.has(c.nextSceneId)) {
              queue.push(c.nextSceneId);
            }
          });
        }

        const unreachable = game.scenes.filter(s => !reachable.has(s.id));
        if (unreachable.length > 0) {
          results.push({
            type: 'warning',
            msg: `ì‹œì‘ ì”¬ì—ì„œ ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œ ì”¬: ${unreachable.map(s => s.id).join(', ')}`
          });
        }
      }

      // Display results
      const panel = byId('validation-panel');
      const resultsContainer = byId('validation-results');

      if (results.length === 0) {
        results.push({ type: 'success', msg: 'âœ“ ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤!' });
      }

      resultsContainer.innerHTML = results.map(r =>
        `<div class="validation-item ${r.type}">${r.msg}</div>`
      ).join('');

      panel.classList.remove('hidden');

      // Auto-hide success after 3s
      if (results.every(r => r.type === 'success')) {
        setTimeout(() => panel.classList.add('hidden'), 3000);
      }
    }

    // ==================== Import/Export ====================

    function exportJSON() {
      const json = JSON.stringify(game, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${game.title.replace(/\s+/g, '-')}-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function importJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Basic validation
          if (!data.scenes || !Array.isArray(data.scenes)) {
            throw new Error('Invalid JSON: scenes ë°°ì—´ì´ ì—†ìŠµë‹ˆë‹¤');
          }

          game = data;
          currentSceneId = null;
          playerSceneId = null;
          playerPath = [];

          renderSceneList();
          renderEditor();
          refreshStartSelect();
          renderPlayer();

          alert('JSONì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤');
        } catch (err) {
          alert('JSON ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ==================== Boot ====================

    function init() {
      // Create initial scenes
      const s001 = {
        id: 'S001',
        name: 'ì‹œì‘',
        isEnding: false,
        content: 'TODO: ì‹œì‘ ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C001A', label: 'TODO', type: 'scene', nextSceneId: 'S002', note: '' },
          { id: 'C001B', label: 'TODO', type: 'scene', nextSceneId: 'S003', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s002 = {
        id: 'S002',
        name: 'ì¤‘ê°„ ì”¬',
        isEnding: false,
        content: 'TODO: ì¤‘ê°„ ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C002A', label: 'ì„±ê³µì ìœ¼ë¡œ í•´ê²°', type: 'success', nextSceneId: '', note: '' },
          { id: 'C002B', label: 'ì‹¤íŒ¨í•˜ê³  í¬ê¸°', type: 'failure', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s003 = {
        id: 'S003',
        name: 'ì—”ë”©',
        isEnding: true,
        endingInfo: {
          code: 'END-001',
          title: 'TODO Ending',
          summary: 'TODO: ì—”ë”© ìš”ì•½ì„ ì‘ì„±í•˜ì„¸ìš”'
        },
        content: 'TODO: ì—”ë”© ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C003A', label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: 'C003B', label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes = [s001, s002, s003];

      // Attach event listeners
      byId('btn-add-scene').addEventListener('click', addScene);
      byId('btn-generate-template').addEventListener('click', generateTemplateStory);
      byId('btn-validate').addEventListener('click', validate);
      byId('btn-export').addEventListener('click', exportJSON);
      byId('input-import').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          importJSON(e.target.files[0]);
        }
      });
      byId('btn-play').addEventListener('click', startPlayer);
      byId('btn-player-start').addEventListener('click', startPlayer);
      byId('btn-player-restart').addEventListener('click', restartPlayer);

      byId('select-start-scene').addEventListener('change', (e) => {
        game.startSceneId = e.target.value;
        game.updatedAt = nowISO();
      });

      byId('search-scene').addEventListener('input', renderSceneList);
      byId('sort-scene').addEventListener('change', renderSceneList);

      // Story flow controls
      byId('btn-toggle-flow').addEventListener('click', () => {
        const panel = byId('story-flow-panel');
        const isHidden = panel.classList.contains('hidden');

        if (isHidden) {
          panel.classList.remove('hidden');
          renderStoryFlow();
        } else {
          panel.classList.add('hidden');
        }
      });

      byId('btn-refresh-flow').addEventListener('click', renderStoryFlow);
      byId('btn-expand-all').addEventListener('click', renderStoryFlow);

      // Initial render
      renderSceneList();
      renderEditor();
      refreshStartSelect();
      renderPlayer();
    }

    // Start the app
    init();
  </script>
</body>
</html>
