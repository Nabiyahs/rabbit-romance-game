<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catch! Love â€” Editor</title>
  <style>
    /* ==================== Styles ==================== */
    :root {
      --color-1: #cccccc;
      --color-2: #999999;
      --color-3: #f5f5f5;
      --color-4: #666666;
      --color-5: #333333;
      --color-success: #555555;
      --color-failure: #777777;
      --shadow: 0 1px 2px rgba(0,0,0,0.05);
      --radius: 2px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #fafafa;
      min-height: 100vh;
      padding: 0;
      color: #333;
    }

    /* TopBar */
    .topbar {
      background: #e0e0e0;
      color: #333;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .topbar h1 {
      font-size: 1.5rem;
      margin-right: auto;
      font-weight: 600;
    }

    .topbar button, .topbar select, .topbar input[type="file"] {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .topbar button:hover {
      background: var(--color-3);
    }

    .topbar select {
      min-width: 150px;
    }

    /* Main Layout */
    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 1rem;
      max-width: 1800px;
      margin: 0 auto;
    }

    @media (min-width: 1024px) {
      .container {
        grid-template-columns: 30% 70%;
        padding: 1.5rem;
      }
    }

    /* Card Base */
    .card {
      background: white;
      border-radius: var(--radius);
      padding: 1.5rem;
      border: 1px solid #ddd;
    }

    /* Scene List */
    /* Story Tree Panel */
    .story-tree-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: calc(100vh - 120px);
      overflow: hidden;
    }

    .story-tree-header {
      padding-bottom: 1rem;
      border-bottom: 2px solid #ddd;
    }

    .story-tree-header h2 {
      margin-bottom: 0.5rem;
    }

    .story-tree-header select,
    .story-tree-header button {
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.85rem;
      background: white;
      cursor: pointer;
    }

    #story-tree-content {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      background: #fafafa;
      border: 1px solid #ddd;
      border-radius: var(--radius);
    }

    .tree-start {
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      background: #e8e8e8;
      border: 2px solid var(--color-5);
      border-radius: var(--radius);
      font-weight: 700;
      color: var(--color-5);
    }

    .tree-node {
      margin: 0.5rem 0;
      padding: 0.75rem;
      background: white;
      border: 1px solid #ddd;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
    }

    .tree-node:hover {
      background: #f0f0f0;
      border-color: #999;
      transform: translateX(3px);
    }

    .tree-node.active {
      background: #e8e8e8;
      border: 2px solid var(--color-5);
    }

    .tree-node-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
    }

    .tree-node-id {
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      font-weight: 700;
      color: #666;
    }

    .tree-node-name {
      font-weight: 600;
      color: var(--color-5);
      flex: 1;
    }

    .tree-node-badge {
      padding: 0.15rem 0.5rem;
      border-radius: 2px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .tree-node-badge.ending {
      background: var(--color-4);
      color: white;
    }

    .tree-node-badge.success {
      background: #4caf50;
      color: white;
    }

    .tree-node-badge.failure {
      background: #f44336;
      color: white;
    }

    .tree-choices {
      margin-top: 0.5rem;
      padding-left: 1rem;
      border-left: 3px solid #ddd;
    }

    .tree-choice {
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: var(--radius);
    }

    .tree-choice-label {
      font-weight: 600;
      color: var(--color-4);
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      display: block;
    }

    .tree-choice-text {
      font-size: 0.85rem;
      color: #666;
      margin-bottom: 0.5rem;
    }

    .tree-choice-arrow {
      color: #999;
      margin: 0 0.5rem;
      font-weight: 700;
    }

    .tree-ending-node {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.4rem 0.75rem;
      border-radius: var(--radius);
      font-weight: 600;
      font-size: 0.85rem;
    }

    .tree-ending-node.success {
      background: #e8f5e9;
      border: 1px solid #81c784;
      color: #2e7d32;
    }

    .tree-ending-node.failure {
      background: #ffebee;
      border: 1px solid #e57373;
      color: #c62828;
    }

    .tree-actions {
      display: inline-flex;
      gap: 0.25rem;
      margin-left: 0.5rem;
    }

    .tree-btn-add {
      padding: 0.25rem 0.5rem;
      background: var(--color-3);
      border: 1px solid #999;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.75rem;
      color: #333;
      font-weight: 600;
      transition: all 0.2s;
    }

    .tree-btn-add:hover {
      background: #e0e0e0;
      border-color: #666;
    }

    .tree-circular {
      color: #ff9800;
      font-weight: 600;
      font-style: italic;
    }

    .tree-empty {
      color: #999;
      font-style: italic;
    }

    .tree-branch {
      margin-left: 1.5rem;
      padding-left: 0.75rem;
      border-left: 2px solid #ddd;
      margin-top: 0.5rem;
    }

    .scene-item {
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .scene-item:hover {
      border-color: var(--color-4);
    }

    .scene-item.active {
      border-color: var(--color-5);
      background: var(--color-3);
    }

    .scene-item.archived {
      opacity: 0.5;
      background: #f5f5f5;
    }

    .scene-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .scene-item-id {
      font-weight: 700;
      color: var(--color-5);
      font-size: 0.85rem;
    }

    .scene-item-name {
      font-weight: 600;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .scene-item-badges {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }

    .badge {
      padding: 0.25rem 0.5rem;
      border-radius: 2px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .badge-ending {
      background: var(--color-4);
      color: white;
    }

    .badge-archived {
      background: #999;
      color: white;
    }

    .badge-success {
      background: var(--color-success);
      color: white;
    }

    .badge-failure {
      background: var(--color-failure);
      color: white;
    }

    .scene-item-choices {
      font-size: 0.8rem;
      color: #666;
      line-height: 1.4;
    }

    .scene-item-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.75rem;
    }

    .scene-item-actions button {
      padding: 0.25rem 0.75rem;
      border: 1px solid #999;
      border-radius: 2px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-delete {
      background: #888;
      color: white;
      border-color: #888;
    }

    .btn-archive {
      background: #999;
      color: white;
      border-color: #999;
    }

    .btn-unarchive {
      background: var(--color-1);
      color: #333;
      border-color: var(--color-1);
    }

    /* Right Panel */
    .right-panel {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Scene Editor */
    .scene-editor h2 {
      color: var(--color-5);
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ddd;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #555;
    }

    .form-group input[type="text"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.9rem;
      font-family: inherit;
    }

    .form-group textarea {
      min-height: 120px;
      resize: vertical;
    }

    .form-group input[type="checkbox"],
    .form-group input[type="radio"] {
      width: auto;
      margin-right: 0.5rem;
    }

    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--color-5);
    }

    .form-group input:read-only {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
    }

    .radio-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .radio-option {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      border-radius: 2px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .radio-option:hover {
      background: var(--color-3);
    }

    .radio-option label {
      cursor: pointer;
      margin-bottom: 0 !important;
      font-weight: normal !important;
    }

    .ending-info {
      background: var(--color-3);
      padding: 1rem;
      border-radius: var(--radius);
      margin-top: 0.5rem;
      border: 1px solid #ddd;
    }

    .choices-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      margin-top: 1rem;
    }

    @media (min-width: 768px) {
      .choices-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .choice-card {
      border: 1px solid #ccc;
      border-radius: var(--radius);
      padding: 1rem;
      background: #fafafa;
    }

    .choice-card h4 {
      color: var(--color-5);
      margin-bottom: 0.75rem;
    }

    .choice-type-scene {
      margin-top: 0.5rem;
    }

    /* Player */
    .player {
      background: #e8e8e8;
      color: #333;
      min-height: 400px;
      border: 1px solid #ccc;
    }

    .player h2 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ccc;
    }

    .player-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
    }

    .player-controls button {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .player-controls button:hover {
      background: var(--color-3);
    }

    .player-breadcrumb {
      background: #d0d0d0;
      padding: 0.75rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      font-size: 0.85rem;
      word-break: break-all;
      border: 1px solid #bbb;
    }

    .player-scene {
      background: white;
      color: #333;
      padding: 1.5rem;
      border-radius: var(--radius);
      margin-bottom: 1rem;
      border: 1px solid #ccc;
    }

    .player-scene-name {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .player-scene-content {
      line-height: 1.8;
      margin-bottom: 1.5rem;
      white-space: pre-wrap;
    }

    .player-choices {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .player-choice-btn {
      padding: 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.2s;
      text-align: left;
    }

    .player-choice-btn:hover:not(:disabled) {
      background: var(--color-3);
    }

    .player-choice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .player-ending {
      text-align: center;
      padding: 2rem;
      border-radius: var(--radius);
      color: #333;
      border: 1px solid #999;
    }

    .player-ending.success {
      background: #d0d0d0;
    }

    .player-ending.failure {
      background: #c0c0c0;
    }

    .player-ending.normal {
      background: #e0e0e0;
    }

    .player-ending h3 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .player-ending-code {
      font-size: 0.9rem;
      opacity: 0.9;
      margin-bottom: 0.5rem;
    }

    .player-ending-title {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }

    .player-ending-summary {
      line-height: 1.6;
      opacity: 0.95;
    }

    /* Validation Panel */
    .validation-panel {
      background: white;
      border: 1px solid #999;
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-top: 1rem;
    }

    .validation-panel h3 {
      color: var(--color-5);
      margin-bottom: 1rem;
    }

    .validation-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 2px;
      border-left: 3px solid;
    }

    .validation-item.error {
      background: #eeeeee;
      border-color: #888;
    }

    .validation-item.warning {
      background: #f5f5f5;
      border-color: #aaa;
    }

    .validation-item.success {
      background: #f0f0f0;
      border-color: #666;
    }

    .hidden {
      display: none;
    }

    /* Story Flow Visualizer */
    .story-flow {
      background: white;
      color: #333;
      min-height: 400px;
      border: 1px solid #ccc;
    }

    .story-flow h2 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #ccc;
    }

    .flow-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .flow-controls button {
      padding: 0.5rem 1rem;
      border: 1px solid #999;
      border-radius: var(--radius);
      background: white;
      color: #333;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .flow-controls button:hover {
      background: var(--color-3);
    }

    .flow-tree {
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      overflow-x: auto;
      padding: 1.5rem;
      background: #fafafa;
      border: 1px solid #ddd;
      border-radius: var(--radius);
      white-space: pre;
      max-height: 600px;
      overflow-y: auto;
    }

    .flow-node {
      cursor: pointer;
      padding: 0.15rem 0.5rem;
      border-radius: 2px;
      display: inline-block;
      margin: 0.15rem 0;
    }

    .flow-node:hover {
      background: #e0e0e0;
    }

    .flow-node.start {
      font-weight: 700;
      color: var(--color-5);
    }

    .flow-node.ending {
      color: var(--color-4);
      font-weight: 600;
    }

    .flow-node.success-choice {
      color: var(--color-success);
    }

    .flow-node.failure-choice {
      color: var(--color-failure);
    }

    .flow-stats {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--color-3);
      border: 1px solid #ddd;
      border-radius: var(--radius);
    }

    .flow-stats h3 {
      font-size: 1rem;
      margin-bottom: 0.75rem;
      color: var(--color-5);
    }

    .flow-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.75rem;
    }

    .flow-stat-item {
      padding: 0.75rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: var(--radius);
    }

    .flow-stat-label {
      font-size: 0.75rem;
      color: #666;
      margin-bottom: 0.25rem;
    }

    .flow-stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-5);
    }

    /* Scene Connection Tree (in Editor) */
    .scene-connection-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #ddd;
    }

    .scene-connection-section h3 {
      color: var(--color-5);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .connection-controls {
      margin-bottom: 1rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .connection-controls label {
      font-size: 0.85rem;
      color: #666;
    }

    .connection-controls select {
      padding: 0.25rem 0.5rem;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-size: 0.85rem;
    }

    .scene-connection-tree {
      background: #fafafa;
      border: 1px solid #ddd;
      border-radius: var(--radius);
      padding: 1.5rem;
      max-height: 500px;
      overflow-y: auto;
      font-size: 0.9rem;
    }

    .connection-current {
      background: #e8e8e8;
      border: 2px solid #999;
      border-radius: var(--radius);
      padding: 0.75rem 1rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
      color: var(--color-5);
    }

    .connection-branch {
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 2px solid #ccc;
      margin-top: 0.75rem;
    }

    .connection-choice {
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: white;
      border: 1px solid #ddd;
      border-radius: var(--radius);
    }

    .connection-choice-label {
      font-weight: 600;
      color: var(--color-4);
      margin-bottom: 0.25rem;
      display: block;
    }

    .connection-arrow {
      color: #999;
      margin: 0 0.5rem;
    }

    .connection-node {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.75rem;
      background: white;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
    }

    .connection-node:hover {
      background: #f0f0f0;
      border-color: #999;
      transform: translateX(2px);
    }

    .connection-node-id {
      font-family: 'Courier New', monospace;
      color: #666;
      font-size: 0.85rem;
    }

    .connection-node-name {
      color: var(--color-5);
    }

    .connection-ending {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.4rem 0.75rem;
      background: #f5f5f5;
      border: 1px solid #ccc;
      border-radius: var(--radius);
      font-weight: 600;
    }

    .connection-ending.success {
      background: #e8f5e9;
      border-color: #81c784;
      color: #2e7d32;
    }

    .connection-ending.failure {
      background: #ffebee;
      border-color: #e57373;
      color: #c62828;
    }

    .connection-actions {
      display: inline-flex;
      gap: 0.25rem;
      margin-left: 0.5rem;
    }

    .btn-add-scene-inline {
      padding: 0.25rem 0.5rem;
      background: var(--color-3);
      border: 1px solid #999;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.75rem;
      color: #333;
      transition: all 0.2s;
    }

    .btn-add-scene-inline:hover {
      background: #e0e0e0;
      border-color: #666;
    }

    .btn-toggle-ending {
      padding: 0.25rem 0.5rem;
      background: white;
      border: 1px solid #999;
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.2s;
    }

    .btn-toggle-ending:hover {
      background: #f0f0f0;
    }

    .connection-empty {
      color: #999;
      font-style: italic;
      padding: 0.5rem;
    }

    .connection-circular {
      color: #ff9800;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <!-- ==================== Layout ==================== -->

  <!-- TopBar -->
  <div class="topbar">
    <h1>Catch! Love â€” Editor</h1>
    <button id="btn-add-scene" aria-label="ìƒˆ ì”¬ ì¶”ê°€">â• ìƒˆ ì”¬</button>
    <button id="btn-generate-template" aria-label="ì¶”ì²œ í…œí”Œë¦¿ ìƒì„±">ğŸ“‹ ì¶”ì²œ êµ¬ì¡° ìƒì„±</button>
    <select id="select-start-scene" aria-label="ì‹œì‘ ì”¬ ì„ íƒ">
      <option value="">ì‹œì‘ ì”¬ ì„ íƒ</option>
    </select>
    <button id="btn-validate" aria-label="ìœ íš¨ì„± ê²€ì‚¬">âœ“ ê²€ì‚¬</button>
    <button id="btn-export" aria-label="JSON ë‚´ë³´ë‚´ê¸°">ğŸ’¾ ë‚´ë³´ë‚´ê¸°</button>
    <label style="padding: 0.5rem 1rem; background: white; border-radius: var(--radius); cursor: pointer; font-weight: 500; border: 1px solid #999;">
      ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°
      <input type="file" id="input-import" accept=".json" style="display: none;" aria-label="JSON ë¶ˆëŸ¬ì˜¤ê¸°">
    </label>
    <button id="btn-play" aria-label="í”Œë ˆì´ ëª¨ë“œ ì‹œì‘">â–¶ í”Œë ˆì´</button>
    <button id="btn-toggle-flow" aria-label="ìŠ¤í† ë¦¬ êµ¬ì¡° ë³´ê¸°">ğŸ—ºï¸ ìŠ¤í† ë¦¬ êµ¬ì¡°</button>
  </div>

  <!-- Main Container -->
  <div class="container">
    <!-- Left Panel: Story Tree -->
    <div class="card story-tree-panel">
      <div class="story-tree-header">
        <h2 style="color: var(--color-5);">ğŸŒ³ ìŠ¤í† ë¦¬ íŠ¸ë¦¬</h2>
        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
          <select id="tree-depth" aria-label="íŠ¸ë¦¬ ê¹Šì´">
            <option value="2">2ë‹¨ê³„</option>
            <option value="3">3ë‹¨ê³„</option>
            <option value="4" selected>4ë‹¨ê³„</option>
            <option value="5">5ë‹¨ê³„</option>
            <option value="99">ì „ì²´</option>
          </select>
          <button id="btn-refresh-tree" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">ìƒˆë¡œê³ ì¹¨</button>
        </div>
      </div>
      <div id="story-tree-content">
        <!-- Story tree will be rendered here -->
      </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
      <!-- Scene Editor -->
      <div class="card scene-editor">
        <h2>ì”¬ ì—ë””í„°</h2>
        <div id="editor-content">
          <p style="color: #999; text-align: center; padding: 2rem;">ì¢Œì¸¡ì—ì„œ ì”¬ì„ ì„ íƒí•˜ì„¸ìš”</p>
        </div>
      </div>

      <!-- Player Preview -->
      <div class="card player">
        <h2>í”Œë ˆì´ì–´ ë¯¸ë¦¬ë³´ê¸°</h2>
        <div class="player-controls">
          <button id="btn-player-start">ì‹œì‘</button>
          <button id="btn-player-restart">ì¬ì‹œì‘</button>
        </div>
        <div id="player-content">
          <p style="opacity: 0.8;">'ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ í”Œë ˆì´ë¥¼ ì‹œì‘í•˜ì„¸ìš”</p>
        </div>
      </div>

      <!-- Story Flow Visualizer -->
      <div id="story-flow-panel" class="card story-flow hidden">
        <h2>ìŠ¤í† ë¦¬ êµ¬ì¡°</h2>
        <div class="flow-controls">
          <button id="btn-refresh-flow">ìƒˆë¡œê³ ì¹¨</button>
          <button id="btn-expand-all">ì „ì²´ í¼ì¹˜ê¸°</button>
        </div>
        <div id="flow-content">
          <p style="color: #999; text-align: center; padding: 2rem;">ìŠ¤í† ë¦¬ êµ¬ì¡°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
        </div>
      </div>

      <!-- Validation Panel (hidden by default) -->
      <div id="validation-panel" class="validation-panel hidden">
        <h3>ìœ íš¨ì„± ê²€ì‚¬ ê²°ê³¼</h3>
        <div id="validation-results"></div>
      </div>
    </div>
  </div>

  <script>
    // ==================== State ====================

    let game = {
      id: 'game-001',
      title: 'Catch! Love',
      palette: ['#A1C3D1', '#B39BC8', '#F0EBF4', '#F172A1', '#E64398'],
      startSceneId: 'S001',
      scenes: [],
      createdAt: nowISO(),
      updatedAt: nowISO(),
      version: 1
    };

    let currentSceneId = null; // Currently selected scene in editor
    let playerSceneId = null;  // Current scene in player
    let playerPath = [];       // Breadcrumb trail

    // ==================== Utils ====================

    function nowISO() {
      return new Date().toISOString();
    }

    function byId(id) {
      return document.getElementById(id);
    }

    function getNextSceneNumber() {
      if (game.scenes.length === 0) return 1;
      const numbers = game.scenes.map(s => {
        const match = s.id.match(/^S(\d+)$/);
        return match ? parseInt(match[1], 10) : 0;
      });
      return Math.max(...numbers) + 1;
    }

    function generateSceneId() {
      const num = getNextSceneNumber();
      return 'S' + String(num).padStart(3, '0');
    }

    function generateChoiceIds(sceneId) {
      return [sceneId.replace('S', 'C') + 'A', sceneId.replace('S', 'C') + 'B'];
    }

    function findScene(sceneId) {
      return game.scenes.find(s => s.id === sceneId);
    }

    function ensureTwo(arr) {
      while (arr.length < 2) {
        arr.push({ id: '', label: '', type: 'scene', nextSceneId: '', note: '' });
      }
      return arr.slice(0, 2);
    }

    function getChoiceDisplay(choice) {
      if (choice.type === 'success') {
        return '[ì„±ê³µ ì—”ë”©]';
      } else if (choice.type === 'failure') {
        return '[ì‹¤íŒ¨ ì—”ë”©]';
      } else {
        return choice.nextSceneId || '?';
      }
    }

    // ==================== Template Generator ====================

    function generateTemplateStory() {
      if (game.scenes.length > 0) {
        if (!confirm('í˜„ì¬ ì”¬ë“¤ì´ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
          return;
        }
      }

      const scenes = [];
      const timestamp = nowISO();

      // ì¼ë°˜ ì”¬ 18ê°œ (S001-S018)
      for (let i = 1; i <= 18; i++) {
        const id = `S${String(i).padStart(3, '0')}`;

        // ë‹¤ìŒ ì”¬ ì—°ê²° (ê°„ë‹¨í•œ ë¶„ê¸° êµ¬ì¡°)
        let nextA, nextB;
        if (i === 18) {
          // ë§ˆì§€ë§‰ ì¼ë°˜ ì”¬ì€ ì„±ê³µ ì—”ë”©ìœ¼ë¡œ ì—°ê²°
          nextA = 'S019'; // ì„±ê³µ ì—”ë”© 1
          nextB = 'S020'; // ì„±ê³µ ì—”ë”© 2
        } else if (i >= 15) {
          // í›„ë°˜ë¶€ëŠ” ë‹¤ì–‘í•œ ì—”ë”©ìœ¼ë¡œ ë¶„ê¸°
          nextA = `S${String(i + 1).padStart(3, '0')}`;
          if (i === 15) nextB = 'S021'; // ì‹¤íŒ¨ ì—”ë”© 1
          else if (i === 16) nextB = 'S022'; // ì‹¤íŒ¨ ì—”ë”© 2
          else nextB = 'S023'; // ì‹¤íŒ¨ ì—”ë”© 3
        } else if (i >= 12) {
          // ì¤‘ë°˜ë¶€ ì‹¤íŒ¨ ë¶„ê¸°ì 
          nextA = `S${String(i + 1).padStart(3, '0')}`;
          nextB = i === 12 ? 'S024' : 'S025'; // ì‹¤íŒ¨ ì—”ë”© 4, 5
        } else {
          // ì´ˆë°˜ë¶€ ì¼ë°˜ì ì¸ ë¶„ê¸°
          nextA = `S${String(i + 1).padStart(3, '0')}`;
          nextB = `S${String(Math.min(i + 2, 18)).padStart(3, '0')}`;
        }

        scenes.push({
          id,
          name: `ì”¬ ${i}`,
          isEnding: false,
          content: '',
          choices: [
            { id: `C${String(i).padStart(3, '0')}A`, label: '', type: 'scene', nextSceneId: nextA, note: '' },
            { id: `C${String(i).padStart(3, '0')}B`, label: '', type: 'scene', nextSceneId: nextB, note: '' }
          ],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      // ì„±ê³µ ì—”ë”© 2ê°œ (S019-S020) - ì„ íƒì§€ ì—†ìŒ
      const successEndings = [
        { code: 'END-SUCCESS-001', title: 'ì„±ê³µ ì—”ë”© 1' },
        { code: 'END-SUCCESS-002', title: 'ì„±ê³µ ì—”ë”© 2' }
      ];

      for (let i = 0; i < 2; i++) {
        const sceneNum = 19 + i;
        const id = `S${String(sceneNum).padStart(3, '0')}`;

        scenes.push({
          id,
          name: successEndings[i].title,
          isEnding: true,
          endingInfo: {
            code: successEndings[i].code,
            title: successEndings[i].title,
            summary: ''
          },
          content: '',
          choices: [],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      // ì‹¤íŒ¨ ì—”ë”© 5ê°œ (S021-S025) - ì„ íƒì§€ ì—†ìŒ
      const failureEndings = [
        { code: 'END-FAILURE-001', title: 'ì‹¤íŒ¨ ì—”ë”© 1' },
        { code: 'END-FAILURE-002', title: 'ì‹¤íŒ¨ ì—”ë”© 2' },
        { code: 'END-FAILURE-003', title: 'ì‹¤íŒ¨ ì—”ë”© 3' },
        { code: 'END-FAILURE-004', title: 'ì‹¤íŒ¨ ì—”ë”© 4' },
        { code: 'END-FAILURE-005', title: 'ì‹¤íŒ¨ ì—”ë”© 5' }
      ];

      for (let i = 0; i < 5; i++) {
        const sceneNum = 21 + i;
        const id = `S${String(sceneNum).padStart(3, '0')}`;

        scenes.push({
          id,
          name: failureEndings[i].title,
          isEnding: true,
          endingInfo: {
            code: failureEndings[i].code,
            title: failureEndings[i].title,
            summary: ''
          },
          content: '',
          choices: [],
          createdAt: timestamp,
          updatedAt: timestamp,
          isArchived: false
        });
      }

      game.scenes = scenes;
      game.startSceneId = 'S001';
      game.updatedAt = timestamp;

      currentSceneId = null;

      renderStoryTree();
      renderEditor();
      refreshStartSelect();
      renderStoryFlow();

      alert(`ê²Œì„ êµ¬ì¡°ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì´ ${scenes.length}ê°œ ì”¬:\nâ€¢ ì¼ë°˜ ì”¬: 18ê°œ (S001-S018)\nâ€¢ ì„±ê³µ ì—”ë”©: 2ê°œ (S019-S020)\nâ€¢ ì‹¤íŒ¨ ì—”ë”©: 5ê°œ (S021-S025)\n\ní‰ê·  í”Œë ˆì´ ì‹œê°„: ì•½ 10ë¶„\n\nê° ì”¬ì˜ ë‚´ìš©ê³¼ ì„ íƒì§€ë¥¼ ì‘ì„±í•˜ì„¸ìš”.`);
    }

    // ==================== Story Flow Visualizer ====================

    function renderStoryFlow() {
      const container = byId('flow-content');

      if (game.scenes.length === 0) {
        container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">ì”¬ì´ ì—†ìŠµë‹ˆë‹¤. ì”¬ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì¶”ì²œ êµ¬ì¡°ë¥¼ ìƒì„±í•˜ì„¸ìš”.</p>';
        return;
      }

      // Build tree structure
      let html = '<div class="flow-tree">';

      const startScene = findScene(game.startSceneId);
      if (!startScene) {
        html += '<p style="color: #888;">ì‹œì‘ ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
      } else {
        const visited = new Set();
        html += buildFlowTree(startScene, '', visited, 0);
      }

      html += '</div>';

      // Add statistics
      const stats = calculateFlowStats();
      html += `
        <div class="flow-stats">
          <h3>ìŠ¤í† ë¦¬ í†µê³„</h3>
          <div class="flow-stats-grid">
            <div class="flow-stat-item">
              <div class="flow-stat-label">ì´ ì”¬ ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.totalScenes}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ì—”ë”© ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.endings}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ìµœëŒ€ ê¹Šì´</div>
              <div class="flow-stat-value">${stats.maxDepth}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">í‰ê·  í”Œë ˆì´ ê¸¸ì´</div>
              <div class="flow-stat-value">${stats.avgPath}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ë¶„ê¸°ì  ê°œìˆ˜</div>
              <div class="flow-stat-value">${stats.branches}</div>
            </div>
            <div class="flow-stat-item">
              <div class="flow-stat-label">ë„ë‹¬ ë¶ˆê°€ëŠ¥</div>
              <div class="flow-stat-value">${stats.unreachable}</div>
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;

      // Attach click handlers
      container.querySelectorAll('.flow-node').forEach(node => {
        node.addEventListener('click', () => {
          const sceneId = node.dataset.sceneId;
          if (sceneId) {
            currentSceneId = sceneId;
            renderStoryTree();
            renderEditor();
            // Scroll to editor
            byId('editor-content').scrollIntoView({ behavior: 'smooth' });
          }
        });
      });
    }

    function buildFlowTree(scene, prefix, visited, depth) {
      if (!scene || visited.has(scene.id)) {
        return '';
      }

      visited.add(scene.id);

      const isStart = scene.id === game.startSceneId;
      const classes = ['flow-node'];
      if (isStart) classes.push('start');
      if (scene.isEnding) classes.push('ending');

      let html = `${prefix}<span class="${classes.join(' ')}" data-scene-id="${scene.id}">${scene.id}: ${scene.name}</span>\n`;

      if (scene.isEnding) {
        return html;
      }

      const choices = ensureTwo(scene.choices || []);

      choices.forEach((choice, idx) => {
        const isLast = idx === choices.length - 1;
        const choicePrefix = isLast ? 'â””â”€â”€' : 'â”œâ”€â”€';
        const nextPrefix = isLast ? '    ' : 'â”‚   ';

        const choiceClasses = ['flow-node'];
        if (choice.type === 'success') choiceClasses.push('success-choice');
        if (choice.type === 'failure') choiceClasses.push('failure-choice');

        const label = choice.label || `ì„ íƒì§€ ${String.fromCharCode(65 + idx)}`;
        html += `${prefix}${choicePrefix} <span class="${choiceClasses.join(' ')}">[${String.fromCharCode(65 + idx)}] ${label}</span>`;

        if (choice.type === 'success') {
          html += ' âœ <span class="flow-node success-choice">âœ“ ì„±ê³µ ì—”ë”©</span>\n';
        } else if (choice.type === 'failure') {
          html += ' âœ <span class="flow-node failure-choice">âœ— ì‹¤íŒ¨ ì—”ë”©</span>\n';
        } else if (choice.nextSceneId) {
          const nextScene = findScene(choice.nextSceneId);
          if (nextScene) {
            html += ' âœ\n';
            if (visited.has(nextScene.id)) {
              html += `${prefix}${nextPrefix}<span class="flow-node" data-scene-id="${nextScene.id}">â†» ${nextScene.id} (ìˆœí™˜)</span>\n`;
            } else {
              html += buildFlowTree(nextScene, prefix + nextPrefix, visited, depth + 1);
            }
          } else {
            html += ` âœ <span style="color: #888;">[ì”¬ ì—†ìŒ: ${choice.nextSceneId}]</span>\n`;
          }
        } else {
          html += ' âœ <span style="color: #888;">[ì—°ê²° ì•ˆë¨]</span>\n';
        }
      });

      return html;
    }

    function calculateFlowStats() {
      const stats = {
        totalScenes: game.scenes.length,
        endings: game.scenes.filter(s => s.isEnding).length,
        maxDepth: 0,
        avgPath: 0,
        branches: 0,
        unreachable: 0
      };

      // Calculate reachable scenes
      if (game.startSceneId && findScene(game.startSceneId)) {
        const reachable = new Set();
        const queue = [{ id: game.startSceneId, depth: 0 }];
        let totalDepth = 0;
        let pathCount = 0;

        while (queue.length > 0) {
          const { id, depth } = queue.shift();
          if (reachable.has(id)) continue;
          reachable.add(id);

          stats.maxDepth = Math.max(stats.maxDepth, depth);

          const scene = findScene(id);
          if (!scene) continue;

          if (scene.isEnding) {
            totalDepth += depth;
            pathCount++;
          }

          const choices = ensureTwo(scene.choices || []);
          let validChoices = 0;

          choices.forEach(c => {
            const type = c.type || 'scene';
            if (type === 'scene' && c.nextSceneId) {
              validChoices++;
              if (!reachable.has(c.nextSceneId)) {
                queue.push({ id: c.nextSceneId, depth: depth + 1 });
              }
            } else if (type === 'success' || type === 'failure') {
              totalDepth += depth + 1;
              pathCount++;
            }
          });

          if (validChoices >= 2) {
            stats.branches++;
          }
        }

        stats.unreachable = game.scenes.length - reachable.size;
        stats.avgPath = pathCount > 0 ? Math.round(totalDepth / pathCount) : 0;
      }

      return stats;
    }

    // ==================== Renderers ====================

    // ==================== Story Tree Rendering ====================

    function renderStoryTree() {
      const container = byId('story-tree-content');
      if (!container) return;

      if (game.scenes.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #999;">ì”¬ì´ ì—†ìŠµë‹ˆë‹¤.<br>ìƒë‹¨ì˜ "ì¶”ì²œ êµ¬ì¡° ìƒì„±" ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.</div>';
        return;
      }

      const startScene = findScene(game.startSceneId);
      if (!startScene) {
        container.innerHTML = '<div style="text-align: center; padding: 2rem; color: #999;">ì‹œì‘ ì”¬ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</div>';
        return;
      }

      const depthSelect = byId('tree-depth');
      const maxDepth = depthSelect ? parseInt(depthSelect.value) : 4;

      let html = '<div class="tree-start">â–¶ ì‹œì‘: ' + startScene.id + ' - ' + (startScene.name || '(ì´ë¦„ ì—†ìŒ)') + '</div>';

      const visited = new Set();
      html += buildTreeNode(startScene, 0, maxDepth, visited);

      container.innerHTML = html;

      // Attach event handlers
      attachTreeHandlers();
    }

    function buildTreeNode(scene, depth, maxDepth, visited) {
      if (!scene || depth >= maxDepth || visited.has(scene.id)) {
        if (visited.has(scene.id)) {
          return `<div class="tree-circular" style="margin-left: ${depth * 1.5}rem;">â†» ${scene.id} (ìˆœí™˜ ì°¸ì¡°)</div>`;
        }
        return '';
      }

      visited.add(scene.id);

      let html = `<div class="tree-node ${scene.id === currentSceneId ? 'active' : ''}" data-scene-id="${scene.id}" style="margin-left: ${depth * 1.5}rem;">`;

      // Node header
      html += '<div class="tree-node-header">';
      html += `<span class="tree-node-id">${scene.id}</span>`;
      html += `<span class="tree-node-name">${scene.name || '(ì´ë¦„ ì—†ìŒ)'}</span>`;

      if (scene.isEnding) {
        const endingType = scene.endingInfo?.code?.includes('SUCCESS') ? 'success' : 'failure';
        html += `<span class="tree-node-badge ${endingType}">${endingType === 'success' ? 'âœ“ ì„±ê³µ' : 'âœ— ì‹¤íŒ¨'}</span>`;
      }

      html += '</div>';

      // Choices
      if (!scene.isEnding) {
        const choices = ensureTwo(scene.choices || []);
        html += '<div class="tree-choices">';

        // Choice A
        html += buildTreeChoice(choices[0], 'A', scene.id, depth, maxDepth, visited);

        // Choice B
        html += buildTreeChoice(choices[1], 'B', scene.id, depth, maxDepth, visited);

        html += '</div>';
      }

      html += '</div>';

      return html;
    }

    function buildTreeChoice(choice, label, parentSceneId, depth, maxDepth, visited) {
      if (!choice) return '';

      let html = '<div class="tree-choice">';
      html += `<span class="tree-choice-label">ì„ íƒì§€ ${label}</span>`;
      html += `<div class="tree-choice-text">${choice.label || '(ë¼ë²¨ ì—†ìŒ)'}</div>`;
      html += `<span class="tree-choice-arrow">â†’</span>`;

      if (choice.type === 'success') {
        html += '<span class="tree-ending-node success">âœ“ ì„±ê³µ ì—”ë”©</span>';
      } else if (choice.type === 'failure') {
        html += '<span class="tree-ending-node failure">âœ— ì‹¤íŒ¨ ì—”ë”©</span>';
      } else if (choice.nextSceneId) {
        const nextScene = findScene(choice.nextSceneId);

        if (!nextScene) {
          html += `<span class="tree-empty">[${choice.nextSceneId}] ì”¬ ì—†ìŒ</span>`;
          html += `<span class="tree-actions">`;
          html += `<button class="tree-btn-add" data-parent="${parentSceneId}" data-choice="${label}" data-target="${choice.nextSceneId}">+ ìƒì„±</button>`;
          html += `</span>`;
        } else {
          if (visited.has(nextScene.id)) {
            html += `<span class="tree-circular">â†» ${nextScene.id} (ìˆœí™˜)</span>`;
          } else {
            // Recursively build next scene
            html += '<div class="tree-branch">';
            html += buildTreeNode(nextScene, depth + 1, maxDepth, new Set(visited));
            html += '</div>';
          }
        }
      } else {
        html += '<span class="tree-empty">(ë¯¸ì—°ê²°)</span>';
        html += `<span class="tree-actions">`;
        html += `<button class="tree-btn-add" data-parent="${parentSceneId}" data-choice="${label}">+ ìƒˆ ì”¬</button>`;
        html += `</span>`;
      }

      html += '</div>';
      return html;
    }

    function attachTreeHandlers() {
      // Click scene node to edit
      document.querySelectorAll('.tree-node').forEach(node => {
        node.addEventListener('click', (e) => {
          // Prevent bubbling from inner elements
          if (e.target.classList.contains('tree-btn-add')) return;
          if (e.target.closest('.tree-choices')) {
            // Only handle clicks on the node header
            if (!e.target.closest('.tree-node-header')) return;
          }

          const sceneId = node.dataset.sceneId;
          if (sceneId) {
            currentSceneId = sceneId;
            renderStoryTree();
            renderEditor();
          }
        });
      });

      // Add scene buttons
      document.querySelectorAll('.tree-btn-add').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const parentSceneId = btn.dataset.parent;
          const choiceKey = btn.dataset.choice;
          const targetSceneId = btn.dataset.target;
          addSceneFromTree(parentSceneId, choiceKey, targetSceneId);
        });
      });
    }

    function addSceneFromTree(parentSceneId, choiceKey, targetSceneId = null) {
      const parentScene = findScene(parentSceneId);
      if (!parentScene) {
        alert('ë¶€ëª¨ ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }

      // Generate new scene ID
      let newSceneId = targetSceneId;
      if (!newSceneId) {
        const maxNum = game.scenes.reduce((max, s) => {
          const match = s.id.match(/^S(\d+)$/);
          return match ? Math.max(max, parseInt(match[1])) : max;
        }, 0);
        newSceneId = `S${String(maxNum + 1).padStart(3, '0')}`;
      }

      // Check if scene already exists
      if (findScene(newSceneId)) {
        // Just navigate to it
        currentSceneId = newSceneId;
        renderStoryTree();
        renderEditor();
        return;
      }

      // Create new scene
      const timestamp = nowISO();
      const newScene = {
        id: newSceneId,
        name: `ì”¬ ${game.scenes.length + 1}`,
        isEnding: false,
        content: '',
        choices: [
          { id: `${newSceneId}A`, label: '', type: 'scene', nextSceneId: '', note: '' },
          { id: `${newSceneId}B`, label: '', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: timestamp,
        updatedAt: timestamp,
        isArchived: false
      };

      game.scenes.push(newScene);
      game.updatedAt = timestamp;

      // Connect parent scene to new scene
      const choices = ensureTwo(parentScene.choices);
      const choiceIndex = choiceKey === 'A' ? 0 : 1;
      choices[choiceIndex].nextSceneId = newSceneId;
      choices[choiceIndex].type = 'scene';
      parentScene.updatedAt = timestamp;

      // Navigate to new scene
      currentSceneId = newSceneId;
      renderStoryTree();
      renderEditor();
    }

    function renderEditor() {
      const container = byId('editor-content');

      if (!currentSceneId) {
        container.innerHTML = '<p style="color: #999; text-align: center; padding: 2rem;">ì¢Œì¸¡ì—ì„œ ì”¬ì„ ì„ íƒí•˜ì„¸ìš”</p>';
        return;
      }

      const scene = findScene(currentSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #888; text-align: center; padding: 2rem;">ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</p>';
        return;
      }

      const choices = ensureTwo(scene.choices || []);
      const choiceA = choices[0];
      const choiceB = choices[1];

      const sceneOptions = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceA.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      const sceneOptionsB = game.scenes
        .map(s => `<option value="${s.id}" ${s.id === choiceB.nextSceneId ? 'selected' : ''}>${s.id} - ${s.name}</option>`)
        .join('');

      container.innerHTML = `
        <div class="form-group">
          <label>ì”¬ ID</label>
          <input type="text" id="edit-id" value="${scene.id}" readonly>
        </div>

        <div class="form-group">
          <label>ì”¬ ì´ë¦„</label>
          <input type="text" id="edit-name" value="${scene.name || ''}">
        </div>

        <div class="form-group">
          <div class="checkbox-group">
            <input type="checkbox" id="edit-is-ending" ${scene.isEnding ? 'checked' : ''}>
            <label for="edit-is-ending">ì—”ë”© ì”¬ìœ¼ë¡œ ì„¤ì •</label>
          </div>
        </div>

        <div id="ending-info-container" class="${scene.isEnding ? '' : 'hidden'}">
          <div class="ending-info">
            <div class="form-group">
              <label>ì—”ë”© ì½”ë“œ</label>
              <input type="text" id="edit-ending-code" value="${scene.endingInfo?.code || ''}">
            </div>
            <div class="form-group">
              <label>ì—”ë”© íƒ€ì´í‹€</label>
              <input type="text" id="edit-ending-title" value="${scene.endingInfo?.title || ''}">
            </div>
            <div class="form-group">
              <label>ì—”ë”© ìš”ì•½</label>
              <textarea id="edit-ending-summary">${scene.endingInfo?.summary || ''}</textarea>
            </div>
          </div>
        </div>

        <div class="form-group">
          <label>ì”¬ ë³¸ë¬¸</label>
          <textarea id="edit-content">${scene.content || ''}</textarea>
        </div>

        <h3 style="color: var(--color-5); margin: 1.5rem 0 1rem;">ì„ íƒì§€</h3>
        <div class="choices-container">
          <div class="choice-card">
            <h4>ì„ íƒì§€ A</h4>
            <div class="form-group">
              <label>ë¼ë²¨</label>
              <input type="text" id="edit-choice-a-label" value="${choiceA.label || ''}">
            </div>
            <div class="form-group">
              <label>íƒ€ì…</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-scene" name="choice-a-type" value="scene" ${(choiceA.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-scene">ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-success" name="choice-a-type" value="success" ${choiceA.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-success">ì„±ê³µ ì—”ë”©</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-a-type-failure" name="choice-a-type" value="failure" ${choiceA.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-a-type-failure">ì‹¤íŒ¨ ì—”ë”©</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-a-scene-select" ${(choiceA.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>ë‹¤ìŒ ì”¬</label>
              <select id="edit-choice-a-next">
                <option value="">ì„ íƒ ì•ˆí•¨</option>
                ${sceneOptions}
              </select>
            </div>
            <div class="form-group">
              <label>ë©”ëª¨ (ì„ íƒ)</label>
              <input type="text" id="edit-choice-a-note" value="${choiceA.note || ''}">
            </div>
          </div>

          <div class="choice-card">
            <h4>ì„ íƒì§€ B</h4>
            <div class="form-group">
              <label>ë¼ë²¨</label>
              <input type="text" id="edit-choice-b-label" value="${choiceB.label || ''}">
            </div>
            <div class="form-group">
              <label>íƒ€ì…</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-scene" name="choice-b-type" value="scene" ${(choiceB.type || 'scene') === 'scene' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-scene">ë‹¤ìŒ ì”¬ìœ¼ë¡œ ì§„í–‰</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-success" name="choice-b-type" value="success" ${choiceB.type === 'success' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-success">ì„±ê³µ ì—”ë”©</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="edit-choice-b-type-failure" name="choice-b-type" value="failure" ${choiceB.type === 'failure' ? 'checked' : ''}>
                  <label for="edit-choice-b-type-failure">ì‹¤íŒ¨ ì—”ë”©</label>
                </div>
              </div>
            </div>
            <div class="form-group choice-type-scene" id="choice-b-scene-select" ${(choiceB.type || 'scene') !== 'scene' ? 'style="display:none;"' : ''}>
              <label>ë‹¤ìŒ ì”¬</label>
              <select id="edit-choice-b-next">
                <option value="">ì„ íƒ ì•ˆí•¨</option>
                ${sceneOptionsB}
              </select>
            </div>
            <div class="form-group">
              <label>ë©”ëª¨ (ì„ íƒ)</label>
              <input type="text" id="edit-choice-b-note" value="${choiceB.note || ''}">
            </div>
          </div>
        </div>
      `;

      // Attach event listeners
      byId('edit-name').addEventListener('input', updateScene);
      byId('edit-is-ending').addEventListener('change', updateScene);
      byId('edit-content').addEventListener('input', updateScene);

      if (scene.isEnding) {
        byId('edit-ending-code').addEventListener('input', updateScene);
        byId('edit-ending-title').addEventListener('input', updateScene);
        byId('edit-ending-summary').addEventListener('input', updateScene);
      }

      byId('edit-choice-a-label').addEventListener('input', updateScene);
      byId('edit-choice-a-next').addEventListener('change', updateScene);
      byId('edit-choice-a-note').addEventListener('input', updateScene);
      byId('edit-choice-b-label').addEventListener('input', updateScene);
      byId('edit-choice-b-next').addEventListener('change', updateScene);
      byId('edit-choice-b-note').addEventListener('input', updateScene);

      // Choice type handlers
      ['a', 'b'].forEach(choice => {
        ['scene', 'success', 'failure'].forEach(type => {
          const radio = byId(`edit-choice-${choice}-type-${type}`);
          if (radio) {
            radio.addEventListener('change', () => {
              const sceneSelect = byId(`choice-${choice}-scene-select`);
              if (type === 'scene') {
                sceneSelect.style.display = 'block';
              } else {
                sceneSelect.style.display = 'none';
              }
              updateScene();
            });
          }
        });
      });
    }

    function renderPlayer() {
      const container = byId('player-content');

      if (!playerSceneId) {
        container.innerHTML = '<p style="opacity: 0.8;">\'ì‹œì‘\' ë²„íŠ¼ì„ ëˆŒëŸ¬ í”Œë ˆì´ë¥¼ ì‹œì‘í•˜ì„¸ìš”</p>';
        return;
      }

      // Check if it's a special ending
      if (playerSceneId === '__SUCCESS__' || playerSceneId === '__FAILURE__') {
        const endingType = playerSceneId === '__SUCCESS__' ? 'success' : 'failure';
        const endingTitle = playerSceneId === '__SUCCESS__' ? 'ì„±ê³µ ì—”ë”©' : 'ì‹¤íŒ¨ ì—”ë”©';
        const breadcrumb = playerPath.length > 0
          ? `<div class="player-breadcrumb">ê²½ë¡œ: ${playerPath.join(' â†’ ')}</div>`
          : '';

        container.innerHTML = `
          ${breadcrumb}
          <div class="player-ending ${endingType}">
            <h3>THE END</h3>
            <div class="player-ending-title">${endingTitle}</div>
          </div>
        `;
        return;
      }

      const scene = findScene(playerSceneId);
      if (!scene) {
        container.innerHTML = '<p style="color: #888;">ì”¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + playerSceneId + '</p>';
        return;
      }

      // Breadcrumb
      const breadcrumb = playerPath.length > 0
        ? `<div class="player-breadcrumb">ê²½ë¡œ: ${playerPath.join(' â†’ ')}</div>`
        : '';

      // Scene display
      let sceneHTML = `
        ${breadcrumb}
        <div class="player-scene">
          <div class="player-scene-name">${scene.name || '(ì´ë¦„ ì—†ìŒ)'}</div>
          <div class="player-scene-content">${scene.content || ''}</div>
        </div>
      `;

      if (scene.isEnding) {
        // Ending display
        sceneHTML += `
          <div class="player-ending normal">
            <h3>THE END</h3>
            ${scene.endingInfo?.code ? `<div class="player-ending-code">CODE: ${scene.endingInfo.code}</div>` : ''}
            ${scene.endingInfo?.title ? `<div class="player-ending-title">${scene.endingInfo.title}</div>` : ''}
            ${scene.endingInfo?.summary ? `<div class="player-ending-summary">${scene.endingInfo.summary}</div>` : ''}
          </div>
        `;
      } else {
        // Choices
        const choices = ensureTwo(scene.choices || []);
        sceneHTML += '<div class="player-choices">';

        choices.forEach((choice, idx) => {
          const label = choice.label || `ì„ íƒì§€ ${String.fromCharCode(65 + idx)}`;
          const type = choice.type || 'scene';
          const disabled = (type === 'scene' && !choice.nextSceneId) ? 'disabled' : '';

          sceneHTML += `
            <button class="player-choice-btn" data-type="${type}" data-next="${choice.nextSceneId || ''}" ${disabled}>
              ${label}
            </button>
          `;
        });

        sceneHTML += '</div>';
      }

      container.innerHTML = sceneHTML;

      // Attach choice handlers
      container.querySelectorAll('.player-choice-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const type = btn.dataset.type;
          const nextId = btn.dataset.next;

          playerPath.push(scene.name || scene.id);

          if (type === 'success') {
            playerSceneId = '__SUCCESS__';
          } else if (type === 'failure') {
            playerSceneId = '__FAILURE__';
          } else if (nextId) {
            playerSceneId = nextId;
          }

          renderPlayer();
        });
      });
    }

    function refreshStartSelect() {
      const select = byId('select-start-scene');
      select.innerHTML = '<option value="">ì‹œì‘ ì”¬ ì„ íƒ</option>';

      game.scenes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = `${s.id} - ${s.name}`;
        if (s.id === game.startSceneId) opt.selected = true;
        select.appendChild(opt);
      });
    }

    // ==================== Events ====================

    function addScene() {
      const newId = generateSceneId();
      const choiceIds = generateChoiceIds(newId);

      const newScene = {
        id: newId,
        name: 'ìƒˆ ì”¬',
        isEnding: false,
        content: 'TODO',
        choices: [
          { id: choiceIds[0], label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: choiceIds[1], label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes.push(newScene);
      game.updatedAt = nowISO();

      currentSceneId = newId;

      renderStoryTree();
      renderEditor();
      refreshStartSelect();
    }

    function deleteScene(sceneId) {
      // Check if referenced by other scenes
      const references = [];
      game.scenes.forEach(s => {
        if (s.id === sceneId) return;
        const choices = ensureTwo(s.choices || []);
        choices.forEach(c => {
          if (c.nextSceneId === sceneId) {
            references.push(`${s.id} (${s.name})`);
          }
        });
      });

      if (references.length > 0) {
        const msg = `ë‹¤ìŒ ì”¬ì—ì„œ ì´ ì”¬ì„ ì°¸ì¡°í•˜ê³  ìˆìŠµë‹ˆë‹¤:\n${references.join('\n')}\n\nì •ë§ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
        if (!confirm(msg)) return;
      } else {
        if (!confirm(`ì”¬ ${sceneId}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
      }

      game.scenes = game.scenes.filter(s => s.id !== sceneId);
      game.updatedAt = nowISO();

      if (currentSceneId === sceneId) {
        currentSceneId = null;
      }

      if (game.startSceneId === sceneId) {
        game.startSceneId = game.scenes.length > 0 ? game.scenes[0].id : '';
      }

      renderStoryTree();
      renderEditor();
      refreshStartSelect();
    }

    function toggleArchive(sceneId, archived) {
      const scene = findScene(sceneId);
      if (!scene) return;

      scene.isArchived = archived;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderStoryTree();
    }

    function updateScene() {
      const scene = findScene(currentSceneId);
      if (!scene) return;

      scene.name = byId('edit-name').value;
      scene.isEnding = byId('edit-is-ending').checked;
      scene.content = byId('edit-content').value;

      if (scene.isEnding) {
        if (!scene.endingInfo) scene.endingInfo = {};
        scene.endingInfo.code = byId('edit-ending-code')?.value || '';
        scene.endingInfo.title = byId('edit-ending-title')?.value || '';
        scene.endingInfo.summary = byId('edit-ending-summary')?.value || '';

        // Show ending info
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.remove('hidden');
      } else {
        const endingContainer = byId('ending-info-container');
        if (endingContainer) endingContainer.classList.add('hidden');
      }

      const choices = ensureTwo(scene.choices || []);

      // Choice A
      choices[0].label = byId('edit-choice-a-label').value;
      choices[0].note = byId('edit-choice-a-note').value;
      const typeA = document.querySelector('input[name="choice-a-type"]:checked')?.value || 'scene';
      choices[0].type = typeA;
      if (typeA === 'scene') {
        choices[0].nextSceneId = byId('edit-choice-a-next').value;
      } else {
        choices[0].nextSceneId = '';
      }

      // Choice B
      choices[1].label = byId('edit-choice-b-label').value;
      choices[1].note = byId('edit-choice-b-note').value;
      const typeB = document.querySelector('input[name="choice-b-type"]:checked')?.value || 'scene';
      choices[1].type = typeB;
      if (typeB === 'scene') {
        choices[1].nextSceneId = byId('edit-choice-b-next').value;
      } else {
        choices[1].nextSceneId = '';
      }

      scene.choices = choices;
      scene.updatedAt = nowISO();
      game.updatedAt = nowISO();

      renderStoryTree();

      // Update player if currently viewing this scene
      if (playerSceneId === currentSceneId) {
        renderPlayer();
      }
    }

    function startPlayer() {
      if (!game.startSceneId) {
        alert('ì‹œì‘ ì”¬ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
        return;
      }

      playerSceneId = game.startSceneId;
      playerPath = [];
      renderPlayer();
    }

    function restartPlayer() {
      startPlayer();
    }

    // ==================== Validation ====================

    function validate() {
      const results = [];

      // Check startSceneId exists
      if (!game.startSceneId) {
        results.push({ type: 'error', msg: 'ì‹œì‘ ì”¬ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤' });
      } else if (!findScene(game.startSceneId)) {
        results.push({ type: 'error', msg: `ì‹œì‘ ì”¬ ${game.startSceneId}ì´(ê°€) ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤` });
      } else {
        const startScene = findScene(game.startSceneId);
        if (startScene.isEnding) {
          results.push({ type: 'warning', msg: 'ì‹œì‘ ì”¬ì´ ì—”ë”© ì”¬ì…ë‹ˆë‹¤' });
        }
      }

      // Check duplicate IDs
      const ids = game.scenes.map(s => s.id);
      const duplicates = ids.filter((id, idx) => ids.indexOf(id) !== idx);
      if (duplicates.length > 0) {
        results.push({ type: 'error', msg: `ì¤‘ë³µ ID ë°œê²¬: ${duplicates.join(', ')}` });
      }

      // Check each scene
      game.scenes.forEach(scene => {
        // Check choices length
        if (!scene.choices || scene.choices.length !== 2) {
          results.push({ type: 'error', msg: `ì”¬ ${scene.id}: ì„ íƒì§€ê°€ ì •í™•íˆ 2ê°œì—¬ì•¼ í•©ë‹ˆë‹¤` });
        }

        // Check nextSceneId validity
        const choices = ensureTwo(scene.choices || []);
        choices.forEach((choice, idx) => {
          const type = choice.type || 'scene';

          if (type === 'scene' && !choice.nextSceneId) {
            results.push({
              type: 'error',
              msg: `ì”¬ ${scene.id}, ì„ íƒì§€ ${String.fromCharCode(65 + idx)}: íƒ€ì…ì´ 'ë‹¤ìŒ ì”¬'ì¸ë° ì”¬ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤`
            });
          }

          if (type === 'scene' && choice.nextSceneId && !findScene(choice.nextSceneId)) {
            results.push({
              type: 'error',
              msg: `ì”¬ ${scene.id}, ì„ íƒì§€ ${String.fromCharCode(65 + idx)}: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì”¬ ì°¸ì¡° (${choice.nextSceneId})`
            });
          }
        });
      });

      // Check unreachable scenes
      if (game.startSceneId && findScene(game.startSceneId)) {
        const reachable = new Set();
        const queue = [game.startSceneId];

        while (queue.length > 0) {
          const id = queue.shift();
          if (reachable.has(id)) continue;
          reachable.add(id);

          const scene = findScene(id);
          if (!scene) continue;

          const choices = ensureTwo(scene.choices || []);
          choices.forEach(c => {
            const type = c.type || 'scene';
            if (type === 'scene' && c.nextSceneId && !reachable.has(c.nextSceneId)) {
              queue.push(c.nextSceneId);
            }
          });
        }

        const unreachable = game.scenes.filter(s => !reachable.has(s.id));
        if (unreachable.length > 0) {
          results.push({
            type: 'warning',
            msg: `ì‹œì‘ ì”¬ì—ì„œ ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œ ì”¬: ${unreachable.map(s => s.id).join(', ')}`
          });
        }
      }

      // Display results
      const panel = byId('validation-panel');
      const resultsContainer = byId('validation-results');

      if (results.length === 0) {
        results.push({ type: 'success', msg: 'âœ“ ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤!' });
      }

      resultsContainer.innerHTML = results.map(r =>
        `<div class="validation-item ${r.type}">${r.msg}</div>`
      ).join('');

      panel.classList.remove('hidden');

      // Auto-hide success after 3s
      if (results.every(r => r.type === 'success')) {
        setTimeout(() => panel.classList.add('hidden'), 3000);
      }
    }

    // ==================== Import/Export ====================

    function exportJSON() {
      const json = JSON.stringify(game, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${game.title.replace(/\s+/g, '-')}-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function importJSON(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Basic validation
          if (!data.scenes || !Array.isArray(data.scenes)) {
            throw new Error('Invalid JSON: scenes ë°°ì—´ì´ ì—†ìŠµë‹ˆë‹¤');
          }

          game = data;
          currentSceneId = null;
          playerSceneId = null;
          playerPath = [];

          renderStoryTree();
          renderEditor();
          refreshStartSelect();
          renderPlayer();

          alert('JSONì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤');
        } catch (err) {
          alert('JSON ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ==================== Boot ====================

    function init() {
      // Create initial scenes
      const s001 = {
        id: 'S001',
        name: 'ì‹œì‘',
        isEnding: false,
        content: 'TODO: ì‹œì‘ ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C001A', label: 'TODO', type: 'scene', nextSceneId: 'S002', note: '' },
          { id: 'C001B', label: 'TODO', type: 'scene', nextSceneId: 'S003', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s002 = {
        id: 'S002',
        name: 'ì¤‘ê°„ ì”¬',
        isEnding: false,
        content: 'TODO: ì¤‘ê°„ ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C002A', label: 'ì„±ê³µì ìœ¼ë¡œ í•´ê²°', type: 'success', nextSceneId: '', note: '' },
          { id: 'C002B', label: 'ì‹¤íŒ¨í•˜ê³  í¬ê¸°', type: 'failure', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      const s003 = {
        id: 'S003',
        name: 'ì—”ë”©',
        isEnding: true,
        endingInfo: {
          code: 'END-001',
          title: 'TODO Ending',
          summary: 'TODO: ì—”ë”© ìš”ì•½ì„ ì‘ì„±í•˜ì„¸ìš”'
        },
        content: 'TODO: ì—”ë”© ì”¬ ë‚´ìš©ì„ ì‘ì„±í•˜ì„¸ìš”',
        choices: [
          { id: 'C003A', label: 'TODO', type: 'scene', nextSceneId: '', note: '' },
          { id: 'C003B', label: 'TODO', type: 'scene', nextSceneId: '', note: '' }
        ],
        createdAt: nowISO(),
        updatedAt: nowISO(),
        isArchived: false
      };

      game.scenes = [s001, s002, s003];

      // Attach event listeners
      byId('btn-add-scene').addEventListener('click', addScene);
      byId('btn-generate-template').addEventListener('click', generateTemplateStory);
      byId('btn-validate').addEventListener('click', validate);
      byId('btn-export').addEventListener('click', exportJSON);
      byId('input-import').addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          importJSON(e.target.files[0]);
        }
      });
      byId('btn-play').addEventListener('click', startPlayer);
      byId('btn-player-start').addEventListener('click', startPlayer);
      byId('btn-player-restart').addEventListener('click', restartPlayer);

      byId('select-start-scene').addEventListener('change', (e) => {
        game.startSceneId = e.target.value;
        game.updatedAt = nowISO();
        renderStoryTree();
      });

      // Story tree controls
      byId('tree-depth').addEventListener('change', renderStoryTree);
      byId('btn-refresh-tree').addEventListener('click', renderStoryTree);

      // Story flow controls
      byId('btn-toggle-flow').addEventListener('click', () => {
        const panel = byId('story-flow-panel');
        const isHidden = panel.classList.contains('hidden');

        if (isHidden) {
          panel.classList.remove('hidden');
          renderStoryFlow();
        } else {
          panel.classList.add('hidden');
        }
      });

      byId('btn-refresh-flow').addEventListener('click', renderStoryFlow);
      byId('btn-expand-all').addEventListener('click', renderStoryFlow);

      // Initial render
      renderStoryTree();
      renderEditor();
      refreshStartSelect();
      renderPlayer();
    }

    // Start the app
    init();
  </script>
</body>
</html>
